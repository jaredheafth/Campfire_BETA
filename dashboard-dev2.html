<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Campfire Widget - Dashboard</title>
    <!-- External CSS Files for Better Performance -->
    <link rel="stylesheet" href="styles/dashboard-base.css">
    <link rel="stylesheet" href="styles/dashboard-forms.css">
    <link rel="stylesheet" href="styles/dashboard-tabs.css">
    <link rel="stylesheet" href="styles/dashboard-modes.css">
    
    <!-- Performance Optimization Scripts -->
    <script src="scripts/performance-utils.js"></script>
    <script src="scripts/virtual-list.js"></script>
    <script src="scripts/performance-settings-ui.js"></script>
</head>
<body style="display: block !important; visibility: visible !important; opacity: 1 !important;">
    <div class="container" style="display: flex !important; visibility: visible !important; opacity: 1 !important;">
        
        <!-- Settings Modal -->
        <div id="settingsModal" class="settings-modal" onclick="if(event.target === this) closeSettings()">
            <div class="settings-modal-content" onclick="event.stopPropagation()">
                <div class="settings-modal-header">
                    <h2>‚öôÔ∏è Settings</h2>
                    <button class="settings-modal-close" onclick="closeSettings()">√ó</button>
                </div>
                
                <div class="settings-section-item">
                    <label>Default Sprites Path</label>
                    <div class="path-display" id="spritePathDisplay">Loading...</div>
                    <div class="path-info" id="spritePathInfo"></div>
                    <div class="path-actions">
                        <button class="button button-secondary" onclick="browseSpritePath()" style="flex: 1; min-width: 140px;">
                            üìÅ Browse Folder
                        </button>
                        <button class="button button-secondary" onclick="resetSpritePath()" id="resetSpritePathBtn" style="flex: 1; min-width: 140px; display: none;">
                            üîÑ Reset to Default
                        </button>
                    </div>
                </div>
                
                <div class="settings-section-item" style="border-top: 1px solid #333; padding-top: 20px; margin-top: 20px;">
                    <label>Widget Window Dimensions</label>
                    <div style="font-size: 11px; color: #888; margin-top: 5px; margin-bottom: 10px;">
                        Minimum: 640 x 360 pixels
                    </div>
                    <div style="margin-top: 10px; display: flex; gap: 15px; align-items: center; flex-wrap: wrap;">
                        <div style="flex: 1; min-width: 120px;">
                            <label style="font-size: 11px; color: #aaa; display: block; margin-bottom: 5px;">Width</label>
                            <input type="number" id="windowWidth" min="640" max="7680" step="1" style="width: 100%; padding: 6px; background: #2a2a2a; border: 1px solid #444; border-radius: 4px; color: #fff; font-size: 13px;">
                        </div>
                        <div style="flex: 1; min-width: 120px;">
                            <label style="font-size: 11px; color: #aaa; display: block; margin-bottom: 5px;">Height</label>
                            <input type="number" id="windowHeight" min="360" max="4320" step="1" style="width: 100%; padding: 6px; background: #2a2a2a; border: 1px solid #444; border-radius: 4px; color: #fff; font-size: 13px;">
                        </div>
                        <div style="display: flex; align-items: flex-end;">
                            <button id="toggleLockBtn" onclick="toggleWindowLock()" style="padding: 6px 14px; background: #444; border: 1px solid #666; border-radius: 4px; color: #fff; cursor: pointer; font-size: 13px; white-space: nowrap;">
                                üîì Unlock
                            </button>
                        </div>
                    </div>
                    <div style="margin-top: 10px; display: flex; gap: 10px;">
                        <button class="button button-secondary" onclick="applyWindowDimensions()" style="flex: 1; min-width: 140px;">
                            ‚úÖ Apply Dimensions
                        </button>
                    </div>
                    <div class="path-info" id="windowDimensionsInfo" style="margin-top: 8px; font-size: 11px; color: #888;"></div>

                    <div style="margin-top: 16px; border-top: 1px solid #333; padding-top: 16px;">
                        <label style="display:block; margin-bottom: 6px;">Capture Options</label>

                        <label style="display: flex; align-items: center; gap: 10px; cursor: pointer; font-size: 13px; color: #e0e0e0; margin-bottom: 8px;">
                            <input type="checkbox" id="useNativeFrame" checked onchange="updateFullPreview();" style="width: 16px; height: 16px; cursor: pointer;">
                            <span>Show Title Bar (native window frame)</span>
                        </label>
                        <div id="useNativeFrameHint" style="margin-top: 0; margin-bottom: 12px; font-size: 11px; color: #888;">
                            Tip: Turning this off makes the widget window frameless, and the in-widget menu bar becomes the draggable area.
                        </div>

                        <div>
                            <label style="font-size: 12px; color: #aaa; display: block; margin-bottom: 6px;">Widget Background</label>
                            <input type="hidden" id="widgetBackground" value="black">
                            <div class="bg-swatch-grid" aria-label="Widget Background">
                                <button type="button" class="bg-swatch bg-swatch-transparent" data-bg="transparent" onclick="setWidgetBackground('transparent')" title="Transparent"></button>
                                <button type="button" class="bg-swatch" data-bg="black" onclick="setWidgetBackground('black')" title="Black" style="background:#000;"></button>
                                <button type="button" class="bg-swatch" data-bg="white" onclick="setWidgetBackground('white')" title="White" style="background:#fff;"></button>
                                <button type="button" class="bg-swatch" data-bg="green" onclick="setWidgetBackground('green')" title="Green Screen" style="background:#00ff00;"></button>
                            </div>
                            <div style="margin-top: 8px; font-size: 11px; color: #888;">
                                Tip: Green is best for chroma key. Transparent depends on capture method (Browser Source is usually best).
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

    <!-- Status Indicator at Bottom Center -->
    <div style="position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%); z-index: 999999; display: flex; align-items: center; gap: 8px; padding: 8px 14px; background: rgba(26, 26, 26, 0.9); backdrop-filter: blur(10px); border: 1px solid rgba(255, 255, 255, 0.15); border-radius: 6px; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);">
        <div class="status-indicator" id="statusIndicator"></div>
        <span id="statusText" style="font-size: 11px; color: #fff;">Disconnected</span>
    </div>
    
        
        <div id="overlayBackdrop" onclick="closeOverlay()"></div>
        <div id="overlayCard">
            <div id="overlayBody">
                <div id="dashboardPanels">
        <div class="main-layout">
            <div class="settings-panel">
                <div class="info-box">
                    <strong>üìã How to Use:</strong> Configure your settings below, then copy the generated code and paste it into OBS as a Browser Source or Custom Widget.
                    <div style="margin-top: 10px; display: flex; align-items: center; justify-content: space-between; gap: 10px; flex-wrap: wrap;">
                        <!-- Left side: Action buttons -->
                        <div style="display: flex; align-items: center; gap: 10px; flex-wrap: wrap;">
                            <button onclick="kickAllUsersConfirm()" class="button-secondary" title="Kick all (non-test) users">
                                ‚òÅÔ∏è
                            </button>
                            <button onclick="joinAllUsersConfirm()" class="button-secondary" title="Join all users (non-test)">
                                üî•
                            </button>
                            <span style="font-weight: 600; color: #888; font-size: 12px;">Test Users:</span>
                            <button onclick="showAllTestUsers()" class="button-secondary" title="Show all test users">
                                ‚úÖ
                            </button>
                            <button onclick="hideAllTestUsers()" class="button-secondary" title="Hide all test users">
                                ‚ùå
                            </button>
                        </div>
                        <!-- Right side: Settings and Save buttons -->
                        <div style="display: flex; align-items: center; gap: 10px; flex-wrap: wrap;">
                            <button onclick="checkForUpdates()" class="button-secondary" title="Check for Updates">
                                üîÑ
                            </button>
                            <button onclick="openSettings()" class="button-secondary" title="App Settings">
                                ‚öôÔ∏è
                            </button>
                            <button onclick="saveSettingsWithNotification()" class="button button-primary" style="background: rgba(76, 175, 80, 0.3); border-color: rgba(76, 175, 80, 0.5);" title="Save Settings">
                                üíæ
                            </button>
                        </div>
                    </div>
                </div>

                <div class="tabs">
                    <button class="tab active" onclick="switchSettingsTab('campfire', this)">Campfire</button>
                    <button class="tab" onclick="switchSettingsTab('sprites', this)">Sprites</button>
                    <button class="tab" onclick="switchSettingsTab('glow', this)">Glow</button>
                    <button class="tab" onclick="switchSettingsTab('size', this)">Size & Perspective</button>
                    <button class="tab" onclick="switchSettingsTab('twitch', this)">Twitch</button>
                    <button class="tab" onclick="switchSettingsTab('chat', this)">Chat</button>
                    <button class="tab" onclick="switchSettingsTab('join', this)">Join</button>
                    <button class="tab" onclick="switchSettingsTab('members', this)">Members</button>
                    <button class="tab" onclick="switchSettingsTab('botmessages', this)">Bot Messages</button>
                    <button class="tab" onclick="switchSettingsTab('code', this)">Code</button>
                    <button class="tab" onclick="switchSettingsTab('audio', this)">Audio</button>
                </div>

                <div id="settingsTab" class="tab-content active">
                    <!-- Campfire Graphic Tab -->
                    <div id="campfireTab" class="settings-section active">
                        <div class="form-section">
                            <div class="form-group">
                                <label>
                                    Upload Method
                                    <span class="label-hint">Choose how to provide the campfire graphic</span>
                                </label>
                                <div style="display: flex; gap: 10px;">
                                    <button type="button" id="btnMethodUrl" class="button" onclick="setCampfireMethod('url')" style="flex: 1;">
                                        URL
                                    </button>
                                    <button type="button" id="btnMethodUpload" class="button-secondary" onclick="setCampfireMethod('upload')" style="flex: 1;">
                                        UPLOAD
                                    </button>
                                </div>
                            </div>

                            <div id="campfireUrlSection" class="form-group">
                                <label for="campfireUrl">
                                    Campfire GIF/Video URL
                                    <span class="label-hint">Enter a direct URL to a GIF or video file. You can upload to Imgur, Giphy, or any image hosting service.</span>
                                </label>
                                <input type="url" id="campfireUrl" placeholder="https://example.com/campfire.gif" oninput="updateFullPreview()">
                                <div id="campfireUrlStatus" style="margin-top: 8px; font-size: 12px; color: #888; display: none;">
                                    <span style="color: #ffa500;">‚ö†Ô∏è</span> You have an uploaded graphic that will be overridden if you use a URL
                                </div>
                            </div>

                            <div id="campfireUploadSection" class="form-group" style="display: none;">
                                <label for="campfireUpload">
                                    Upload Campfire Graphic
                                    <span class="label-hint">Upload a GIF, image, or video file for your campfire</span>
                                </label>
                                <div style="display: flex; align-items: center; gap: 10px; flex-wrap: wrap;">
                                    <input type="file" id="campfireUpload" accept="image/*,.gif,video/*,.mp4,.webm,.mov" onchange="handleCampfireUpload(event)" style="flex: 1; min-width: 200px;">
                                    <button type="button" class="button-secondary" onclick="clearCampfireUpload()">üóëÔ∏è Clear Upload</button>
                                    <button type="button" class="button-secondary" onclick="clearAllGraphics()">üóëÔ∏è Clear All Graphics (Fix Issues)</button>
                                </div>
                                <div id="campfirePreview" class="sprite-preview" style="margin-top: 10px;">
                                    <span style="color: #888; font-size: 12px;">No campfire graphic uploaded</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Glow Settings Tab -->
                    <div id="glowTab" class="settings-section">
                        <div class="form-section">
                            <div class="form-group">
                                <label for="glowSize">
                                    Glow Size
                                    <span class="label-hint">Size of the glow effect around the campfire</span>
                                </label>
                                <div class="range-container">
                                    <input type="range" id="glowSize" min="100" max="800" value="500" step="10" oninput="updateGlowSizeDisplay(); updateFullPreview();">
                                    <div class="range-value" id="glowSizeValue">500px</div>
                                </div>
                            </div>

                            <div class="form-group">
                                <label for="glowIntensity">
                                    Glow Intensity
                                    <span class="label-hint">Overall opacity/brightness of the glow</span>
                                </label>
                                <div class="range-container">
                                    <input type="range" id="glowIntensity" min="0" max="100" value="77" step="1" oninput="updateGlowIntensityDisplay(); updateFullPreview();">
                                    <div class="range-value" id="glowIntensityValue">77%</div>
                                </div>
                            </div>

                            <div class="form-group">
                                <label for="shadowIntensity">
                                    Shadow Intensity
                                    <span class="label-hint">Intensity of drop shadows on the fire emoji</span>
                                </label>
                                <div class="range-container">
                                    <input type="range" id="shadowIntensity" min="0" max="100" value="91" step="1" oninput="updateShadowIntensityDisplay(); updateFullPreview();">
                                    <div class="range-value" id="shadowIntensityValue">91%</div>
                                </div>
                            </div>

                            <div class="form-group">
                                <label for="glowSpread">
                                    Glow Spread
                                    <span class="label-hint">How far the glow extends outward</span>
                                </label>
                                <div class="range-container">
                                    <input type="range" id="glowSpread" min="20" max="100" value="64" step="1" oninput="updateGlowSpreadDisplay(); updateFullPreview();">
                                    <div class="range-value" id="glowSpreadValue">64%</div>
                                </div>
                                <div class="range-labels">
                                    <span>Concentrated</span>
                                    <span>Diffused</span>
                                </div>
                            </div>

                            <div class="form-group" style="margin-bottom: 0;">
                                <div class="checkbox-group">
                                    <input type="checkbox" id="animatedGlow" checked onchange="updateFullPreview()">
                                    <label for="animatedGlow" style="margin: 0;">Animated Glow</label>
                                </div>
                                <span class="label-hint">Creates a gentle pulsing fire effect</span>
                            </div>

                            <div class="form-group" style="margin-top: 14px;">
                                <label for="flickerOpacity">
                                    Flicker Opacity
                                    <span class="label-hint">A second glow layer that sits in front of the campfire</span>
                                </label>
                                <div class="range-container">
                                    <input type="range" id="flickerOpacity" min="0" max="100" value="25" step="1" oninput="updateFlickerOpacityDisplay(); updateFullPreview();">
                                    <div class="range-value" id="flickerOpacityValue">25%</div>
                                </div>
                            </div>

                            <div class="form-group">
                                <label for="flickerSpread">
                                    Flicker Size / Spread
                                    <span class="label-hint">How wide the flicker glow expands (front layer)</span>
                                </label>
                                <div class="range-container">
                                    <input type="range" id="flickerSpread" min="20" max="100" value="55" step="1" oninput="updateFlickerSpreadDisplay(); updateFullPreview();">
                                    <div class="range-value" id="flickerSpreadValue">55%</div>
                                </div>
                                <div class="range-labels">
                                    <span>Tight</span>
                                    <span>Wide</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Size Settings Tab -->
                    <div id="sizeTab" class="settings-section">
                        <div class="form-section">
                            <div class="form-group">
                                <label for="fireSize">
                                    Fire Size
                                    <span class="label-hint">Size of the fire emoji/graphic (in pixels)</span>
                                </label>
                                <div class="range-container">
                                    <input type="range" id="fireSize" min="24" max="120" value="48" step="2" oninput="updateFireSizeDisplay();">
                                    <div class="range-value" id="fireSizeValue">48px</div>
                                </div>
                            </div>

                            <div class="form-group">
                                <label for="spriteSize">
                                    Sprite Size
                                    <span class="label-hint">Size of user sprites/shapes (in pixels)</span>
                                </label>
                                <div class="range-container">
                                    <input type="range" id="spriteSize" min="20" max="300" value="40" step="5" oninput="updateSpriteSizeDisplay();">
                                    <div class="range-value" id="spriteSizeValue">40px</div>
                                </div>
                            </div>

                            <div class="form-group">
                                <label for="circleAngle">
                                    View Angle
                                    <span class="label-hint">Adjust from top-down view (circle) to side view (ellipse/line)</span>
                                </label>
                                <div class="range-container">
                                    <input type="range" id="circleAngle" min="0" max="90" value="64" step="1" oninput="updateAngleDisplay(); updateFullPreview();">
                                    <div class="range-value" id="angleValue">64¬∞</div>
                                </div>
                                <div class="range-labels">
                                    <span>Top-Down (Circle)</span>
                                    <span>Side View (Line)</span>
                                </div>
                            </div>

                            <div class="form-group">
                                <label for="campfireYOffset">
                                    Campfire Vertical Offset
                                    <span class="label-hint">Move the campfire graphic up/down. Center is 50.</span>
                                </label>
                                <div class="range-container">
                                    <input type="range" id="campfireYOffset" min="0" max="100" value="50" step="1" oninput="updateCampfireYOffsetDisplay();">
                                    <div class="range-value" id="campfireYOffsetValue">50 (+0px)</div>
                                </div>
                                <div class="range-labels">
                                    <span>Up</span>
                                    <span>Down</span>
                                </div>
                            </div>
                        </div>
                    </div>


                    <!-- Twitch Connection Tab -->
                    <div id="twitchTab" class="settings-section">
                        <div class="form-section">
                            <div class="form-group">
                                <label>
                                    Twitch Connection
                                    <span class="label-hint">Connect your Twitch account to enable chat integration</span>
                                </label>
                                <div id="twitchConnectionStatus" style="padding: 15px; background: #2a2a2a; border-radius: 8px; margin-bottom: 15px;">
                                    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
                                        <span id="twitchStatusIcon">‚ö™</span>
                                        <span id="twitchStatusText">Not Connected</span>
                                    </div>
                                    <div id="twitchConfigDisplay" style="display: none; font-size: 12px; color: #888; margin-top: 10px;">
                                        <div>Username: <span id="twitchUsernameDisplay">-</span></div>
                                        <div>Channel: <span id="twitchChannelDisplay">-</span></div>
                                    </div>
                                </div>
                                
                            </div>
                            
                            <!-- Top controls: Checkbox and Save button -->
                            <div style="display: flex; align-items: center; justify-content: space-between; margin-top: 20px; margin-bottom: 15px; padding: 12px; background: #1f1f1f; border-radius: 6px; border: 1px solid #333;">
                                <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; font-size: 14px; color: #fff;">
                                    <input type="checkbox" id="useSeparateChatBot" onchange="toggleChatBotInputs()" style="cursor: pointer; width: 16px; height: 16px;">
                                    <span>Use separate bot account for sending messages</span>
                                </label>
                                <button type="button" class="button button-primary" onclick="saveTwitchConfig()" style="padding: 8px 20px; font-size: 13px;">
                                    üíæ Save Configuration
                                </button>
                            </div>
                            
                            <div class="form-group">
                                <label for="twitchChannelName">
                                    Channel Name
                                    <span class="label-hint">Channel to monitor (usually same as your username)</span>
                                </label>
                                <input type="text" id="twitchChannelName" placeholder="your_channel" oninput="updateTwitchConfig(); autoFillUsernameFromChannel();">
                            </div>
                            
                            <!-- Side-by-side layout for Main Account and Chat Bot Account -->
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 20px;">
                                <!-- Main Account Column -->
                                <div style="border: 1px solid #333; border-radius: 8px; padding: 15px; background: #1f1f1f;">
                                    <h3 style="margin-top: 0; margin-bottom: 15px; color: #ff6b35; font-size: 16px;">üì∫ Main Account</h3>
                                    
                            <div class="form-group">
                                <label for="twitchBotUsername">
                                    Twitch Username
                                    <span class="label-hint">Your Twitch username</span>
                                </label>
                                <input type="text" id="twitchBotUsername" placeholder="your_username" readonly onfocus="this.removeAttribute('readonly')" onblur="this.setAttribute('readonly', ''); autoFillUsernameFromChannel();" style="background: #2a2a2a; cursor: text;" oninput="updateTwitchConfig()">
                            </div>
                                    
                                    <div class="form-group">
                                        <label for="twitchAccessToken">
                                            ACCESS TOKEN
                                            <span class="label-hint">From token generator</span>
                                        </label>
                                        <div style="display: flex; gap: 5px; margin-bottom: 10px;">
                                            <input type="password" id="twitchAccessToken" placeholder="Access Token..." style="flex: 1; font-size: 11px;">
                                            <button type="button" class="button button-secondary" onclick="toggleAccessTokenVisibility()" style="white-space: nowrap; padding: 5px 10px; font-size: 11px;">
                                                üëÅÔ∏è
                                            </button>
                                        </div>
                                    </div>
                                    
                                    <div class="form-group">
                                        <label for="twitchRefreshToken">
                                            REFRESH TOKEN
                                            <span class="label-hint">From token generator (optional)</span>
                                        </label>
                                        <div style="display: flex; gap: 5px; margin-bottom: 10px;">
                                            <input type="password" id="twitchRefreshToken" placeholder="Refresh Token..." style="flex: 1; font-size: 11px;">
                                            <button type="button" class="button button-secondary" onclick="toggleRefreshTokenVisibility()" style="white-space: nowrap; padding: 5px 10px; font-size: 11px;">
                                                üëÅÔ∏è
                                            </button>
                                        </div>
                                    </div>
                                    
                                    <div class="form-group">
                                        <label for="twitchClientId">
                                            CLIENT ID
                                            <span class="label-hint">From token generator</span>
                                        </label>
                                        <input type="text" id="twitchClientId" placeholder="Client ID..." style="width: 100%; font-size: 11px;">
                                    </div>
                                    
                                    <button type="button" class="button button-primary" id="generateTwitchToken" onclick="generateTwitchToken('main')" style="width: 100%; margin-top: 10px; font-size: 12px;">
                                        üîë Generate Token
                                    </button>
                                    
                                    <div style="display: flex; gap: 8px; margin-top: 8px;">
                                        <button type="button" class="button button-primary" onclick="connectTwitchAccount('main')" style="flex: 1; font-size: 12px; background: #4caf50;">
                                            üîå Connect
                                        </button>
                                        <button type="button" class="button button-secondary" id="disconnectMainBtn" onclick="disconnectTwitchAccount('main')" style="flex: 1; font-size: 12px; background: #ff4444; display: none;">
                                            üîå Disconnect
                                        </button>
                                    </div>
                                </div>
                                
                                <!-- Chat Bot Account Column -->
                                <div style="border: 1px solid #333; border-radius: 8px; padding: 15px; background: #1f1f1f;">
                                        <h3 style="margin-top: 0; margin-bottom: 15px; color: #ff6b35; font-size: 16px;">ü§ñ Chat Bot Account</h3>
                                    
                                    <div class="form-group">
                                        <label for="twitchChatBotUsername">
                                            Twitch Username
                                            <span class="label-hint">Bot account username</span>
                                        </label>
                                        <input type="text" id="twitchChatBotUsername" placeholder="bot_username" oninput="updateTwitchConfig()" disabled style="opacity: 0.5; cursor: not-allowed;">
                                    </div>
                                    
                                    <div class="form-group">
                                        <label for="twitchChatBotAccessToken">
                                            ACCESS TOKEN
                                            <span class="label-hint">From token generator</span>
                                        </label>
                                        <div style="display: flex; gap: 5px; margin-bottom: 10px;">
                                            <input type="password" id="twitchChatBotAccessToken" placeholder="Access Token..." style="flex: 1; font-size: 11px;" disabled>
                                            <button type="button" class="button button-secondary" onclick="toggleChatBotAccessTokenVisibility()" style="white-space: nowrap; padding: 5px 10px; font-size: 11px;" disabled>
                                                üëÅÔ∏è
                                            </button>
                                        </div>
                                    </div>
                                    
                                    <div class="form-group">
                                        <label for="twitchChatBotRefreshToken">
                                            REFRESH TOKEN
                                            <span class="label-hint">From token generator (optional)</span>
                                        </label>
                                        <div style="display: flex; gap: 5px; margin-bottom: 10px;">
                                            <input type="password" id="twitchChatBotRefreshToken" placeholder="Refresh Token..." style="flex: 1; font-size: 11px;" disabled>
                                            <button type="button" class="button button-secondary" onclick="toggleChatBotRefreshTokenVisibility()" style="white-space: nowrap; padding: 5px 10px; font-size: 11px;" disabled>
                                                üëÅÔ∏è
                                            </button>
                                        </div>
                                    </div>
                                    
                                    <div class="form-group">
                                        <label for="twitchChatBotClientId">
                                            CLIENT ID
                                            <span class="label-hint">From token generator</span>
                                        </label>
                                        <input type="text" id="twitchChatBotClientId" placeholder="Client ID..." style="width: 100%; font-size: 11px;" disabled>
                                    </div>
                                    
                                    <button type="button" class="button button-primary" id="generateChatBotToken" onclick="generateTwitchToken('chatbot')" style="width: 100%; margin-top: 10px; font-size: 12px;" disabled>
                                        üîë Generate Token
                                    </button>
                                    
                                    <div style="display: flex; gap: 8px; margin-top: 8px;">
                                        <button type="button" class="button button-primary" id="connectChatBotBtn" onclick="connectTwitchAccount('chatbot')" style="flex: 1; font-size: 12px; background: #4caf50;" disabled>
                                            üîå Connect
                                        </button>
                                        <button type="button" class="button button-secondary" id="disconnectChatBotBtn" onclick="disconnectTwitchAccount('chatbot')" style="flex: 1; font-size: 12px; background: #ff4444; display: none;" disabled>
                                            üîå Disconnect
                                        </button>
                                    </div>
                                </div>
                            </div>
                            </div>
                            
                            <div style="margin-top: 15px; padding: 10px; background: #1a1a1a; border-radius: 5px; border-left: 3px solid #ff6b35;">
                                <p style="margin: 0; font-size: 11px; color: #888;">
                                    üí° <strong>Tip:</strong> Click "Generate Token" to open the token generator. Use the checkbox at the top to configure a separate bot account for sending messages.
                                </p>
                            </div>
                            
                            <div style="margin-top: 20px; padding: 15px; background: #1a1a1a; border-radius: 8px; border-left: 3px solid #ff6b35;">
                                <strong style="color: #ff6b35;">‚ÑπÔ∏è How it works:</strong>
                                <ol style="margin-top: 10px; padding-left: 20px; font-size: 13px; line-height: 1.8;">
                                    <li>Enter your Twitch username (channel name will auto-fill)</li>
                                    <li>Click "Generate Token" to open the token generator</li>
                                    <li>Copy and paste your Access Token, Refresh Token, and Client ID</li>
                                    <li>Click "Save Configuration" at the top</li>
                                    <li>The widget will automatically connect to your channel</li>
                                </ol>
                                <p style="margin-top: 10px; font-size: 12px; color: #888;">
                                    <strong>Why Channel Name?</strong> The channel name tells the widget which Twitch channel's chat to monitor. 
                                    It's usually the same as your username, but you can monitor a different channel if needed (e.g., if you're using a bot account to monitor another streamer's chat).
                                </p>
                            </div>
                        </div>
                    </div>

                    <!-- Twitch Chat Tab -->
                    <div id="chatTab" class="settings-section">
                        <div class="form-section">
                            <div class="form-group">
                                <label>
                                    Twitch Chat
                                    <span class="label-hint">Live chat from your channel. Connect in the Twitch tab to see messages.</span>
                                </label>
                                <div id="twitchChatLog" style="height: 320px; overflow-y: auto; background: #1a1a1a; border: 1px solid #333; border-radius: 8px; padding: 12px; font-family: 'Consolas', 'Monaco', monospace; font-size: 13px; line-height: 1.5;">
                                    <div id="twitchChatEmpty" style="color: #666;">Connect to Twitch in the Twitch tab to see chat. Messages will appear here when they're sent in your channel.</div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Join Settings Tab -->
                    <div id="joinTab" class="settings-section">
                        <div class="form-section">
                            <!-- Join Method, Command/Emote/Cheer, and Max Users in one row -->
                            <div class="form-row">
                                <!-- Join Method -->
                                <div class="form-group form-group-compact">
                                    <label for="joinMethod">
                                        Join Method
                                        <span class="label-hint">How viewers join</span>
                                    </label>
                                    <select id="joinMethod" onchange="updateJoinMethod(); updateFullPreview();">
                                        <option value="command">Chat Command</option>
                                        <option value="emote">Emote</option>
                                        <option value="cheer">Cheer/Payment</option>
                                    </select>
                                </div>

                                <!-- Command Settings (shown when method is "command") -->
                                <div id="commandSettings" class="form-group form-group-compact">
                                    <label for="command">
                                        Command Text
                                        <span class="label-hint">e.g., !join, !camp</span>
                                    </label>
                                    <input type="text" id="command" value="!join" placeholder="!join" oninput="updateFullPreview();">
                                </div>

                                <!-- Emote Settings (shown when method is "emote") -->
                                <div id="emoteSettings" class="form-group form-group-compact" style="display: none;">
                                    <label for="emoteName">
                                        Emote Name
                                        <span class="label-hint">e.g., Campfire</span>
                                    </label>
                                    <input type="text" id="emoteName" value="" placeholder="Campfire" oninput="updateFullPreview();">
                                </div>

                                <!-- Cheer Settings (shown when method is "cheer") -->
                                <div id="cheerSettings" class="form-group form-group-compact" style="display: none;">
                                    <label for="cheerMethod">
                                        Payment Type
                                        <span class="label-hint">What they pay with</span>
                                    </label>
                                    <select id="cheerMethod" onchange="updateFullPreview();">
                                        <option value="bits">Bits</option>
                                        <option value="giftsubs">Gift Subs</option>
                                        <option value="both">Bits or Gift Subs</option>
                                    </select>
                                </div>

                                <!-- Cheer Amount (shown when method is "cheer") -->
                                <div id="cheerAmountSettings" class="form-group form-group-compact" style="display: none;">
                                    <label for="cheerAmount">
                                        Amount
                                        <span class="label-hint">Required amount</span>
                                    </label>
                                    <input type="number" id="cheerAmount" value="100" min="1" oninput="updateFullPreview();">
                                </div>

                                <!-- Maximum Users -->
                                <div class="form-group form-group-compact">
                                    <label for="maxUsers">
                                        Maximum Users
                                        <span class="label-hint">Max around campfire</span>
                                    </label>
                                    <input type="number" id="maxUsers" value="20" min="1" max="50" oninput="updateFullPreview();">
                                </div>
                            </div>

                            <hr style="border: none; border-top: 1px solid #333; margin: 20px 0;">

                            <!-- Restrictions (Two Columns) -->
                            <div class="form-group">
                                <label>
                                    Restrictions
                                    <span class="label-hint">Who can join the campfire</span>
                                </label>
                                <div style="display: flex; gap: 20px; margin-top: 8px;">
                                    <!-- Left Column: Subscriber Requirements -->
                                    <div style="flex: 1;">
                                        <div style="font-size: 12px; font-weight: 600; color: #aaa; margin-bottom: 8px;">Subscriber Requirements</div>
                                        <div style="display: flex; flex-direction: column; gap: 8px;">
                                            <div class="checkbox-group">
                                                <input type="checkbox" id="subscriberOnly" onchange="updateFullPreview();">
                                                <label for="subscriberOnly" style="margin: 0;">Any Subscriber (Tier 1, 2, or 3)</label>
                                            </div>
                                            <div class="checkbox-group">
                                                <input type="checkbox" id="subTier2Only" onchange="updateFullPreview();">
                                                <label for="subTier2Only" style="margin: 0;">Tier 2+ Subscribers Only</label>
                                            </div>
                                            <div class="checkbox-group">
                                                <input type="checkbox" id="subTier3Only" onchange="updateFullPreview();">
                                                <label for="subTier3Only" style="margin: 0;">Tier 3 Subscribers Only</label>
                                            </div>
                                        </div>
                                    </div>

                                    <!-- Right Column: Other Restrictions -->
                                    <div style="flex: 1;">
                                        <div style="font-size: 12px; font-weight: 600; color: #aaa; margin-bottom: 8px;">Other Restrictions</div>
                                        <div style="display: flex; flex-direction: column; gap: 8px;">
                                            <div class="checkbox-group">
                                                <input type="checkbox" id="vipOnly" onchange="updateFullPreview();">
                                                <label for="vipOnly" style="margin: 0;">VIP Only</label>
                                            </div>
                                            <div class="checkbox-group">
                                                <input type="checkbox" id="primeOnly" onchange="updateFullPreview();">
                                                <label for="primeOnly" style="margin: 0;">Prime/Turbo Only</label>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                <span class="label-hint" style="margin-top: 8px; display: block;">
                                    Leave all unchecked to allow all viewers
                                </span>
                            </div>

                            <hr style="border: none; border-top: 1px solid #333; margin: 20px 0;">

                            <!-- Current Commands List -->
                            <div class="form-group">
                                <label>Available Commands</label>
                                <div style="background: #2a2a2a; padding: 15px; border-radius: 8px; font-size: 13px; line-height: 1.4;">
                                    <div style="margin-bottom: 10px;"><strong>Join Commands:</strong></div>
                                    <div id="joinCommandDisplay" style="color: #4caf50; margin-bottom: 8px;">‚Ä¢ <span id="currentJoinCommand">!join</span> - Join the campfire</div>
                                    <div style="color: #888;">‚Ä¢ !leave - Leave the campfire</div>
                                    <div style="color: #888;">‚Ä¢ !camp - Alternative join command</div>

                                    <div style="margin-top: 15px; margin-bottom: 10px;"><strong>Other Commands:</strong></div>
                                    <div style="color: #888;">‚Ä¢ !status - Show campfire status</div>
                                    <div style="color: #888;">‚Ä¢ !users - List current members</div>
                                    <div style="color: #888;">‚Ä¢ !kick [username] - Remove user (broadcaster only)</div>
                                </div>
                                <span class="label-hint" style="margin-top: 8px; display: block;">
                                    Commands are triggered in Twitch chat. Configure the join command above.
                                </span>
                            </div>
                        </div>
                    </div>

                    <!-- Sprite Settings Tab -->
                    <div id="spritesTab" class="settings-section">
                        <div class="form-section">
                            <div class="form-group">
                                <label for="spriteMode">
                                    Sprite Mode
                                    <span class="label-hint">Choose how user sprites are displayed</span>
                                </label>
                                <select id="spriteMode" onchange="updateSpriteMode(); updateFullPreview();">
                                    <option value="circles">CIRCLES</option>
                                    <option value="circle">SHADOWS</option>
                                    <option value="rpg-characters">ADVENTURERS</option>
                                    <option value="pixel-morphs">MORPHS</option>
                                    <option value="custom">CUSTOM</option>
                                </select>
                            </div>

                            <!-- Circle Mode (SHADOWS) -->
                            <div id="circleSpriteSection" class="form-group" style="display: none;">
                                <label>
                                    SHADOWS Sprites
                                    <span class="label-hint">Preloaded pixel art circles (black shapes that will be colorized by Twitch username colors)</span>
                                </label>
                                <div style="background: #1a1a1a; border: 1px solid #333; border-radius: 6px; padding: 15px; margin-top: 10px;">
                                    <div style="color: #4caf50; font-size: 13px; margin-bottom: 8px;">‚úÖ Default sprites are preloaded with the installer</div>
                                    <div style="color: #888; font-size: 12px;">No upload needed - sprites are included automatically</div>
                                </div>
                                <div id="shadowSpritesList" class="sprite-list" style="margin-top: 10px; display: grid; grid-template-columns: repeat(auto-fill, minmax(60px, 1fr)); gap: 10px;">
                                    <span style="color: #888; font-size: 12px; grid-column: 1 / -1;">Loading default sprites...</span>
                                </div>
                            </div>

                            <!-- RPG Characters Mode (ADVENTURERS) -->
                            <div id="rpgSpriteSection" class="form-group" style="display: none;">
                                <label>
                                    ADVENTURERS Sprites
                                    <span class="label-hint">Preloaded RPG character sprites. Viewers can choose from these, or they'll be randomly assigned.</span>
                                </label>
                                <div style="background: #1a1a1a; border: 1px solid #333; border-radius: 6px; padding: 15px; margin-top: 10px;">
                                    <div style="color: #4caf50; font-size: 13px; margin-bottom: 8px;">‚úÖ Default sprites are preloaded with the installer</div>
                                    <div style="color: #888; font-size: 12px;">No upload needed - sprites are included automatically</div>
                                </div>
                                <div id="rpgSpritesList" class="sprite-list" style="margin-top: 10px; display: grid; grid-template-columns: repeat(auto-fill, minmax(60px, 1fr)); gap: 10px;">
                                    <span style="color: #888; font-size: 12px; grid-column: 1 / -1;">Loading default sprites...</span>
                                </div>
                            </div>

                            <!-- Pixel Morphs Mode (MORPHS) -->
                            <div id="morphSpriteSection" class="form-group" style="display: none;">
                                <label>
                                    MORPHS Sprites
                                    <span class="label-hint">Preloaded pixel art shapes (black shapes that will be colorized by Twitch username colors)</span>
                                </label>
                                <div style="background: #1a1a1a; border: 1px solid #333; border-radius: 6px; padding: 15px; margin-top: 10px;">
                                    <div style="color: #4caf50; font-size: 13px; margin-bottom: 8px;">‚úÖ Default sprites are preloaded with the installer</div>
                                    <div style="color: #888; font-size: 12px;">No upload needed - sprites are included automatically</div>
                                </div>
                                <div id="morphSpritesList" class="sprite-list" style="margin-top: 10px; display: grid; grid-template-columns: repeat(auto-fill, minmax(60px, 1fr)); gap: 10px;">
                                    <span style="color: #888; font-size: 12px; grid-column: 1 / -1;">Loading default sprites...</span>
                                </div>
                            </div>

                            <!-- Custom Mode -->
                            <div id="customSpriteSection" class="form-group" style="display: none;">
                                <label for="customSpriteUpload">
                                    Custom Sprite
                                    <span class="label-hint">Upload a custom sprite/GIF/image for users (or allow viewers to upload their own)</span>
                                </label>
                                <input type="file" id="customSpriteUpload" accept="image/*,.gif" onchange="handleCustomSpriteUpload(event)">
                                <div id="customSpritePreview" class="sprite-preview">
                                    <span style="color: #888; font-size: 12px;">No custom sprite uploaded</span>
                                </div>
                            </div>

                            <div class="form-group">
                                <label>
                                    Sprite Default Direction
                                    <span class="label-hint">Which direction is your sprite facing by default? This ensures the flip mechanics work correctly.</span>
                                </label>
                                <div style="display: flex; gap: 10px; align-items: center; margin-top: 8px;">
                                    <button type="button" id="spriteDirectionLeft" class="direction-button" onclick="setSpriteDirection('left')" style="flex: 1; padding: 12px; background: #1a1a1a; border: 2px solid #333; border-radius: 8px; cursor: pointer; font-size: 24px; transition: all 0.2s;">
                                        ‚Üê
                                    </button>
                                    <button type="button" id="spriteDirectionRight" class="direction-button" onclick="setSpriteDirection('right')" style="flex: 1; padding: 12px; background: #1a1a1a; border: 2px solid #333; border-radius: 8px; cursor: pointer; font-size: 24px; transition: all 0.2s;">
                                        ‚Üí
                                    </button>
                                </div>
                                <div id="spriteDirectionDisplay" style="margin-top: 8px; color: #888; font-size: 12px; text-align: center;">
                                    Default: Left
                                </div>
                            </div>

                            <div class="form-group">
                                <label>
                                    Viewer Dashboard Link
                                    <span class="label-hint">Share this link with your viewers</span>
                                </label>
                                <div style="display: flex; gap: 10px; align-items: center;">
                                    <input type="text" id="viewerDashboardLink" readonly value="viewer-dashboard.html" style="flex: 1;">
                                    <button class="button button-secondary" onclick="copyViewerLink()" style="padding: 8px 16px; font-size: 13px;">Copy</button>
                                </div>
                            </div>

                        </div>
                    </div>

                    <!-- Members Tab -->
                    <div id="membersTab" class="settings-section">
                        <div class="form-section">
                            <div class="info-box" style="margin-bottom: 20px;">
                                <strong>üë• Campfire Members</strong>
                                <p style="margin-top: 10px; font-size: 13px; opacity: 0.8;">
                                    Manage viewers around the campfire. Members persist across page refreshes.
                                </p>
                            </div>
                            
                            <div id="membersList" style="display: grid; gap: 10px;">
                                <!-- Member list will be populated here -->
                                <div style="text-align: center; padding: 40px; color: #888;">
                                    <p>Loading members...</p>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Bot Messages Tab -->
                    <div id="botmessagesTab" class="settings-section">
                        <div class="form-section">
                            <div class="form-group">
                                <label>
                                    Bot Messages Configuration
                                    <span class="label-hint">Enable/disable and customize bot messages sent to your Twitch channel</span>
                                </label>

                                <div id="botMessagesList" style="display: grid; gap: 15px; margin-top: 15px;">
                                    <!-- Bot messages will be populated here -->
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Code Tab -->
                    <div id="codeTab" class="settings-section">
                        <div class="form-section">
                            <div class="info-box" style="margin-bottom: 15px;">
                                <strong>üìù Instructions:</strong>
                                <ol style="margin-left: 20px; margin-top: 10px;">
                                    <li>Go to OBS and add a Browser Source, or use your streaming software's custom widget feature</li>
                                    <li>Click "Create New Widget" or edit existing</li>
                                    <li>Paste the HTML code below into the HTML section</li>
                                    <li>Save and add to your scene in OBS</li>
                                </ol>
                            </div>
                            <button class="button copy-button" onclick="copyCode()" style="margin-bottom: 15px;">üìã Copy Code</button>
                            <div class="code-section" style="margin-top: 5px;">
                                <h3>HTML Code (paste this entire code block):</h3>
                                <pre id="widgetCode"></pre>
                            </div>
                        </div>
                    </div>

                    <!-- Audio Tab -->
                    <div id="audioTab" class="settings-section">
                        <div class="form-section">
                            <div class="form-group">
                                <label>Audio Channels</label>
                                <span class="label-hint">Configure background music, ambience, and sound effects</span>
                            </div>
                            <!-- Music Channel -->
                            <div class="form-group">
                                <label>üéµ Music</label>
                                <div style="display: flex; gap: 10px; align-items: center; margin-top: 8px;">
                                    <input type="file" id="musicFile" accept="audio/*" onchange="updateAudioSetting('music', 'file', this.files[0]?.name || '')">
                                    <input type="range" id="musicVolume" min="0" max="100" value="70" onchange="updateAudioSetting('music', 'volume', this.value); document.getElementById('musicVolumeValue').textContent = this.value + '%'">
                                    <span id="musicVolumeValue">70%</span>
                                    <input type="checkbox" id="musicLoop" checked onchange="updateAudioSetting('music', 'loop', this.checked)">
                                    <label for="musicLoop" style="margin: 0;">Loop</label>
                                    <button onclick="previewAudio('music')">‚ñ∂Ô∏è Preview</button>
                                </div>
                            </div>
                            <!-- Ambience Channel -->
                            <div class="form-group">
                                <label>üåø Ambience</label>
                                <div style="display: flex; gap: 10px; align-items: center; margin-top: 8px;">
                                    <input type="file" id="ambienceFile" accept="audio/*" onchange="updateAudioSetting('ambience', 'file', this.files[0]?.name || '')">
                                    <input type="range" id="ambienceVolume" min="0" max="100" value="50" onchange="updateAudioSetting('ambience', 'volume', this.value); document.getElementById('ambienceVolumeValue').textContent = this.value + '%'">
                                    <span id="ambienceVolumeValue">50%</span>
                                    <input type="checkbox" id="ambienceLoop" checked onchange="updateAudioSetting('ambience', 'loop', this.checked)">
                                    <label for="ambienceLoop" style="margin: 0;">Loop</label>
                                    <button onclick="previewAudio('ambience')">‚ñ∂Ô∏è Preview</button>
                                </div>
                            </div>
                            <!-- User Sounds -->
                            <div class="form-group">
                                <label>üë§ User Sounds</label>
                                <div style="margin-top: 8px;">
                                    <!-- Join Sound -->
                                    <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 8px;">
                                        <span style="width: 60px;">Join:</span>
                                        <input type="file" id="joinSoundFile" accept="audio/*" onchange="updateAudioSetting('userSounds', 'join', {file: this.files[0]?.name || '', gain: document.getElementById('joinGain').value})">
                                        <input type="range" id="joinGain" min="0" max="100" value="80" onchange="updateAudioSetting('userSounds', 'join', {file: document.getElementById('joinSoundFile').files[0]?.name || '', gain: this.value}); document.getElementById('joinGainValue').textContent = this.value + '%'">
                                        <span id="joinGainValue">80%</span>
                                        <button onclick="previewAudio('join')">‚ñ∂Ô∏è Preview</button>
                                    </div>
                                    <!-- Leave Sound -->
                                    <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 8px;">
                                        <span style="width: 60px;">Leave:</span>
                                        <input type="file" id="leaveSoundFile" accept="audio/*" onchange="updateAudioSetting('userSounds', 'leave', {file: this.files[0]?.name || '', gain: document.getElementById('leaveGain').value})">
                                        <input type="range" id="leaveGain" min="0" max="100" value="60" onchange="updateAudioSetting('userSounds', 'leave', {file: document.getElementById('leaveSoundFile').files[0]?.name || '', gain: this.value}); document.getElementById('leaveGainValue').textContent = this.value + '%'">
                                        <span id="leaveGainValue">60%</span>
                                        <button onclick="previewAudio('leave')">‚ñ∂Ô∏è Preview</button>
                                    </div>
                                    <!-- Speak Sound -->
                                    <div style="display: flex; gap: 10px; align-items: center;">
                                        <span style="width: 60px;">Speak:</span>
                                        <input type="file" id="speakSoundFile" accept="audio/*" onchange="updateAudioSetting('userSounds', 'speak', {file: this.files[0]?.name || '', gain: document.getElementById('speakGain').value})">
                                        <input type="range" id="speakGain" min="0" max="100" value="40" onchange="updateAudioSetting('userSounds', 'speak', {file: document.getElementById('speakSoundFile').files[0]?.name || '', gain: this.value}); document.getElementById('speakGainValue').textContent = this.value + '%'">
                                        <span id="speakGainValue">40%</span>
                                        <button onclick="previewAudio('speak')">‚ñ∂Ô∏è Preview</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                </div>

                </div>
            </div>
        </div>
    </div>

    <script>
        let widgetCode = '';
        let livePreviewEnabled = false;
        let livePreviewSyncBound = false;
        let widgetPreviewReady = false;
        function escapeHtml(str) { if (str == null) return ''; var s = String(str); return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#39;'); }
        function escapeJsQuoted(str) { if (str == null) return ''; return String(str).replace(/\\/g,'\\\\').replace(/'/g,"\\'").replace(/\r/g,'\\r').replace(/\n/g,'\\n'); }

        async function loadWidgetCode() {
            try {
                const response = await fetch('widget.html');
                widgetCode = await response.text();
            } catch (e) {
                console.error('Could not load widget.html.');
            }
        }

        function isDesktopApp() {
            return !!window.electronAPI;
        }

        function getLivePreviewDefault() {
            // Desktop app: Live Preview is the main widget view
            return true;
        }

        function loadLivePreviewSetting() {
            const stored = localStorage.getItem('livePreviewEnabled');
            if (stored === null) return getLivePreviewDefault();
            return stored === 'true';
        }

        function setLivePreviewEnabled(enabled) {
            livePreviewEnabled = !!enabled;
            localStorage.setItem('livePreviewEnabled', String(livePreviewEnabled));
            updateLivePreviewUI();
        }

        function updateLivePreviewUI() {
            const panel = document.getElementById('previewPanel');
            const btn = document.getElementById('toggleLivePreviewBtn');
            const iframe = document.getElementById('fullWidgetPreview');
            if (!panel || !btn || !iframe) {
                console.error('[Preview] Missing elements:', { panel: !!panel, btn: !!btn, iframe: !!iframe });
                return;
            }
            
            console.log('[Preview] updateLivePreviewUI called, livePreviewEnabled:', livePreviewEnabled, 'isDesktopApp:', isDesktopApp());
            
            if (isDesktopApp()) {
                // Force enable in desktop app
                livePreviewEnabled = true;
                btn.style.display = 'none';
                panel.classList.remove('collapsed');
                panel.style.display = 'flex';
                panel.style.visibility = 'visible';
                panel.style.opacity = '1';
                
                // Force iframe to load in desktop app
                const src = iframe.getAttribute('data-src') || 'widget.html';
                console.log('[Preview] Desktop app - Loading iframe with src:', src);
                iframe.src = src;
                attachLivePreviewSync();
            } else if (livePreviewEnabled) {
                panel.classList.remove('collapsed');
                panel.style.display = 'flex';
                btn.textContent = 'Hide Preview';
                if (!iframe.src || iframe.src === 'about:blank' || iframe.src === '') {
                    const src = iframe.getAttribute('data-src') || 'widget.html';
                    console.log('[Preview] Loading iframe with src:', src);
                    iframe.src = src;
                }
                attachLivePreviewSync();
            } else {
                panel.classList.add('collapsed');
                btn.textContent = 'Show Preview';
                iframe.src = 'about:blank';
            }
        }

        function toggleLivePreview() {
            if (isDesktopApp()) return;
            setLivePreviewEnabled(!livePreviewEnabled);
        }

        function attachLivePreviewSync() {
            if (livePreviewSyncBound) return;
            livePreviewSyncBound = true;
            
            const iframe = document.getElementById('fullWidgetPreview');
            if (!iframe) return;
            
            const syncPreview = async () => {
                if (!livePreviewEnabled || !window.electronAPI) return;
                try {
                    const widgetUsers = await window.electronAPI.getWidgetUsers();
                    if (iframe.contentWindow) {
                        iframe.contentWindow.postMessage({
                            type: 'syncFullState',
                            users: widgetUsers
                        }, '*');
                    }
                } catch (e) {
                    console.error('Error syncing preview:', e);
                }
            };
            
            iframe.addEventListener('load', () => {
                if (!livePreviewEnabled) return;
                widgetPreviewReady = true;
                syncPreview();
                
                if (window.electronAPI) {
                    window.electronAPI.onUserJoin(() => {
                        if (livePreviewEnabled) setTimeout(syncPreview, 100);
                    });
                    window.electronAPI.onUserLeave(() => {
                        if (livePreviewEnabled) setTimeout(syncPreview, 100);
                    });
                }
            });
        }

        async function waitForPreviewReady(maxWaitMs = 2000) {
            // In desktop app, widget runs in separate window, always ready
            return true;
        }

        function openOverlay(mode) {
            document.body.classList.add('overlay-open');
            const title = document.getElementById('overlayTitle');
            if (title) {
                title.textContent = mode === 'members' ? 'Members' : (mode === 'settings' ? 'Settings' : 'Dashboard');
            }
            
            if (mode === 'members') {
                switchTab('members');
            } else if (mode === 'settings') {
                switchSettingsTab('campfire');
            } else {
                switchSettingsTab('campfire');
            }
        }

        function closeOverlay() {
            document.body.classList.remove('overlay-open');
        }

        function updateOverlayStatus(connected) {
            const dot = document.getElementById('overlayStatusDot');
            const text = document.getElementById('overlayStatusText');
            if (dot) {
                dot.classList.toggle('connected', !!connected);
            }
            if (text) {
                text.textContent = connected ? 'Connected' : 'Disconnected';
            }
        }

        // Bottom-center status badge (separate dashboard window uses this)
        function updateBottomConnectionBadge(connected) {
            const dot = document.getElementById('statusIndicator');
            const text = document.getElementById('statusText');
            if (dot) dot.classList.toggle('connected', !!connected);
            if (text) text.textContent = connected ? 'Connected' : 'Disconnected';
        }

        function setupBottomConnectionIndicator() {
            if (!window.electronAPI) return;
            // Initial state from main
            window.electronAPI.getTwitchStatus()
                .then(s => updateBottomConnectionBadge(!!s?.connected))
                .catch(() => updateBottomConnectionBadge(false));
            // Real-time updates
            window.electronAPI.onTwitchConnected(() => updateBottomConnectionBadge(true));
            window.electronAPI.onTwitchDisconnected(() => updateBottomConnectionBadge(false));
            window.electronAPI.onTwitchError(() => updateBottomConnectionBadge(false));
            // Safety net: poll occasionally in case renderers miss an event
            setInterval(() => {
                window.electronAPI.getTwitchStatus()
                    .then(s => updateBottomConnectionBadge(!!s?.connected))
                    .catch(() => {});
            }, 5000);
        }
        
        function initDesktopMenuBar() {
            console.log('[Menu Bar] initDesktopMenuBar() called');
            
            const hasElectronAPI = typeof window.electronAPI !== 'undefined';
            const hasProcess = typeof window.process !== 'undefined';
            const userAgentHasElectron = navigator.userAgent.includes('Electron');
            const isDesktopApp = hasElectronAPI || hasProcess || userAgentHasElectron;
            
            console.log('[Menu Bar] Checking desktop app mode:', isDesktopApp);
            
            const menuBar = document.getElementById('desktopMenuBar');
            console.log('[Menu Bar] Menu bar element found:', !!menuBar);
            
            if (!menuBar) {
                console.error('[Menu Bar] Menu bar element not found!');
                return;
            }
            
            // Show menu bar if in Electron
            if (isDesktopApp) {
                menuBar.classList.add('desktop-app');
                console.log('[Menu Bar] Added desktop-app class');
                
                // DISABLE AUTO-HIDE FOR NOW - Keep menu bar always visible
                menuBar.classList.remove('hidden');
                menuBar.style.opacity = '1';
                menuBar.style.transform = 'translateX(-50%) translateY(0)';
                menuBar.style.display = 'flex';
                menuBar.style.visibility = 'visible';
                console.log('[Menu Bar] Menu bar shown and kept visible (auto-hide disabled)');
            }
            
            if (isDesktopApp && typeof window.electronAPI !== 'undefined') {
                const btnDashboard = document.getElementById('btnDashboard');
                const btnSettings = document.getElementById('btnSettings');
                const btnMembers = document.getElementById('btnMembers');
                const btnEnd = document.getElementById('btnEnd');
                const statusIndicator = document.getElementById('statusIndicator');
                const statusText = document.getElementById('statusText');
                
                if (btnDashboard) {
                    btnDashboard.addEventListener('click', () => {
                        openOverlay('dashboard');
                    });
                }
                
                if (btnSettings) {
                    btnSettings.addEventListener('click', () => {
                        openOverlay('settings');
                    });
                }
                
                if (btnMembers) {
                    btnMembers.addEventListener('click', () => {
                        openOverlay('members');
                    });
                }
                
                if (btnEnd) {
                    btnEnd.addEventListener('click', async () => {
                        if (confirm('Are you sure you want to shut down the widget and all servers?')) {
                            await window.electronAPI.shutdownApp();
                        }
                    });
                }
                
                if (window.electronAPI) {
                    window.electronAPI.onTwitchConnected(() => {
                        if (statusIndicator) statusIndicator.classList.add('connected');
                        if (statusText) statusText.textContent = 'Connected';
                    });
                    
                    window.electronAPI.onTwitchDisconnected(() => {
                        if (statusIndicator) statusIndicator.classList.remove('connected');
                        if (statusText) statusText.textContent = 'Disconnected';
                    });
                    
                    window.electronAPI.getTwitchStatus().then(status => {
                        if (status.connected) {
                            if (statusIndicator) statusIndicator.classList.add('connected');
                            if (statusText) statusText.textContent = 'Connected';
                        }
                    }).catch(err => {
                        console.error('[Menu Bar] Error getting Twitch status:', err);
                    });
                }
            }
        }
        
        function enableHoverControls() {
            if (!isDesktopApp()) return;
            let hideTimer = null;
            const show = () => {
                document.body.classList.add('show-controls');
                if (hideTimer) clearTimeout(hideTimer);
                hideTimer = setTimeout(() => {
                    document.body.classList.remove('show-controls');
                }, 2000);
            };
            document.addEventListener('mousemove', show);
            document.addEventListener('mouseenter', show);
            show();
        }

        function switchSettingsTab(tabName, clickedButton) {
            try {
                // Hide ALL other tab-content divs (members, code)
                document.querySelectorAll('.tab-content').forEach(content => {
                    content.classList.remove('active');
                });
                
                // Show settings tab content
                const settingsTab = document.getElementById('settingsTab');
                if (settingsTab) {
                    settingsTab.classList.add('active');
                }
                
                // Hide all settings sections
                document.querySelectorAll('.settings-section').forEach(section => {
                    section.classList.remove('active');
                });
                
                // Remove active class from all tabs
                document.querySelectorAll('.tab').forEach(tab => {
                    tab.classList.remove('active');
                });
                
                // Show selected section
                const section = document.getElementById(tabName + 'Tab');
                if (section) {
                    section.classList.add('active');
                } else {
                    console.error('Tab section not found:', tabName + 'Tab');
                }
                
                // Activate corresponding tab button
                if (clickedButton) {
                    clickedButton.classList.add('active');
                } else {
                    // Fallback: find tab by text content
                    const tabButtons = document.querySelectorAll('.tab');
                    tabButtons.forEach(tab => {
                        const tabText = tab.textContent.trim();
                        if ((tabName === 'campfire' && tabText.includes('Campfire')) ||
                            (tabName === 'glow' && tabText.includes('Glow')) ||
                            (tabName === 'size' && tabText.includes('Size')) ||
                            (tabName === 'circle' && tabText.includes('Perspective')) ||
                            (tabName === 'chat' && tabText.includes('Chat')) ||
                            (tabName === 'join' && tabText.includes('Join')) ||
                            (tabName === 'members' && tabText.includes('Members')) ||
                            (tabName === 'code' && tabText.includes('Code')) ||
                            (tabName === 'audio' && tabText.includes('Audio')) ||
                            (tabName === 'sprites' && tabText.includes('Sprites'))) {
                            tab.classList.add('active');
                        }
                    });
                }
                
                // Reset scroll so content starts at top (settings-panel is the scroll container when tab uses flex: 0 0 auto)
                if (settingsTab) settingsTab.scrollTop = 0;
                const sp = document.querySelector('.settings-panel');
                if (sp) sp.scrollTop = 0;
                
                // Handle tab-specific actions
                if (tabName === 'members') {
                    if (typeof loadDashboardMembers === 'function') loadDashboardMembers();
                } else if (tabName === 'chat') {
                    const log = document.getElementById('twitchChatLog');
                    if (log) log.scrollTop = log.scrollHeight;
                } else if (tabName === 'code') {
                    // Generate code when Code tab is opened
                    setTimeout(() => {
                        if (typeof generateCode === 'function') {
                            generateCode();
                        }
                    }, 100);
                }
                
                updateFullPreview();
            } catch (error) {
                console.error('Error switching tab:', error);
            }
        }

        function toggleSection(header) {
            const content = header.nextElementSibling;
            const toggle = header.querySelector('.section-toggle');
            content.classList.toggle('collapsed');
            toggle.classList.toggle('collapsed');
        }

        function switchTab(tabName, element) {
            try {
                // Hide ALL tab-content divs (including settingsTab)
                document.querySelectorAll('.tab-content').forEach(content => {
                    content.classList.remove('active');
                });
                
                // Hide all settings sections (in case we're coming from a settings tab)
                document.querySelectorAll('.settings-section').forEach(section => {
                    section.classList.remove('active');
                });
                
                // Remove active class from all tabs
                document.querySelectorAll('.tab').forEach(tab => {
                    tab.classList.remove('active');
                });
                
                // Add active class to clicked tab
                if (element) {
                    element.classList.add('active');
                } else {
                    // Fallback: find tab by text content
                    document.querySelectorAll('.tab').forEach(tab => {
                        if ((tabName === 'members' && tab.textContent.includes('üë•')) ||
                            (tabName === 'code' && tab.textContent.includes('üìù'))) {
                            tab.classList.add('active');
                        }
                    });
                }
                
                // Show the target tab
                const targetTab = document.getElementById(tabName + 'Tab');
                if (targetTab) {
                    targetTab.classList.add('active');
                    targetTab.scrollTop = 0;
                    const sp = document.querySelector('.settings-panel');
                    if (sp) sp.scrollTop = 0;
                } else {
                    console.error('Tab not found:', tabName + 'Tab');
                }
                
                if (tabName === 'code') {
                    // Only generate code when Code tab is clicked, with error handling
                    setTimeout(() => {
                        try {
                            const codeTab = document.getElementById('codeTab');
                            if (codeTab && codeTab.classList.contains('active')) {
                                if (typeof generateCode === 'function') {
                                    generateCode();
                                } else {
                                    console.error('generateCode function not found');
                                    const codeArea = document.getElementById('widgetCode');
                                    if (codeArea) {
                                        codeArea.textContent = '<!-- Error: generateCode function not available -->';
                                    }
                                }
                            }
                        } catch (e) {
                            console.error('Error generating code:', e);
                            const codeArea = document.getElementById('widgetCode');
                            if (codeArea) {
                                codeArea.textContent = '<!-- Error generating code. Please refresh the page and try again. -->';
                            }
                        }
                    }, 100);
                } else if (tabName === 'members') {
                    // Load members when Members tab is clicked
                    try {
                        loadDashboardMembers();
                        // Set up refresh listener (only once)
                        if (window.electronAPI && window.electronAPI.onRefreshMembers && !window.membersRefreshListenerSet) {
                            window.electronAPI.onRefreshMembers(() => {
                                loadDashboardMembers();
                            });
                            window.membersRefreshListenerSet = true;
                        }
                        if (window.electronAPI && window.electronAPI.onSyncFullState && !window.syncFullStateListenerSet) {
                            window.electronAPI.onSyncFullState((users) => {
                                if (!livePreviewEnabled) return;
                                const iframe = document.getElementById('fullWidgetPreview');
                                if (iframe && iframe.contentWindow) {
                                    iframe.contentWindow.postMessage({
                                        type: 'syncFullState',
                                        users: Array.isArray(users) ? users : []
                                    }, '*');
                                }
                            });
                            window.syncFullStateListenerSet = true;
                        }
                    } catch (e) {
                        console.error('Error loading members:', e);
                        const membersList = document.getElementById('membersList');
                        if (membersList) {
                            membersList.innerHTML = '<div class="empty-state">Error loading members. Please try again.</div>';
                        }
                    }
                } else {
                    // Clear code area when switching away from Code tab to prevent text leakage
                    const codeArea = document.getElementById('widgetCode');
                    if (codeArea) {
                        codeArea.textContent = '';
                    }
                }
            } catch (error) {
                console.error('Error switching tab:', error);
            }
        }

        // Show all test users
        async function showAllTestUsers() {
            console.log('[Dashboard] showAllTestUsers called');
            if (!window.electronAPI) {
                alert('Not available in web version');
                return;
            }
            
            try {
                console.log('[Dashboard] Calling joinAllTestUsers...');
                const result = await window.electronAPI.joinAllTestUsers();
                console.log('[Dashboard] joinAllTestUsers result:', result);
                if (result && result.success === true) {
                    console.log('‚úÖ Test users joined successfully:', result.results);
                    // Small delay to ensure activeUsers is updated
                    await new Promise(resolve => setTimeout(resolve, 100));
                    // Refresh members list to update toggle states
                    if (typeof loadDashboardMembers === 'function') {
                        await loadDashboardMembers();
                    }
                    // Also refresh the members window if it exists
                    if (window.electronAPI && window.electronAPI.refreshMembers) {
                        await window.electronAPI.refreshMembers();
                    }
                } else {
                    console.error('Failed to join test users:', result);
                    alert('Failed to show test users. Check console for details.');
                }
            } catch (error) {
                console.error('Error showing test users:', error);
                alert('Error showing test users: ' + (error.message || error));
            }
        }
        
        // Hide all test users
        async function hideAllTestUsers() {
            console.log('[Dashboard] hideAllTestUsers called');
            if (!window.electronAPI) {
                alert('Not available in web version');
                return;
            }
            
            try {
                console.log('[Dashboard] Calling kickAllTestUsers...');
                const result = await window.electronAPI.kickAllTestUsers();
                console.log('[Dashboard] kickAllTestUsers result:', result);
                if (result && result.success === true) {
                    console.log('‚úÖ Test users removed successfully:', result.results);
                    // Small delay to ensure activeUsers is updated
                    await new Promise(resolve => setTimeout(resolve, 100));
                    // Refresh members list to update toggle states
                    if (typeof loadDashboardMembers === 'function') {
                        await loadDashboardMembers();
                    }
                    // Also refresh the members window if it exists
                    if (window.electronAPI && window.electronAPI.refreshMembers) {
                        await window.electronAPI.refreshMembers();
                    }
                } else {
                    console.error('Failed to kick test users:', result);
                    alert('Failed to hide test users. Check console for details.');
                }
            } catch (error) {
                console.error('Error hiding test users:', error);
                alert('Error hiding test users: ' + (error.message || error));
            }
        }

        async function kickAllUsersConfirm() {
            if (!window.electronAPI || !window.electronAPI.kickAllUsers) {
                alert('Not available in web version');
                return;
            }
            if (!confirm('‚òÅÔ∏è Kick ALL (non-test) users from the campfire?')) return;
            try {
                await window.electronAPI.kickAllUsers();
                if (typeof loadDashboardMembers === 'function') {
                    await new Promise(r => setTimeout(r, 150));
                    await loadDashboardMembers();
                }
            } catch (e) {
                console.error('Error kicking all users:', e);
                alert('Failed to kick all users.');
            }
        }

        async function joinAllUsersConfirm() {
            if (!window.electronAPI || !window.electronAPI.joinAllUsers) {
                alert('Not available in web version');
                return;
            }
            const controlled = confirm('üî• Join ALL users from chat?\n\nOK = Controlled (follow join rules)\nCancel = Chaos (override rules)');
            try {
                await window.electronAPI.joinAllUsers({ mode: controlled ? 'controlled' : 'chaos' });
                if (typeof loadDashboardMembers === 'function') {
                    await new Promise(r => setTimeout(r, 150));
                    await loadDashboardMembers();
                }
            } catch (e) {
                console.error('Error joining all users:', e);
                alert('Failed to join all users.');
            }
        }
        
        // Debounce updateFullPreview to prevent excessive calls while dragging sliders
        let previewUpdateTimeout = null;
        function updateFullPreview() {
            // In desktop app with separate dashboard, preview iframe doesn't exist
            const settings = getSettings();
            localStorage.setItem('campfireWidgetSettings', JSON.stringify(settings));
            // Desktop app: also send to main (debounced) so the widget updates live
            if (window.electronAPI?.saveSettings) {
                if (previewUpdateTimeout) clearTimeout(previewUpdateTimeout);
                previewUpdateTimeout = setTimeout(() => {
                    try { window.electronAPI.saveSettings(settings); } catch (e) {}
                }, 150);
            }
        }

        function updateAngleDisplay() {
            const input = document.getElementById('circleAngle');
            const angle = input.value;
            document.getElementById('angleValue').textContent = angle + '¬∞';
            updateSliderBackground(input);
        }

        function updateCampfireYOffsetDisplay() {
            const input = document.getElementById('campfireYOffset');
            if (!input) return;
            const v = parseInt(input.value || 50, 10);
            // Map 0‚Äì100 ‚Üí -200px..+200px (50 = 0px)
            const px = (v - 50) * 4;
            const el = document.getElementById('campfireYOffsetValue');
            if (el) el.textContent = `${v} (${px >= 0 ? '+' : ''}${px}px)`;
            updateSliderBackground(input);
            updateFullPreview();
        }

        function updateGlowSizeDisplay() {
            const input = document.getElementById('glowSize');
            const size = input.value;
            document.getElementById('glowSizeValue').textContent = size + 'px';
            updateSliderBackground(input);
        }

        function updateGlowIntensityDisplay() {
            const input = document.getElementById('glowIntensity');
            const intensity = input.value;
            document.getElementById('glowIntensityValue').textContent = intensity + '%';
            updateSliderBackground(input);
        }
        
        function updateSliderBackground(input) {
            const value = (input.value - input.min) / (input.max - input.min) * 100;
            input.style.background = `linear-gradient(to right, #667eea 0%, #667eea ${value}%, #3a3a3a ${value}%, #3a3a3a 100%)`;
        }
        
        function initializeAllSliders() {
            document.querySelectorAll('input[type="range"]').forEach(slider => {
                updateSliderBackground(slider);
                slider.addEventListener('input', () => updateSliderBackground(slider));
            });
        }

        function updateShadowIntensityDisplay() {
            const intensity = document.getElementById('shadowIntensity').value;
            document.getElementById('shadowIntensityValue').textContent = intensity + '%';
        }

        function updateGlowSpreadDisplay() {
            const spread = document.getElementById('glowSpread').value;
            document.getElementById('glowSpreadValue').textContent = spread + '%';
        }

        function updateFlickerOpacityDisplay() {
            const input = document.getElementById('flickerOpacity');
            if (!input) return;
            const v = input.value;
            const el = document.getElementById('flickerOpacityValue');
            if (el) el.textContent = v + '%';
        }

        function updateFlickerSpreadDisplay() {
            const input = document.getElementById('flickerSpread');
            if (!input) return;
            const v = input.value;
            const el = document.getElementById('flickerSpreadValue');
            if (el) el.textContent = v + '%';
        }

        function updateFireSizeDisplay() {
            const size = document.getElementById('fireSize').value;
            document.getElementById('fireSizeValue').textContent = size + 'px';
            // Only save fireSize setting, not all settings
            const currentSettings = JSON.parse(localStorage.getItem('campfireWidgetSettings') || '{}');
            const newSize = parseInt(size);
            const oldSize = currentSettings.fireSize || 48;
            if (newSize !== oldSize) {
                currentSettings.fireSize = newSize;
                localStorage.setItem('campfireWidgetSettings', JSON.stringify(currentSettings));
            }
        }

        function updateSpriteSizeDisplay() {
            const size = document.getElementById('spriteSize').value;
            document.getElementById('spriteSizeValue').textContent = size + 'px';
            // Only save spriteSize setting, not all settings
            const currentSettings = JSON.parse(localStorage.getItem('campfireWidgetSettings') || '{}');
            const newSize = parseInt(size);
            const oldSize = currentSettings.spriteSize || 40;
            if (newSize !== oldSize) {
                currentSettings.spriteSize = newSize;
                localStorage.setItem('campfireWidgetSettings', JSON.stringify(currentSettings));
            }
        }

        // Flag to prevent infinite loops when syncing dropdowns
        let _syncingSpriteMode = false;
        
        function updateSpriteMode(skipSave = false) {
            const mode = document.getElementById('spriteMode').value;
            
            // Hide all sections
            document.getElementById('circleSpriteSection').style.display = 'none';
            document.getElementById('rpgSpriteSection').style.display = 'none';
            document.getElementById('morphSpriteSection').style.display = 'none';
            document.getElementById('customSpriteSection').style.display = 'none';
            
            // Show relevant section
            if (mode === 'circles') {
                // Circles mode: no section needed (uses simple colored circles)
                // All sections remain hidden
            } else if (mode === 'circle') {
                document.getElementById('circleSpriteSection').style.display = 'block';
                loadSpriteList('shadow');
            } else if (mode === 'rpg-characters') {
                document.getElementById('rpgSpriteSection').style.display = 'block';
                loadSpriteList('rpg');
            } else if (mode === 'pixel-morphs') {
                document.getElementById('morphSpriteSection').style.display = 'block';
                loadSpriteList('morph');
            } else if (mode === 'custom') {
                document.getElementById('customSpriteSection').style.display = 'block';
            }
            
            // Restore direction for this sprite mode
            const saved = JSON.parse(localStorage.getItem('campfireWidgetSettings') || '{}');
            const directions = saved.spriteDefaultDirections || {};
            const modeDirection = directions[mode] || saved.spriteDefaultDirection || 'left';
            setSpriteDirection(modeDirection, false); // Don't save on mode switch
            
            // Only save if not called programmatically (skipSave flag)
            if (!skipSave && !_syncingSpriteMode) {
                _syncingSpriteMode = true;
                try {
                    // Save to localStorage and dispatch event to sync with Quick Settings
                    const settings = getSettings();
                    localStorage.setItem('campfireWidgetSettings', JSON.stringify(settings));
                    window.dispatchEvent(new CustomEvent('campfireSettingsUpdate', { detail: settings }));
                } finally {
                    _syncingSpriteMode = false;
                }
            }
        }
        
        // Load and display sprite lists
        function loadSpriteList(type) {
            const listKey = `${type}SpritesList`;
            const container = document.getElementById(listKey);
            if (!container) return;
            
            const sprites = JSON.parse(localStorage.getItem(`${type}Sprites`) || '[]');
            
            if (sprites.length === 0) {
                container.innerHTML = '<span style="color: #888; font-size: 12px; grid-column: 1 / -1;">No sprites uploaded</span>';
                return;
            }
            
            container.innerHTML = sprites.map((sprite, index) => `
                <div style="position: relative; border: 2px solid #333; border-radius: 4px; overflow: hidden;">
                    <img src="${sprite.data}" style="width: 100%; height: 60px; object-fit: contain; background: #1a1a1a;" alt="${sprite.name}">
                    <button onclick="removeSprite('${type}', ${index})" style="position: absolute; top: 2px; right: 2px; background: rgba(255,0,0,0.8); color: white; border: none; border-radius: 3px; width: 20px; height: 20px; cursor: pointer; font-size: 12px;">√ó</button>
                </div>
            `).join('');
        }
        
        // Handle sprite uploads (multiple files)
        function handleCircleSpriteUpload(event) {
            handleMultiSpriteUpload(event, 'shadow');
        }
        
        function handleRpgSpriteUpload(event) {
            handleMultiSpriteUpload(event, 'rpg');
        }
        
        function handleMorphSpriteUpload(event) {
            handleMultiSpriteUpload(event, 'morph');
        }
        
        function handleMultiSpriteUpload(event, type) {
            const files = Array.from(event.target.files);
            if (files.length === 0) return;
            
            const sprites = JSON.parse(localStorage.getItem(`${type}Sprites`) || '[]');
            let loaded = 0;
            
            files.forEach((file, index) => {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const base64 = e.target.result;
                    sprites.push({
                        name: file.name,
                        data: base64,
                        size: file.size
                    });
                    loaded++;
                    
                    if (loaded === files.length) {
                        localStorage.setItem(`${type}Sprites`, JSON.stringify(sprites));
                        loadSpriteList(type);
                        updateFullPreview();
                        event.target.value = ''; // Clear input
                    }
                };
                reader.readAsDataURL(file);
            });
        }
        
        function removeSprite(type, index) {
            const sprites = JSON.parse(localStorage.getItem(`${type}Sprites`) || '[]');
            sprites.splice(index, 1);
            localStorage.setItem(`${type}Sprites`, JSON.stringify(sprites));
            loadSpriteList(type);
            updateFullPreview();
        }
        
        // Load RPG sprites from the server folder
        async function loadRpgSpritesFromFolder() {
            // Check if we're in Electron or web server
            const isElectron = !!window.electronAPI;
            const isFileProtocol = window.location.protocol === 'file:';
            
            // Skip only if file:// AND not Electron
            if (isFileProtocol && !isElectron) {
                console.log('Skipping sprite loading - dashboard opened as file:// (use http://localhost:3000/dashboard.html or Electron app)');
                return;
            }
            
            console.log('üîÑ Loading RPG sprites...', isElectron ? '(Electron mode)' : '(Web mode)');
            
            // Check if RPG sprites are already loaded (but allow reload if count doesn't match)
            const existingSprites = JSON.parse(localStorage.getItem('rpgSprites') || '[]');
            const expectedCount = 20; // We expect 20 RPG sprites
            if (existingSprites.length === expectedCount) {
                console.log(`‚úÖ RPG sprites already loaded: ${existingSprites.length} sprites`);
                return;
            } else if (existingSprites.length > 0) {
                console.log(`Reloading RPG sprites (found ${existingSprites.length}, expected ${expectedCount})`);
            }
            
            // List of RPG character files found in the folder (updated with normalized sprites)
            const rpgCharacterFiles = [
                'Archer.gif',
                'Armored Axeman.gif',
                'Armored Orc.gif',
                'Armored Skeleton.gif',
                'Elite Orc.gif',
                'Greatsword Skeleton.gif',
                'Knight.gif',
                'Knight Templar.gif',
                'Lancer.gif',
                'Orc.gif',
                'Orc rider.gif',
                'Priest.gif',
                'Skeleton.gif',
                'Skeleton Archer.gif',
                'Slime.gif',
                'Soldier.gif',
                'Swordsman.gif',
                'Werebear.gif',
                'Werewolf.gif',
                'Wizard.gif'
            ];
            
            console.log(`Loading ${rpgCharacterFiles.length} RPG sprites from server...`);
            
            const loadedSprites = [];
            let loadedCount = 0;
            
            // Load each sprite file
            for (const filename of rpgCharacterFiles) {
                try {
                    // URL encode the filename to handle spaces
                    const encodedFilename = encodeURIComponent(filename);
                    // Use appropriate path based on environment
                    // In Electron (file://), use relative path. In web server, use absolute path.
                    const spriteUrl = isElectron 
                        ? `sprites/defaults/rpg-characters/${encodedFilename}`
                        : `/sprites/defaults/rpg-characters/${encodedFilename}`;
                    const response = await fetch(spriteUrl);
                    if (response.ok) {
                        const blob = await response.blob();
                        const reader = new FileReader();
                        
                        await new Promise((resolve, reject) => {
                            reader.onload = (e) => {
                                const base64 = e.target.result;
                                // Clean up filename to get sprite name (remove .gif extension)
                                const spriteName = filename.replace('.gif', '').trim();
                                loadedSprites.push({
                                    name: spriteName,
                                    filename: filename,
                                    data: base64,
                                    size: blob.size
                                });
                                loadedCount++;
                                resolve();
                            };
                            reader.onerror = reject;
                            reader.readAsDataURL(blob);
                        });
                    } else {
                        console.warn(`‚ùå Could not load ${filename}: HTTP ${response.status} - ${response.statusText}`);
                        console.warn(`   Attempted URL: ${spriteUrl}`);
                        console.warn(`   Full URL: ${window.location.origin}${spriteUrl}`);
                    }
                } catch (error) {
                    console.error(`‚ùå Error loading ${filename}:`, error);
                    console.error(`   Attempted URL: ${spriteUrl}`);
                    console.error(`   Full URL: ${window.location.origin}${spriteUrl}`);
                }
            }
            
            if (loadedSprites.length > 0) {
                localStorage.setItem('rpgSprites', JSON.stringify(loadedSprites));
                console.log(`‚úÖ Loaded ${loadedSprites.length} RPG sprites from folder`);
                
                // Update the sprite list if RPG mode is active
                const currentMode = document.getElementById('spriteMode')?.value;
                if (currentMode === 'rpg-characters') {
                    loadSpriteList('rpg');
                }
            } else {
                console.warn('No RPG sprites could be loaded from server');
            }
        }

        async function loadShadowSpritesFromFolder() {
            // Check if we're in Electron or web server
            const isElectron = !!window.electronAPI;
            const isFileProtocol = window.location.protocol === 'file:';
            
            // Skip only if file:// AND not Electron
            if (isFileProtocol && !isElectron) {
                console.log('Skipping sprite loading - dashboard opened as file:// (use http://localhost:3000/dashboard.html or Electron app)');
                return;
            }
            
            console.log('üîÑ Loading shadow sprites...', isElectron ? '(Electron mode)' : '(Web mode)');
            
            // Check if shadow sprites are already loaded
            const existingSprites = JSON.parse(localStorage.getItem('shadowSprites') || '[]');
            if (existingSprites.length > 0) {
                console.log(`‚úÖ Shadow sprites already loaded: ${existingSprites.length} sprites`);
                return;
            }
            
            // Try to load GIF files from the shadows folder
            const shadowFiles = [
                '3dgifmaker92871.gif'
            ];
            
            console.log(`Loading shadow sprites from server...`);
            
            const loadedSprites = [];
            
            // Load each shadow GIF file
            for (const filename of shadowFiles) {
                try {
                    const encodedFilename = encodeURIComponent(filename);
                    // Use appropriate path based on environment
                    const spriteUrl = isElectron
                        ? `sprites/defaults/shadows/${encodedFilename}`
                        : `/sprites/defaults/shadows/${encodedFilename}`;
                    const response = await fetch(spriteUrl);
                    if (response.ok) {
                        const blob = await response.blob();
                        const reader = new FileReader();
                        
                        await new Promise((resolve, reject) => {
                            reader.onload = (e) => {
                                const base64 = e.target.result;
                                const spriteName = filename.replace('.gif', '').trim();
                                loadedSprites.push({
                                    name: spriteName,
                                    filename: filename,
                                    data: base64,
                                    size: blob.size
                                });
                                resolve();
                            };
                            reader.onerror = reject;
                            reader.readAsDataURL(blob);
                        });
                    } else {
                        console.warn(`‚ùå Could not load ${filename}: HTTP ${response.status} - ${response.statusText}`);
                        console.warn(`   Attempted URL: ${spriteUrl}`);
                        console.warn(`   Full URL: ${window.location.origin}${spriteUrl}`);
                    }
                } catch (error) {
                    console.error(`‚ùå Error loading ${filename}:`, error);
                    console.error(`   Attempted URL: ${spriteUrl}`);
                    console.error(`   Full URL: ${window.location.origin}${spriteUrl}`);
                }
            }
            
            if (loadedSprites.length > 0) {
                localStorage.setItem('shadowSprites', JSON.stringify(loadedSprites));
                console.log(`‚úÖ Loaded ${loadedSprites.length} shadow sprites from folder`);
                
                // Update the sprite list if circle mode is active
                const currentMode = document.getElementById('spriteMode')?.value;
                if (currentMode === 'circle') {
                    loadSpriteList('shadow');
                }
            } else {
                console.log('No shadow GIFs found, will use SVG circle fallback');
            }
        }

        async function loadMorphSpritesFromFolder() {
            // Check if we're in Electron or web server
            const isElectron = !!window.electronAPI;
            const isFileProtocol = window.location.protocol === 'file:';
            
            // Skip only if file:// AND not Electron
            if (isFileProtocol && !isElectron) {
                console.log('Skipping sprite loading - dashboard opened as file:// (use http://localhost:3000/dashboard.html or Electron app)');
                return;
            }
            
            console.log('üîÑ Loading pixel morph sprites...', isElectron ? '(Electron mode)' : '(Web mode)');
            
            // Check if morph sprites are already loaded (but allow reload if count doesn't match)
            const existingSprites = JSON.parse(localStorage.getItem('morphSprites') || '[]');
            const expectedCount = 10; // We expect 10 pixel morph sprites
            if (existingSprites.length === expectedCount) {
                console.log(`‚úÖ Pixel morph sprites already loaded: ${existingSprites.length} sprites`);
                return;
            } else if (existingSprites.length > 0) {
                console.log(`Reloading pixel morph sprites (found ${existingSprites.length}, expected ${expectedCount})`);
            }
            
            // List of pixel morph files found in the folder
            const morphFiles = [
                'pixelmorph_blue.gif',
                'pixelmorph_brown.gif',
                'pixelmorph_gray.gif',
                'pixelmorph_green.gif',
                'pixelmorph_lavender.gif',
                'pixelmorph_orange.gif',
                'pixelmorph_purple.gif',
                'pixelmorph_teal.gif',
                'pixelmorph_white.gif',
                'pixelmorph_yellow.gif'
            ];
            
            console.log(`Loading ${morphFiles.length} pixel morph sprites from server...`);
            
            const loadedSprites = [];
            
            // Load each sprite file
            for (const filename of morphFiles) {
                try {
                    const encodedFilename = encodeURIComponent(filename);
                    // Use appropriate path based on environment
                    const spriteUrl = isElectron
                        ? `sprites/defaults/pixel-morphs/${encodedFilename}`
                        : `/sprites/defaults/pixel-morphs/${encodedFilename}`;
                    const response = await fetch(spriteUrl);
                    if (response.ok) {
                        const blob = await response.blob();
                        const reader = new FileReader();
                        
                        await new Promise((resolve, reject) => {
                            reader.onload = (e) => {
                                const base64 = e.target.result;
                                // Clean up filename to get sprite name (remove .gif extension and pixelmorph_ prefix)
                                const spriteName = filename.replace('pixelmorph_', '').replace('.gif', '').trim();
                                loadedSprites.push({
                                    name: spriteName.charAt(0).toUpperCase() + spriteName.slice(1), // Capitalize first letter
                                    filename: filename,
                                    data: base64,
                                    size: blob.size
                                });
                                resolve();
                            };
                            reader.onerror = reject;
                            reader.readAsDataURL(blob);
                        });
                    } else {
                        console.warn(`‚ùå Could not load ${filename}: HTTP ${response.status} - ${response.statusText}`);
                        console.warn(`   Attempted URL: ${spriteUrl}`);
                        console.warn(`   Full URL: ${window.location.origin}${spriteUrl}`);
                    }
                } catch (error) {
                    console.error(`‚ùå Error loading ${filename}:`, error);
                    console.error(`   Attempted URL: ${spriteUrl}`);
                    console.error(`   Full URL: ${window.location.origin}${spriteUrl}`);
                }
            }
            
            if (loadedSprites.length > 0) {
                localStorage.setItem('morphSprites', JSON.stringify(loadedSprites));
                console.log(`‚úÖ Loaded ${loadedSprites.length} pixel morph sprites from folder`);
                
                // Update the sprite list if pixel morph mode is active
                const currentMode = document.getElementById('spriteMode')?.value;
                if (currentMode === 'pixel-morphs') {
                    loadSpriteList('morph');
                }
            } else {
                console.warn('No pixel morph sprites could be loaded from server');
            }
        }

        function clearCampfireUpload() {
            if (confirm('Are you sure you want to clear the uploaded campfire graphic?')) {
                localStorage.removeItem('campfireGraphicData');
                const uploadInput = document.getElementById('campfireUpload');
                if (uploadInput) {
                    uploadInput.value = '';
                }
                const preview = document.getElementById('campfirePreview');
                if (preview) {
                    preview.innerHTML = '<span style="color: #888; font-size: 12px;">No campfire graphic uploaded</span>';
                }
                updateFullPreview();
            }
        }

        function clearAllGraphics() {
            if (confirm('This will clear ALL uploaded graphics (campfire, sprites). This may fix dashboard issues. Continue?')) {
                localStorage.removeItem('campfireGraphicData');
                localStorage.removeItem('defaultSpriteData');
                localStorage.removeItem('customSpriteData');
                
                // Reset file inputs
                const campfireUpload = document.getElementById('campfireUpload');
                const defaultSpriteUpload = document.getElementById('defaultSpriteUpload');
                const customSpriteUpload = document.getElementById('customSpriteUpload');
                if (campfireUpload) campfireUpload.value = '';
                if (defaultSpriteUpload) defaultSpriteUpload.value = '';
                if (customSpriteUpload) customSpriteUpload.value = '';
                
                // Reset previews
                const campfirePreview = document.getElementById('campfirePreview');
                const defaultSpritePreview = document.getElementById('defaultSpritePreview');
                const customSpritePreview = document.getElementById('customSpritePreview');
                if (campfirePreview) campfirePreview.innerHTML = '<span style="color: #888; font-size: 12px;">No campfire graphic uploaded</span>';
                if (defaultSpritePreview) defaultSpritePreview.innerHTML = '<span style="color: #888; font-size: 12px;">No sprite uploaded</span>';
                if (customSpritePreview) customSpritePreview.innerHTML = '<span style="color: #888; font-size: 12px;">No sprite uploaded</span>';
                
                alert('‚úÖ All graphics cleared! Please refresh the page.');
                location.reload();
            }
        }

        function clearAllDataAndReload() {
            if (confirm('This will clear ALL data (settings, graphics, everything) and reload the page. This should fix any dashboard issues. Continue?')) {
                try {
                    localStorage.clear();
                    alert('‚úÖ All data cleared! Reloading page...');
                    location.reload();
                } catch (e) {
                    alert('Error clearing data: ' + e.message + '\n\nPlease manually clear your browser cache and localStorage.');
                }
            }
        }

        function setCampfireMethod(method) {
            const btnUrl = document.getElementById('btnMethodUrl');
            const btnUpload = document.getElementById('btnMethodUpload');
            const urlSection = document.getElementById('campfireUrlSection');
            const uploadSection = document.getElementById('campfireUploadSection');
            const urlStatus = document.getElementById('campfireUrlStatus');
            
            if (!urlSection || !uploadSection || !btnUrl || !btnUpload) {
                console.error('Campfire sections or buttons not found');
                return;
            }
            
            // Check if uploaded data exists
            const campfireData = localStorage.getItem('campfireGraphicData');
            const hasUploadedData = campfireData && campfireData.length > 0;
            
            if (method === 'url') {
                // Style URL button as active
                btnUrl.className = 'button';
                btnUpload.className = 'button-secondary';
                
                urlSection.style.display = 'block';
                uploadSection.style.display = 'none';
                
                // Show warning if uploaded data exists
                if (urlStatus) {
                    urlStatus.style.display = hasUploadedData ? 'block' : 'none';
                }
            } else {
                // Style UPLOAD button as active
                btnUrl.className = 'button-secondary';
                btnUpload.className = 'button';
                
                urlSection.style.display = 'none';
                uploadSection.style.display = 'block';
                
                // Hide URL status warning
                if (urlStatus) {
                    urlStatus.style.display = 'none';
                }
                
                // Always show preview if there's uploaded data
                const preview = document.getElementById('campfirePreview');
                if (preview) {
                    if (hasUploadedData) {
                        const isVideo = campfireData.startsWith('data:video/');
                        if (isVideo) {
                            preview.innerHTML = `<video src="${campfireData}" style="max-width: 100%; max-height: 100px; border-radius: 4px;" controls autoplay loop muted></video>`;
                        } else {
                            preview.innerHTML = `<img src="${campfireData}" style="max-width: 100%; max-height: 100px; border-radius: 4px;" alt="Campfire Graphic">`;
                        }
                    } else {
                        preview.innerHTML = '<span style="color: #888; font-size: 12px;">No campfire graphic uploaded</span>';
                    }
                }
            }
            
            updateFullPreview();
        }

        function updateCampfireMethod() {
            const method = document.getElementById('campfireMethod')?.value || 'url';
            setCampfireMethod(method);
        }

        function handleCampfireUpload(event) {
            const file = event.target.files[0];
            if (!file) {
                // Clear the input if no file selected
                event.target.value = '';
                return;
            }
            
            // Check file size (limit to 10MB to prevent localStorage issues)
            const maxSize = 10 * 1024 * 1024; // 10MB
            if (file.size > maxSize) {
                alert('‚ö†Ô∏è File is too large! Maximum size is 10MB. Please use a smaller file or compress it.');
                event.target.value = '';
                return;
            }
            
            const reader = new FileReader();
            reader.onerror = function() {
                alert('‚ùå Error reading file. Please try again.');
                event.target.value = '';
            };
            
            reader.onload = function(e) {
                try {
                    const base64 = e.target.result;
                    localStorage.setItem('campfireGraphicData', base64);
                    
                    // Ensure upload section is visible
                    const uploadSection = document.getElementById('campfireUploadSection');
                    const urlSection = document.getElementById('campfireUrlSection');
                    if (uploadSection && urlSection) {
                        uploadSection.style.display = 'block';
                        urlSection.style.display = 'none';
                        // Update method selector
                        const methodSelect = document.getElementById('campfireMethod');
                        if (methodSelect) {
                            methodSelect.value = 'upload';
                        }
                    }
                    
                    // Update preview
                    const preview = document.getElementById('campfirePreview');
                    if (preview) {
                        const fileExtension = file.name.split('.').pop().toLowerCase();
                        const isVideo = ['mp4', 'webm', 'mov', 'avi'].includes(fileExtension);
                        const isGif = fileExtension === 'gif';
                        
                        if (isVideo || file.type.startsWith('video/')) {
                            preview.innerHTML = `<video src="${base64}" style="max-width: 100%; max-height: 100px; border-radius: 4px;" controls autoplay loop muted></video>`;
                        } else if (isGif || file.type === 'image/gif') {
                            preview.innerHTML = `<img src="${base64}" style="max-width: 100%; max-height: 100px; border-radius: 4px;" alt="Campfire GIF">`;
                        } else {
                            preview.innerHTML = `<img src="${base64}" style="max-width: 100%; max-height: 100px; border-radius: 4px;" alt="Campfire Graphic">`;
                        }
                    }
                    
                    updateFullPreview();
                } catch (error) {
                    console.error('Error handling upload:', error);
                    alert('‚ùå Error processing file. Please try again.');
                    event.target.value = '';
                }
            };
            
            reader.readAsDataURL(file);
        }

        function updateJoinMethod() {
            const method = document.getElementById('joinMethod').value;
            const commandSettings = document.getElementById('commandSettings');
            const emoteSettings = document.getElementById('emoteSettings');
            const cheerSettings = document.getElementById('cheerSettings');
            const cheerAmountSettings = document.getElementById('cheerAmountSettings');

            // Hide all first
            commandSettings.style.display = 'none';
            emoteSettings.style.display = 'none';
            cheerSettings.style.display = 'none';
            cheerAmountSettings.style.display = 'none';

            // Show relevant ones
            if (method === 'command') {
                commandSettings.style.display = 'block';
                updateCurrentCommandDisplay();
            } else if (method === 'emote') {
                emoteSettings.style.display = 'block';
            } else if (method === 'cheer') {
                cheerSettings.style.display = 'block';
                cheerAmountSettings.style.display = 'block';
            }
        }

        function updateCurrentCommandDisplay() {
            const command = document.getElementById('command').value || '!join';
            document.getElementById('currentJoinCommand').textContent = command;
        }

        function handleDefaultSpriteUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                const base64 = e.target.result;
                localStorage.setItem('defaultSpriteData', base64);
                const preview = document.getElementById('defaultSpritePreview');
                preview.innerHTML = `<img src="${base64}" style="max-width: 100%; max-height: 60px; border-radius: 4px;">`;
                updateFullPreview();
            };
            reader.readAsDataURL(file);
        }

        function handleCustomSpriteUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                const base64 = e.target.result;
                localStorage.setItem('customSpriteData', base64);
                const preview = document.getElementById('customSpritePreview');
                preview.innerHTML = `<img src="${base64}" style="max-width: 100%; max-height: 60px; border-radius: 4px;">`;
                updateFullPreview();
            };
            reader.readAsDataURL(file);
        }

        function setSpriteDirection(direction, updatePreview = true) {
            const leftBtn = document.getElementById('spriteDirectionLeft');
            const rightBtn = document.getElementById('spriteDirectionRight');
            const display = document.getElementById('spriteDirectionDisplay');
            
            // Remove active class from both buttons
            leftBtn.classList.remove('active');
            rightBtn.classList.remove('active');
            
            // Add active class to selected button
            if (direction === 'left') {
                leftBtn.classList.add('active');
                display.textContent = 'Default: Left';
            } else {
                rightBtn.classList.add('active');
                display.textContent = 'Default: Right';
            }
            
            if (updatePreview) {
                // Save spriteDefaultDirection per sprite mode
                const currentSettings = JSON.parse(localStorage.getItem('campfireWidgetSettings') || '{}');
                const currentMode = document.getElementById('spriteMode')?.value || 'circles';
                
                // Initialize spriteDefaultDirections if it doesn't exist
                if (!currentSettings.spriteDefaultDirections) {
                    currentSettings.spriteDefaultDirections = {
                        'circles': currentSettings.spriteDefaultDirection || 'left',
                        'circle': currentSettings.spriteDefaultDirection || 'left',
                        'rpg-characters': currentSettings.spriteDefaultDirection || 'left',
                        'pixel-morphs': currentSettings.spriteDefaultDirection || 'left',
                        'custom': currentSettings.spriteDefaultDirection || 'left'
                    };
                }
                
                // Save direction for current mode
                currentSettings.spriteDefaultDirections[currentMode] = direction;
                
                // Also update legacy spriteDefaultDirection for backward compatibility
                currentSettings.spriteDefaultDirection = direction;
                
                localStorage.setItem('campfireWidgetSettings', JSON.stringify(currentSettings));
                // Dispatch event to update widget
                window.dispatchEvent(new CustomEvent('campfireSettingsUpdate', { detail: { 
                    spriteDefaultDirection: direction,
                    spriteDefaultDirections: currentSettings.spriteDefaultDirections
                } }));
            }
        }

        function copyViewerLink() {
            // Get the viewer dashboard link
            let link;
            if (window.location.protocol === 'file:') {
                // If opened as file://, use localhost
                link = 'http://localhost:3000/viewer-dashboard.html';
            } else {
                link = window.location.origin + window.location.pathname.replace('dashboard.html', 'viewer-dashboard.html');
            }
            // Update the input field
            const input = document.getElementById('viewerDashboardLink');
            if (input) input.value = link;
            
            navigator.clipboard.writeText(link).then(() => {
                alert('‚úÖ Viewer dashboard link copied!');
            }).catch(() => {
                if (input) {
                    input.select();
                    document.execCommand('copy');
                }
                alert('‚úÖ Viewer dashboard link copied!');
            });
        }

        // ============================================
        // Widget Background (Swatches)
        // ============================================
        function setWidgetBackground(value, shouldUpdate = true) {
            const v = String(value || 'transparent').toLowerCase();
            const input = document.getElementById('widgetBackground');
            if (input) input.value = v;

            // Highlight selection
            document.querySelectorAll('.bg-swatch').forEach(btn => {
                const bg = (btn.getAttribute('data-bg') || '').toLowerCase();
                btn.classList.toggle('selected', bg === v);
            });

            // On Windows, transparent + native frame is unreliable.
            // If the user chooses Transparent, force frameless for stability.
            const isWindows = /Windows/i.test(navigator.userAgent || '');
            if (isWindows) {
                const frameEl = document.getElementById('useNativeFrame');
                const hintEl = document.getElementById('useNativeFrameHint');
                if (v === 'transparent') {
                    if (frameEl) {
                        frameEl.checked = false;
                        frameEl.disabled = true;
                    }
                    if (hintEl) {
                        hintEl.textContent = 'On Windows, Transparent forces frameless mode for stability (prevents blank/click-through windows).';
                    }
                } else {
                    if (frameEl) {
                        frameEl.disabled = false;
                    }
                    if (hintEl) {
                        hintEl.textContent = 'Tip: Turning this off makes the widget window frameless, and the in-widget menu bar becomes the draggable area.';
                    }
                }
            }

            if (shouldUpdate) updateFullPreview();
        }
        
        // Update viewer dashboard link on page load
        function updateViewerDashboardLink() {
            const input = document.getElementById('viewerDashboardLink');
            if (input) {
                if (window.location.protocol === 'file:') {
                    input.value = 'http://localhost:3000/viewer-dashboard.html';
                } else {
                    input.value = window.location.origin + window.location.pathname.replace('dashboard.html', 'viewer-dashboard.html');
                }
            }
        }

        function getSettings() {
            const joinMethodValue = document.getElementById('joinMethod')?.value || 'command';
            return {
                campfireMethod: document.getElementById('campfireMethod')?.value || 'url',
                campfireGraphicUrl: document.getElementById('campfireUrl')?.value || '',
                campfireGraphicData: localStorage.getItem('campfireGraphicData') || '',
                circleAngle: parseInt(document.getElementById('circleAngle')?.value || 64),
                campfireYOffset: parseInt(document.getElementById('campfireYOffset')?.value || 50),
                widgetBackground: document.getElementById('widgetBackground')?.value || 'black',
                useNativeFrame: document.getElementById('useNativeFrame')?.checked !== false,
                showTestUsers: false, // Using buttons instead of checkbox
                joinMethod: joinMethodValue,
                command: document.getElementById('command')?.value || '!join',
                emoteName: document.getElementById('emoteName')?.value || '',
                maxUsers: parseInt(document.getElementById('maxUsers')?.value || 20),
                subscriberOnly: document.getElementById('subscriberOnly')?.checked || false,
                subTier2Only: document.getElementById('subTier2Only')?.checked || false,
                subTier3Only: document.getElementById('subTier3Only')?.checked || false,
                vipOnly: document.getElementById('vipOnly')?.checked || false,
                primeOnly: document.getElementById('primeOnly')?.checked || false,
                cheerMethod: joinMethodValue === 'cheer' ? (document.getElementById('cheerMethod')?.value || 'bits') : null,
                cheerAmount: joinMethodValue === 'cheer' ? parseInt(document.getElementById('cheerAmount')?.value || 100) : 0,
                spriteMode: document.getElementById('spriteMode')?.value || 'circles',
                glowSize: parseInt(document.getElementById('glowSize')?.value || 500),
                glowIntensity: parseInt(document.getElementById('glowIntensity')?.value || 77),
                shadowIntensity: parseInt(document.getElementById('shadowIntensity')?.value || 91),
                glowSpread: parseInt(document.getElementById('glowSpread')?.value || 64),
                animatedGlow: document.getElementById('animatedGlow')?.checked !== false,
                flickerOpacity: parseInt(document.getElementById('flickerOpacity')?.value || 25),
                flickerSpread: parseInt(document.getElementById('flickerSpread')?.value || 55),
                // Legacy support (for backward compatibility)
                defaultSpriteData: localStorage.getItem('defaultSpriteData') || '',
                customSpriteData: localStorage.getItem('customSpriteData') || '',
                // New sprite collections
                shadowSprites: JSON.parse(localStorage.getItem('shadowSprites') || '[]'),
                rpgSprites: JSON.parse(localStorage.getItem('rpgSprites') || '[]'),
                morphSprites: JSON.parse(localStorage.getItem('morphSprites') || '[]'),
                fireSize: parseInt(document.getElementById('fireSize')?.value || 48),
                spriteSize: parseInt(document.getElementById('spriteSize')?.value || 40),
                spriteDefaultDirection: document.getElementById('spriteDirectionLeft')?.classList.contains('active') ? 'left' : 'right', // Legacy
                spriteDefaultDirections: (() => {
                    // Get direction for current mode
                    const currentMode = document.getElementById('spriteMode')?.value || 'circles';
                    const currentDirection = document.getElementById('spriteDirectionLeft')?.classList.contains('active') ? 'left' : 'right';
                    
                    // Load existing directions or initialize
                    const saved = JSON.parse(localStorage.getItem('campfireWidgetSettings') || '{}');
                    const directions = saved.spriteDefaultDirections || {
                        'circles': 'left',
                        'circle': 'left',
                        'rpg-characters': 'left',
                        'pixel-morphs': 'left',
                        'custom': 'left'
                    };
                    
                    // Update current mode's direction
                    directions[currentMode] = currentDirection;
                    return directions;
                })()
            };
        }

        function loadSettings() {
            const saved = localStorage.getItem('campfireWidgetSettings');
            if (saved) {
                try {
                    const settings = JSON.parse(saved);
                    // Handle campfire method - if there's uploaded data, default to upload method
                    const campfireData = localStorage.getItem('campfireGraphicData');
                    const hasUploadedData = campfireData && campfireData.length > 0;
                    const campfireMethod = hasUploadedData ? 'upload' : (settings.campfireMethod || 'url');
                    
                    const campfireMethodEl = document.getElementById('campfireMethod');
                    if (campfireMethodEl) campfireMethodEl.value = campfireMethod;
                    
                    const campfireUrlEl = document.getElementById('campfireUrl');
                    if (campfireUrlEl) campfireUrlEl.value = settings.campfireGraphicUrl || '';
                    
                    // Set the campfire method (this shows/hides the right sections)
                    if (typeof setCampfireMethod === 'function') {
                        setCampfireMethod(campfireMethod);
                    }
                    
                    // Update preview if there's uploaded data (always show it if it exists)
                    // campfireData already declared above, reuse it
                    if (campfireData && campfireData.length > 0) {
                        const preview = document.getElementById('campfirePreview');
                        if (preview) {
                            const isVideo = campfireData.startsWith('data:video/');
                            if (isVideo) {
                                preview.innerHTML = `<video src="${campfireData}" style="max-width: 100%; max-height: 100px; border-radius: 4px;" controls autoplay loop muted></video>`;
                            } else {
                                preview.innerHTML = `<img src="${campfireData}" style="max-width: 100%; max-height: 100px; border-radius: 4px;" alt="Campfire Graphic">`;
                            }
                        }
                    }
                    const circleAngleEl = document.getElementById('circleAngle');
                    if (circleAngleEl) circleAngleEl.value = settings.circleAngle !== undefined ? settings.circleAngle : 64;
                    const campfireYOffsetEl = document.getElementById('campfireYOffset');
                    if (campfireYOffsetEl) campfireYOffsetEl.value = settings.campfireYOffset !== undefined ? settings.campfireYOffset : 50;

                    const widgetBackgroundEl = document.getElementById('widgetBackground');
                    if (widgetBackgroundEl) widgetBackgroundEl.value = settings.widgetBackground || 'black';

                    if (typeof setWidgetBackground === 'function') {
                        setWidgetBackground(settings.widgetBackground || 'black', false);
                    }

                    const useNativeFrameEl = document.getElementById('useNativeFrame');
                    if (useNativeFrameEl) useNativeFrameEl.checked = settings.useNativeFrame !== false;
                    
                    // Default to false (unchecked) if not explicitly set to true
                    // Test users checkbox removed - using buttons instead
                    const joinMethodEl = document.getElementById('joinMethod');
                    if (joinMethodEl) joinMethodEl.value = settings.joinMethod || 'command';
                    
                    const commandEl = document.getElementById('command');
                    if (commandEl) commandEl.value = settings.command || '!join';
                    
                    const emoteNameEl = document.getElementById('emoteName');
                    if (emoteNameEl) emoteNameEl.value = settings.emoteName || '';
                    
                    const maxUsersEl = document.getElementById('maxUsers');
                    if (maxUsersEl) maxUsersEl.value = settings.maxUsers || 20;
                    
                    const subscriberOnlyEl = document.getElementById('subscriberOnly');
                    if (subscriberOnlyEl) subscriberOnlyEl.checked = settings.subscriberOnly || false;
                    
                    const subTier2OnlyEl = document.getElementById('subTier2Only');
                    if (subTier2OnlyEl) subTier2OnlyEl.checked = settings.subTier2Only || false;
                    
                    const subTier3OnlyEl = document.getElementById('subTier3Only');
                    if (subTier3OnlyEl) subTier3OnlyEl.checked = settings.subTier3Only || false;
                    
                    const vipOnlyEl = document.getElementById('vipOnly');
                    if (vipOnlyEl) vipOnlyEl.checked = settings.vipOnly || false;
                    
                    const primeOnlyEl = document.getElementById('primeOnly');
                    if (primeOnlyEl) primeOnlyEl.checked = settings.primeOnly || false;
                    
                    // Handle cheer settings (backward compatible with bitsRequired)
                    if (settings.cheerMethod || settings.joinMethod === 'cheer') {
                        if (joinMethodEl) joinMethodEl.value = 'cheer';
                        const cheerMethodEl = document.getElementById('cheerMethod');
                        if (cheerMethodEl) cheerMethodEl.value = settings.cheerMethod || 'bits';
                        const cheerAmountEl = document.getElementById('cheerAmount');
                        if (cheerAmountEl) cheerAmountEl.value = settings.cheerAmount || 100;
                    } else if (settings.bitsRequired && settings.bitsRequired > 0) {
                        // Legacy: convert old bitsRequired to new cheer system
                        if (joinMethodEl) joinMethodEl.value = 'cheer';
                        const cheerMethodEl = document.getElementById('cheerMethod');
                        if (cheerMethodEl) cheerMethodEl.value = 'bits';
                        const cheerAmountEl = document.getElementById('cheerAmount');
                        if (cheerAmountEl) cheerAmountEl.value = settings.bitsRequired;
                    }
                    if (typeof updateJoinMethod === 'function') updateJoinMethod();
                    
                    const glowSizeEl = document.getElementById('glowSize');
                    if (glowSizeEl) glowSizeEl.value = settings.glowSize || 500;
                    
                    const glowIntensityEl = document.getElementById('glowIntensity');
                    if (glowIntensityEl) glowIntensityEl.value = settings.glowIntensity || 77;
                    
                    const shadowIntensityEl = document.getElementById('shadowIntensity');
                    if (shadowIntensityEl) shadowIntensityEl.value = settings.shadowIntensity || 91;
                    
                    const glowSpreadEl = document.getElementById('glowSpread');
                    if (glowSpreadEl) glowSpreadEl.value = settings.glowSpread || 64;
                    
                    const animatedGlowEl = document.getElementById('animatedGlow');
                    if (animatedGlowEl) animatedGlowEl.checked = settings.animatedGlow !== undefined ? settings.animatedGlow : true;
                    
                    const flickerOpacityEl = document.getElementById('flickerOpacity');
                    if (flickerOpacityEl) flickerOpacityEl.value = settings.flickerOpacity !== undefined ? settings.flickerOpacity : 25;

                    const flickerSpreadEl = document.getElementById('flickerSpread');
                    if (flickerSpreadEl) flickerSpreadEl.value = settings.flickerSpread !== undefined ? settings.flickerSpread : 55;

                    if (typeof updateFlickerOpacityDisplay === 'function') updateFlickerOpacityDisplay();
                    if (typeof updateFlickerSpreadDisplay === 'function') updateFlickerSpreadDisplay();
                    
                    const spriteModeEl = document.getElementById('spriteMode');
                    if (spriteModeEl) spriteModeEl.value = settings.spriteMode || 'circles';
                    
                    const fireSizeEl = document.getElementById('fireSize');
                    if (fireSizeEl) fireSizeEl.value = settings.fireSize || 48;
                    
                    const spriteSizeEl = document.getElementById('spriteSize');
                    if (spriteSizeEl) spriteSizeEl.value = settings.spriteSize || 40;
                    
                    // Load sprite collections
                    if (settings.shadowSprites && settings.shadowSprites.length > 0) {
                        localStorage.setItem('shadowSprites', JSON.stringify(settings.shadowSprites));
                    }
                    if (settings.rpgSprites && settings.rpgSprites.length > 0) {
                        localStorage.setItem('rpgSprites', JSON.stringify(settings.rpgSprites));
                    }
                    if (settings.morphSprites && settings.morphSprites.length > 0) {
                        localStorage.setItem('morphSprites', JSON.stringify(settings.morphSprites));
                    }
                    
                    // Legacy support
                    const defaultSpritePreview = document.getElementById('defaultSpritePreview');
                    if (settings.defaultSpriteData && defaultSpritePreview) {
                        defaultSpritePreview.innerHTML = `<img src="${settings.defaultSpriteData}" style="max-width: 100%; max-height: 60px; border-radius: 4px;">`;
                    }
                    const customSpritePreview = document.getElementById('customSpritePreview');
                    if (settings.customSpriteData && customSpritePreview) {
                        customSpritePreview.innerHTML = `<img src="${settings.customSpriteData}" style="max-width: 100%; max-height: 60px; border-radius: 4px;">`;
                    }
                    
                    // Set sprite default direction for current mode
                    const currentMode = settings.spriteMode || 'circles';
                    const directions = settings.spriteDefaultDirections || {};
                    const spriteDirection = directions[currentMode] || settings.spriteDefaultDirection || 'left';
                    if (typeof setSpriteDirection === 'function') setSpriteDirection(spriteDirection, false);
                    
                    if (typeof updateSpriteMode === 'function') updateSpriteMode();
                    if (typeof updateAngleDisplay === 'function') updateAngleDisplay();
                    if (typeof updateCampfireYOffsetDisplay === 'function') updateCampfireYOffsetDisplay();
                    if (typeof updateGlowSizeDisplay === 'function') updateGlowSizeDisplay();
                    if (typeof updateGlowIntensityDisplay === 'function') updateGlowIntensityDisplay();
                    if (typeof updateShadowIntensityDisplay === 'function') updateShadowIntensityDisplay();
                    if (typeof updateGlowSpreadDisplay === 'function') updateGlowSpreadDisplay();
                    if (typeof updateFireSizeDisplay === 'function') updateFireSizeDisplay();
                    if (typeof updateSpriteSizeDisplay === 'function') updateSpriteSizeDisplay();
                    if (typeof updateFullPreview === 'function') updateFullPreview();
                } catch (e) {
                    console.error('Error loading settings:', e);
                }
            } else {
                if (typeof updateGlowSizeDisplay === 'function') updateGlowSizeDisplay();
                if (typeof updateGlowIntensityDisplay === 'function') updateGlowIntensityDisplay();
                if (typeof updateShadowIntensityDisplay === 'function') updateShadowIntensityDisplay();
                if (typeof updateGlowSpreadDisplay === 'function') updateGlowSpreadDisplay();
                if (typeof updateFireSizeDisplay === 'function') updateFireSizeDisplay();
                if (typeof updateSpriteSizeDisplay === 'function') updateSpriteSizeDisplay();
                if (typeof updateAngleDisplay === 'function') updateAngleDisplay();
                if (typeof updateCampfireYOffsetDisplay === 'function') updateCampfireYOffsetDisplay();
                if (typeof updateFullPreview === 'function') updateFullPreview();
            }
        }

        function saveSettings() {
            const settings = getSettings();
            localStorage.setItem('campfireWidgetSettings', JSON.stringify(settings));
            if (window.electronAPI?.saveSettings) {
                try { window.electronAPI.saveSettings(settings); } catch (e) { console.warn('saveSettings to main failed:', e); }
            }
            window.dispatchEvent(new CustomEvent('campfireSettingsUpdate', { detail: settings }));
            updateFullPreview();
            
            const codeTab = document.getElementById('codeTab');
            if (codeTab && codeTab.classList.contains('active')) {
                generateCode();
            }
            
            showNotification('‚úÖ Settings saved!');
        }

        function saveSettingsWithNotification() {
            saveSettings(); // This already shows the notification
        }

        function resetSettings() {
            showConfirmation(
                'Reset Settings',
                'Are you sure you want to reset all settings to defaults?',
                () => {
                    localStorage.removeItem('campfireWidgetSettings');
                    showNotification('‚úÖ Settings reset! Reloading...');
                    setTimeout(() => {
                        location.reload();
                    }, 1000);
                }
            );
        }

        function testWidget() {
            window.open('widget.html', '_blank');
        }

        async function generateCode() {
            // Wrap entire function in try-catch to prevent breaking the page
            try {
                const codeArea = document.getElementById('widgetCode');
                if (!codeArea) {
                    console.error('Code area not found');
                    return;
                }
                
                // Show loading message
                codeArea.textContent = '<!-- Generating code... -->';
                
                const settings = getSettings();
                
                let widgetCode = '';
                try {
                    const response = await fetch('widget.html');
                    widgetCode = await response.text();
                } catch (e) {
                    console.error('Could not fetch widget.html:', e);
                    codeArea.textContent = '<!-- Error: Could not load widget.html. Please ensure the file exists. -->';
                    return;
                }
                
                const baseUrl = window.location.origin + window.location.pathname.replace('dashboard.html', 'widget.html');
                const params = new URLSearchParams();
                if (settings.campfireGraphicUrl) params.append('graphic', settings.campfireGraphicUrl);
                params.append('angle', settings.circleAngle);
                params.append('joinMethod', settings.joinMethod || 'command');
                params.append('command', settings.command);
                params.append('emoteName', settings.emoteName || '');
                params.append('maxUsers', settings.maxUsers);
                if (settings.subscriberOnly) params.append('subOnly', 'true');
                if (settings.subTier2Only) params.append('subTier2', 'true');
                if (settings.subTier3Only) params.append('subTier3', 'true');
                if (settings.vipOnly) params.append('vipOnly', 'true');
                if (settings.primeOnly) params.append('primeOnly', 'true');
                // Handle cheer/payment method
                if (settings.joinMethod === 'cheer' && settings.cheerMethod) {
                    params.append('joinMethod', 'cheer');
                    params.append('cheerMethod', settings.cheerMethod);
                    params.append('cheerAmount', settings.cheerAmount || 100);
                }
                params.append('glowSize', settings.glowSize || 500);
                params.append('glowIntensity', settings.glowIntensity || 77);
                params.append('shadowIntensity', settings.shadowIntensity || 91);
                params.append('glowSpread', settings.glowSpread || 64);
                if (settings.animatedGlow !== false) params.append('animatedGlow', 'true');
                params.append('flickerOpacity', settings.flickerOpacity ?? 25);
                params.append('flickerSpread', settings.flickerSpread ?? 55);
                params.append('spriteMode', settings.spriteMode || 'default');
                params.append('fireSize', settings.fireSize || 48);
                params.append('spriteSize', settings.spriteSize || 40);
                params.append('spriteDefaultDirection', settings.spriteDefaultDirection || 'left');
                
                // Embed base64 graphics and settings directly into widget code
                // Skip embedding for now to prevent syntax errors - graphics will be loaded from localStorage
                // This prevents the script from breaking with large base64 strings
                let embeddedDataScript = '';
                
                // Only embed if data is small enough and won't break the script
                try {
                    const hasSmallCampfire = settings.campfireGraphicData && settings.campfireGraphicData.length > 0 && settings.campfireGraphicData.length < 100000;
                    const hasSmallDefault = settings.defaultSpriteData && settings.defaultSpriteData.length > 0 && settings.defaultSpriteData.length < 100000;
                    const hasSmallCustom = settings.customSpriteData && settings.customSpriteData.length > 0 && settings.customSpriteData.length < 100000;
                    
                    // Check sprite collections - calculate total size
                    const hasShadowSprites = settings.shadowSprites && settings.shadowSprites.length > 0;
                    const hasRpgSprites = settings.rpgSprites && settings.rpgSprites.length > 0;
                    const hasMorphSprites = settings.morphSprites && settings.morphSprites.length > 0;
                    
                    // Calculate total size of sprite collections
                    let spriteCollectionsSize = 0;
                    if (hasShadowSprites) {
                        const shadowJson = JSON.stringify(settings.shadowSprites);
                        spriteCollectionsSize += shadowJson.length;
                    }
                    if (hasRpgSprites) {
                        const rpgJson = JSON.stringify(settings.rpgSprites);
                        spriteCollectionsSize += rpgJson.length;
                    }
                    if (hasMorphSprites) {
                        const morphJson = JSON.stringify(settings.morphSprites);
                        spriteCollectionsSize += morphJson.length;
                    }
                    
                    // Allow sprite collections to be larger (up to 5MB total) since they're essential
                    const hasSpriteCollections = (hasShadowSprites || hasRpgSprites || hasMorphSprites) && spriteCollectionsSize < 5000000;
                    
                    if (hasSmallCampfire || hasSmallDefault || hasSmallCustom || hasSpriteCollections) {
                        embeddedDataScript = '\n<' + 'script>\n';
                        embeddedDataScript += '(function() {\n';
                        
                        if (hasSmallCampfire) {
                            try {
                                const campfireJson = JSON.stringify(settings.campfireGraphicData);
                                embeddedDataScript += 'localStorage.setItem(\'campfireGraphicData\', ' + campfireJson + ');\n';
                            } catch (e) {
                                console.warn('Could not embed campfire graphic:', e);
                            }
                        }
                        if (hasSmallDefault) {
                            try {
                                const defaultSpriteJson = JSON.stringify(settings.defaultSpriteData);
                                embeddedDataScript += 'localStorage.setItem(\'defaultSpriteData\', ' + defaultSpriteJson + ');\n';
                            } catch (e) {
                                console.warn('Could not embed default sprite:', e);
                            }
                        }
                        if (hasSmallCustom) {
                            try {
                                const customSpriteJson = JSON.stringify(settings.customSpriteData);
                                embeddedDataScript += 'localStorage.setItem(\'customSpriteData\', ' + customSpriteJson + ');\n';
                            } catch (e) {
                                console.warn('Could not embed custom sprite:', e);
                            }
                        }
                        
                        // Embed sprite collections
                        if (hasShadowSprites && spriteCollectionsSize < 5000000) {
                            try {
                                const shadowJson = JSON.stringify(settings.shadowSprites);
                                embeddedDataScript += 'localStorage.setItem(\'shadowSprites\', ' + shadowJson + ');\n';
                            } catch (e) {
                                console.warn('Could not embed shadow sprites:', e);
                            }
                        }
                        if (hasRpgSprites && spriteCollectionsSize < 5000000) {
                            try {
                                const rpgJson = JSON.stringify(settings.rpgSprites);
                                embeddedDataScript += 'localStorage.setItem(\'rpgSprites\', ' + rpgJson + ');\n';
                            } catch (e) {
                                console.warn('Could not embed RPG sprites:', e);
                            }
                        }
                        if (hasMorphSprites && spriteCollectionsSize < 5000000) {
                            try {
                                const morphJson = JSON.stringify(settings.morphSprites);
                                embeddedDataScript += 'localStorage.setItem(\'morphSprites\', ' + morphJson + ');\n';
                            } catch (e) {
                                console.warn('Could not embed morph sprites:', e);
                            }
                        }
                        
                        embeddedDataScript += '})();\n';
                        embeddedDataScript += '<' + '/script>\n';
                    }
                } catch (e) {
                    console.warn('Could not create embedded script:', e);
                    embeddedDataScript = '';
                }
                
                // Insert before closing body tag, or at end if no body tag
                // Skip embedding if it might cause issues
                try {
                    // Allow larger scripts for sprite collections (up to 10MB)
                    if (embeddedDataScript.length < 10000000) { // 10MB limit for embedded script (to accommodate sprite collections)
                        if (widgetCode.includes('</body>')) {
                            widgetCode = widgetCode.replace('</body>', embeddedDataScript + '</body>');
                        } else {
                            widgetCode += embeddedDataScript;
                        }
                    } else {
                        console.warn('Embedded script too large (' + (embeddedDataScript.length / 1000000).toFixed(2) + 'MB), skipping embedding');
                    }
                } catch (e) {
                    console.warn('Could not embed script, continuing without embedded data:', e);
                }
                
                // Build the code string safely using string concatenation
                const header = '<!-- \n' +
                    'OBS CAMPFIRE WIDGET\n' +
                    '==========================================\n\n' +
                    'INSTRUCTIONS:\n' +
                    '1. Copy the ENTIRE code below (everything between the comment markers)\n' +
                    '2. In OBS, add a Browser Source\n' +
                    '3. Set the URL to a local file path or hosted URL, OR paste this code into your streaming software\'s custom widget feature\n' +
                    '4. Save and add to your scene\n\n' +
                    'NOTE: Custom graphics (campfire and sprites) are embedded in this code.\n\n' +
                    '==========================================\n' +
                    '-->\n\n';
                
                const footer = '\n\n<!-- \n' +
                    'END OF WIDGET CODE\n' +
                    'Copy everything above this line into OBS Browser Source or your streaming software\'s custom widget feature\n\n' +
                    'NOTE: Custom graphics (campfire and sprites) are embedded in this code as base64 data.\n' +
                    '-->';
                
                // Use string concatenation to avoid issues with large strings
                // Only set textContent if codeArea exists and is visible
                if (codeArea) {
                    try {
                        codeArea.textContent = header + widgetCode + footer;
                    } catch (e) {
                        console.error('Error setting code text:', e);
                        codeArea.textContent = '<!-- Error: Code too large to display. Please use smaller graphics or refresh the page. -->';
                    }
                }
            } catch (e) {
                console.error('Error generating code:', e);
                const codeArea = document.getElementById('widgetCode');
                if (codeArea) {
                    codeArea.textContent = '<!-- \n' +
                        'ERROR: Could not generate widget code.\n\n' +
                        'Error: ' + (e.message || 'Unknown error') + '\n\n' +
                        'Please try:\n' +
                        '1. Refresh the page\n' +
                        '2. Clear your browser cache\n' +
                        '3. Try again\n\n' +
                        'If the problem persists, check the browser console for details.\n' +
                        '-->';
                }
            }
        }

        function copyCode() {
            const code = document.getElementById('widgetCode').textContent;
            navigator.clipboard.writeText(code).then(() => {
                alert('‚úÖ Code copied to clipboard!');
            }).catch(() => {
                const textarea = document.createElement('textarea');
                textarea.value = code;
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand('copy');
                document.body.removeChild(textarea);
                alert('‚úÖ Code copied to clipboard!');
            });
        }

        // Initialize - wrap in try-catch to prevent page breakage
        async function initializeDashboard() {
            try {
                console.log('[Dashboard] initializeDashboard called');
                console.log('[Dashboard] Window title:', document.title);
                console.log('[Dashboard] Is desktop app:', isDesktopApp());
                
                // ONLY enter widget-mode if this is NOT a separate dashboard window
                // Check if this is the separate settings/dashboard window by looking at the title
                const isSeparateDashboard = document.title.includes('Dashboard');
                console.log('[Dashboard] Is separate dashboard:', isSeparateDashboard);
                
                if (isSeparateDashboard) {
                    console.log('[Dashboard] This is separate dashboard window - showing normal dashboard UI');
                    
                    // Add dashboard-window class to prevent widget-mode CSS from hiding content
                    document.body.classList.add('dashboard-window');
                    document.body.classList.remove('widget-mode');
                    console.log('[Dashboard] Added dashboard-window class, removed widget-mode');
                    
                    // Force show the overlayCard and backdrop with dashboard content
                    const overlayCard = document.getElementById('overlayCard');
                    const overlayBackdrop = document.getElementById('overlayBackdrop');
                    if (overlayCard) {
                        overlayCard.style.display = 'flex';
                        overlayCard.style.visibility = 'visible';
                        overlayCard.style.opacity = '1';
                        console.log('[Dashboard] overlayCard forced visible');
                    } else {
                        console.error('[Dashboard] overlayCard not found!');
                    }
                    if (overlayBackdrop) {
                        overlayBackdrop.style.display = 'block';
                        overlayBackdrop.style.visibility = 'visible';
                        overlayBackdrop.style.opacity = '1';
                        console.log('[Dashboard] overlayBackdrop forced visible');
                    }
                }
                
                if (isDesktopApp() && !isSeparateDashboard) {
                    console.log('[Dashboard] This is the widget window, enabling widget-mode');
                    // FORCE PREVIEW AND MENU VISIBLE FIRST, before adding widget-mode
                    const panel = document.getElementById('previewPanel');
                    const iframe = document.getElementById('fullWidgetPreview');
                    const menuBar = document.getElementById('desktopMenuBar');
                    
                    if (panel) {
                        panel.classList.remove('collapsed');
                        panel.style.cssText = 'position: fixed !important; top: 0 !important; left: 0 !important; width: 100vw !important; height: 100vh !important; padding: 0 !important; border: none !important; background: #000000 !important; z-index: 1000 !important; display: flex !important; flex-direction: column !important; visibility: visible !important; opacity: 1 !important;';
                        console.log('[Dashboard] Preview panel forced visible BEFORE widget-mode');
                    }
                    
                    if (iframe) {
                        if (!iframe.src || iframe.src === '' || iframe.src === 'about:blank') {
                            iframe.src = iframe.getAttribute('data-src') || 'widget.html';
                        }
                        iframe.style.cssText = 'width: 100% !important; height: 100% !important; border: none !important; display: block !important; visibility: visible !important; opacity: 1 !important;';
                        console.log('[Dashboard] Iframe forced visible, src:', iframe.src);
                    }
                    
                    if (menuBar) {
                        menuBar.classList.add('desktop-app');
                        menuBar.style.cssText = 'position: fixed !important; top: 10px !important; left: 50% !important; transform: translateX(-50%) !important; display: flex !important; z-index: 999999 !important; opacity: 1 !important; visibility: visible !important; flex-direction: row !important; align-items: center !important; gap: 8px !important;';
                        console.log('[Dashboard] Menu bar forced visible BEFORE widget-mode');
                    }
                    
                    // NOW add widget-mode
                    document.body.classList.add('widget-mode');
                    console.log('[Dashboard] Added widget-mode class to body');
                    
                    // RE-ENFORCE visibility after widget-mode is applied AND keep enforcing
                    const enforceVisibility = () => {
                        if (panel) {
                            panel.style.cssText = 'position: fixed !important; top: 0 !important; left: 0 !important; width: 100vw !important; height: 100vh !important; padding: 0 !important; border: none !important; background: #000000 !important; z-index: 1000 !important; display: flex !important; flex-direction: column !important; visibility: visible !important; opacity: 1 !important;';
                            panel.classList.remove('collapsed');
                        }
                        if (menuBar) {
                            menuBar.style.cssText = 'position: fixed !important; top: 10px !important; left: 50% !important; transform: translateX(-50%) !important; display: flex !important; z-index: 999999 !important; opacity: 1 !important; visibility: visible !important; flex-direction: row !important; align-items: center !important; gap: 8px !important;';
                            menuBar.classList.remove('hidden');
                        }
                    };
                    
                    requestAnimationFrame(enforceVisibility);
                    // Keep enforcing every 100ms for the first 2 seconds to prevent anything from hiding it
                    let enforceCount = 0;
                    const enforceInterval = setInterval(() => {
                        enforceVisibility();
                        enforceCount++;
                        if (enforceCount >= 20) { // 20 * 100ms = 2 seconds
                            clearInterval(enforceInterval);
                        }
                    }, 100);
                }
                // Only reset graphics if there's an issue (don't auto-reset every time)
                // Check if we need to reset by looking for very large localStorage items
                try {
                    const campfireData = localStorage.getItem('campfireGraphicData');
                    if (campfireData && campfireData.length > 10000000) { // 10MB limit
                        console.log('Large graphic detected, clearing to prevent issues...');
                        localStorage.removeItem('campfireGraphicData');
                    }
                } catch (e) {
                    console.warn('Could not check campfire data:', e);
                }
                
                // Load widget code (non-blocking)
                try {
                    loadWidgetCode();
                } catch (e) {
                    console.warn('Could not load widget code:', e);
                }
                
                // Initialize live preview toggle - FORCE ON in desktop app widget-mode ONLY
                try {
                    const isSeparateDashboard = document.title.includes('Dashboard');
                    
                    if (isDesktopApp() && !isSeparateDashboard) {
                        // This is widget window - enable preview
                        livePreviewEnabled = true;
                        
                        // Force preview panel to be visible immediately and KEEP IT VISIBLE
                        const panel = document.getElementById('previewPanel');
                        const iframe = document.getElementById('fullWidgetPreview');
                        if (panel) {
                            panel.classList.remove('collapsed');
                            panel.style.cssText = 'position: fixed !important; top: 0 !important; left: 0 !important; width: 100vw !important; height: 100vh !important; padding: 0 !important; border: none !important; background: #000000 !important; z-index: 1000 !important; display: flex !important; flex-direction: column !important; visibility: visible !important; opacity: 1 !important;';
                            console.log('[Dashboard] Preview panel forced visible and locked');
                        }
                        if (iframe) {
                            if (!iframe.src || iframe.src === '' || iframe.src === 'about:blank') {
                                iframe.src = iframe.getAttribute('data-src') || 'widget.html';
                            }
                            iframe.style.cssText = 'width: 100% !important; height: 100% !important; border: none !important; display: block !important; visibility: visible !important; opacity: 1 !important;';
                        }
                    } else if (isDesktopApp() && isSeparateDashboard) {
                        // This is separate dashboard window - just load settings normally
                        console.log('[Dashboard] Separate dashboard window - loading normally');
                        livePreviewEnabled = false; // No preview in separate dashboard
                    } else {
                        livePreviewEnabled = loadLivePreviewSetting();
                        updateLivePreviewUI();
                    }
                    console.log('[Dashboard] Preview enabled:', livePreviewEnabled);
                } catch (e) {
                    console.warn('Could not initialize live preview toggle:', e);
                }
                
                enableHoverControls();

                // Always listen for full-state sync from main process
                if (window.electronAPI && window.electronAPI.onSyncFullState && !window.syncFullStateListenerSet) {
                    window.electronAPI.onSyncFullState((users) => {
                        if (!livePreviewEnabled) return;
                        const iframe = document.getElementById('fullWidgetPreview');
                        if (iframe && iframe.contentWindow) {
                            iframe.contentWindow.postMessage({
                                type: 'syncFullState',
                                users: Array.isArray(users) ? users : []
                            }, '*');
                        }
                    });
                    window.syncFullStateListenerSet = true;
                }
                
                // Initialize sprite direction to default (left) if not set
                try {
                    const saved = localStorage.getItem('campfireWidgetSettings');
                    if (!saved) {
                        setSpriteDirection('left', false);
                    }
                } catch (e) {
                    console.warn('Could not set sprite direction:', e);
                }
                
                // Load RPG sprites from folder if not already loaded
                try {
                    await loadRpgSpritesFromFolder();
                } catch (e) {
                    console.error('‚ùå Error loading RPG sprites from folder:', e);
                }
                
                // Load shadow sprites from folder if not already loaded
                try {
                    await loadShadowSpritesFromFolder();
                } catch (e) {
                    console.error('‚ùå Error loading shadow sprites from folder:', e);
                }
                
                // Load pixel morph sprites from folder if not already loaded
                try {
                    await loadMorphSpritesFromFolder();
                } catch (e) {
                    console.error('‚ùå Error loading pixel morph sprites from folder:', e);
                }
                
                // Load settings
                try {
                    loadSettings();
                } catch (e) {
                    console.error('Error loading settings:', e);
                }
                
                // Load Twitch config if in Electron
                try {
                    if (window.electronAPI) {
                        loadTwitchConfig();
                        loadAppVersion();
                        setupUpdateChecker();
                        setupTwitchStatusListeners();
                        setupBottomConnectionIndicator();
                        window.electronAPI.onTwitchConnected(() => updateOverlayStatus(true));
                        window.electronAPI.onTwitchDisconnected(() => updateOverlayStatus(false));
                        window.electronAPI.getTwitchStatus().then(status => {
                            updateOverlayStatus(!!status?.connected);
                        }).catch(() => {
                            updateOverlayStatus(false);
                        });
                    } else {
                        // Set version for localhost/web version
                        const versionEl = document.getElementById('versionNumber');
                        if (versionEl) {
                            versionEl.textContent = 'Localhost/Web';
                        }
                    }
                } catch (e) {
                    console.warn('Could not load Twitch config:', e);
                }
                
                // Update preview when settings change
                try {
                    const circleAngleEl = document.getElementById('circleAngle');
                    const campfireUrlEl = document.getElementById('campfireUrl');
                    const commandEl = document.getElementById('command');
                    if (circleAngleEl) {
                        circleAngleEl.addEventListener('input', updateFullPreview);
                    }
                    if (campfireUrlEl) {
                        campfireUrlEl.addEventListener('input', updateFullPreview);
                    }
                    if (commandEl) {
                        commandEl.addEventListener('input', updateCurrentCommandDisplay);
                    }
                } catch (e) {
                    console.warn('Could not attach event listeners:', e);
                }
                
                console.log('‚úÖ Dashboard initialized');
            } catch (error) {
                console.error('Critical error during initialization:', error);
                // Don't show alert - just log it so page can still load
            }
        }

        // Wait for DOM to be ready before initializing
        try {
            if (document.readyState === 'loading') {
                // Listen for tab switch messages from main process
                if (window.electronAPI && window.electronAPI.onSwitchTab) {
                    window.electronAPI.onSwitchTab((tabName) => {
                        console.log('[Dashboard] Received switch-tab message:', tabName);
                        if (tabName === 'settings') {
                            // Switch to first settings tab (campfire)
                            const campfireTab = document.querySelector('.tab[onclick*="campfire"]');
                            if (campfireTab) {
                                switchSettingsTab('campfire', campfireTab);
                            }
                        } else if (tabName === 'members') {
                            // Switch to members tab
                            const membersTab = document.querySelector('.tab[onclick*="members"]');
                            if (membersTab) {
                                switchTab('members', membersTab);
                            } else {
                                switchTab('members');
                            }
                        } else {
                            // Try to switch to the tab
                            switchTab(tabName);
                        }
                    });
                }
                
                // Listen for open-settings-modal message (from main process)
                if (window.electronAPI && window.electronAPI.onOpenSettingsModal) {
                    window.electronAPI.onOpenSettingsModal(() => {
                        openSettings();
                    });
                }
                
                document.addEventListener('DOMContentLoaded', async () => {
                    await initializeDashboard();
                    updateViewerDashboardLink();
                    
                    // Load members list on startup (ensures TestUsers appear immediately, toggled off)
                    if (typeof loadDashboardMembers === 'function') {
                        await loadDashboardMembers();
                    }
                    
                    // Initialize all sliders with background fill
                    initializeAllSliders();
                    
                    // Listen for storage events to sync sprite mode dropdown when Quick Settings changes it (cross-window)
                    window.addEventListener('storage', (e) => {
                        if (e.key === 'campfireWidgetSettings') {
                            try {
                                const newSettings = JSON.parse(e.newValue);
                                if (newSettings.spriteMode !== undefined) {
                                    const dashboardSpriteModeSelect = document.getElementById('spriteMode');
                                    if (dashboardSpriteModeSelect && dashboardSpriteModeSelect.value !== newSettings.spriteMode) {
                                        // Prevent triggering onchange event by temporarily removing listener
                                        const oldOnchange = dashboardSpriteModeSelect.onchange;
                                        dashboardSpriteModeSelect.onchange = null;
                                        dashboardSpriteModeSelect.value = newSettings.spriteMode;
                                        dashboardSpriteModeSelect.onchange = oldOnchange;
                                        // Trigger UI update (show/hide sections) but don't save again
                                        if (typeof updateSpriteMode === 'function') {
                                            // Pass skipSave=true to prevent saving and triggering another event
                                            updateSpriteMode(true);
                                        }
                                    }
                                }
                            } catch (err) {
                                console.error('Error syncing sprite mode from storage:', err);
                            }
                        }
                    });
                    
                    // Enable widget-mode by default in desktop app (after initialization)
                    // BUT NOT if this is a separate dashboard window
                    const isSeparateDashboard = (window.electronAPI || navigator.userAgent.includes('Electron')) && window.location.pathname.includes('dashboard.html');
                    if ((window.electronAPI || navigator.userAgent.includes('Electron')) && !isSeparateDashboard) {
                        document.body.classList.add('widget-mode');
                        
                        // Ensure preview is enabled and loaded
                        setLivePreviewEnabled(true);
                        updateLivePreviewUI();
                        
                        // Initialize menu bar
                        setTimeout(() => initDesktopMenuBar(), 200);
                    }
                });
            } else {
                // DOM already loaded, initialize immediately
                initializeDashboard();
                updateViewerDashboardLink();
            }
        } catch (e) {
            console.error('Failed to set up initialization:', e);
            // Try to initialize anyway after a short delay
            setTimeout(initializeDashboard, 100);
        }

        // Twitch OAuth Functions
        async function loadTwitchConfig() {
            if (!window.electronAPI) {
                console.log('Not running in Electron - Twitch config unavailable');
                return;
            }
            
            try {
                const config = await window.electronAPI.getTwitchConfig();
                if (config) {
                    document.getElementById('twitchBotUsername').value = config.botUsername || '';
                    document.getElementById('twitchChannelName').value = config.channelName || '';
                    document.getElementById('twitchAccessToken').value = config.accessToken || '';
                    document.getElementById('twitchRefreshToken').value = config.refreshToken || '';
                    document.getElementById('twitchClientId').value = config.clientId || '';
                    
                    // Check if chat bot credentials are different from main (indicating separate bot was used)
                    const useSeparateBot = config.chatBotUsername && 
                                          (config.chatBotUsername !== config.botUsername || 
                                           config.chatBotAccessToken !== config.accessToken);
                    
                    document.getElementById('useSeparateChatBot').checked = useSeparateBot;
                    
                    document.getElementById('twitchChatBotUsername').value = config.chatBotUsername || '';
                    document.getElementById('twitchChatBotAccessToken').value = config.chatBotAccessToken || '';
                    document.getElementById('twitchChatBotRefreshToken').value = config.chatBotRefreshToken || '';
                    document.getElementById('twitchChatBotClientId').value = config.chatBotClientId || '';
                    
                    // Initialize chat bot inputs state (ensure it runs after DOM is ready)
                    setTimeout(() => {
                        toggleChatBotInputs();
                    }, 100);
                    
                    // Update status with real-time connection check
                    setTimeout(async () => {
                        await updateTwitchStatus(config);
                    }, 500);
                }
            } catch (e) {
                console.error('Error loading Twitch config:', e);
            }
        }

        async function generateTwitchToken(accountType = 'main') {
            if (!window.electronAPI) {
                alert('This feature is only available in the desktop app. Please use the desktop application.');
                return;
            }
            
            const button = accountType === 'main' 
                ? document.getElementById('generateTwitchToken')
                : document.getElementById('generateChatBotToken');
            const tokenInput = accountType === 'main'
                ? document.getElementById('twitchAccessToken')
                : document.getElementById('twitchChatBotAccessToken');
            
            if (!button) return;
            
            button.disabled = true;
            button.textContent = '‚è≥ Opening Twitch...';
            
            try {
                const result = await window.electronAPI.generateTwitchToken(accountType);
                if (result && result.token) {
                    if (tokenInput) tokenInput.value = result.token;
                    button.textContent = accountType === 'main' ? 'üîë Generate Twitch Token' : 'üîë Generate Chat Bot Token';
                    button.disabled = false;
                    alert('Token received. Enter your Username and Channel, then click Save Configuration to connect.');
                } else {
                    button.textContent = accountType === 'main' ? 'üîë Generate Twitch Token' : 'üîë Generate Chat Bot Token';
                    button.disabled = false;
                }
            } catch (e) {
                console.error('Error generating token:', e);
                
                if (e.message === 'MANUAL_ENTRY_REQUIRED') {
                    button.textContent = accountType === 'main' ? 'üîë Generate Twitch Token' : 'üîë Generate Chat Bot Token';
                    button.disabled = false;
                    return;
                }
                
                alert('Error generating token: ' + e.message);
                button.textContent = accountType === 'main' ? 'üîë Generate Twitch Token' : 'üîë Generate Chat Bot Token';
                button.disabled = false;
            }
        }

        function toggleTokenVisibility() {
            const tokenInput = document.getElementById('twitchOAuthToken');
            const button = event.target;
            if (tokenInput.type === 'password') {
                tokenInput.type = 'text';
                button.textContent = 'üôà Hide';
            } else {
                tokenInput.type = 'password';
                button.textContent = 'üëÅÔ∏è Show';
            }
        }
        
        function toggleAccessTokenVisibility() {
            const tokenInput = document.getElementById('twitchAccessToken');
            const button = event.target;
            if (!tokenInput || !button) return;
            
            if (tokenInput.type === 'password') {
                tokenInput.type = 'text';
                button.textContent = 'üôà';
            } else {
                tokenInput.type = 'password';
                button.textContent = 'üëÅÔ∏è';
            }
        }
        
        function toggleRefreshTokenVisibility() {
            const tokenInput = document.getElementById('twitchRefreshToken');
            const button = event.target;
            if (!tokenInput || !button) return;
            
            if (tokenInput.type === 'password') {
                tokenInput.type = 'text';
                button.textContent = 'üôà';
            } else {
                tokenInput.type = 'password';
                button.textContent = 'üëÅÔ∏è';
            }
        }
        
        function toggleChatBotAccessTokenVisibility() {
            const tokenInput = document.getElementById('twitchChatBotAccessToken');
            const button = event.target;
            if (!tokenInput || !button) return;
            
            if (tokenInput.type === 'password') {
                tokenInput.type = 'text';
                button.textContent = 'üôà';
            } else {
                tokenInput.type = 'password';
                button.textContent = 'üëÅÔ∏è';
            }
        }
        
        function toggleChatBotRefreshTokenVisibility() {
            const tokenInput = document.getElementById('twitchChatBotRefreshToken');
            const button = event.target;
            if (!tokenInput || !button) return;
            
            if (tokenInput.type === 'password') {
                tokenInput.type = 'text';
                button.textContent = 'üôà';
            } else {
                tokenInput.type = 'password';
                button.textContent = 'üëÅÔ∏è';
            }
        }

        function autoFillUsernameFromChannel() {
            // Auto-fill username from channel name if username is empty or readonly
            const channelName = document.getElementById('twitchChannelName').value.trim();
            const usernameInput = document.getElementById('twitchBotUsername');
            
            // Only auto-fill if username is readonly (meaning user hasn't clicked into it)
            if (channelName && usernameInput.hasAttribute('readonly') && !usernameInput.value.trim()) {
                usernameInput.value = channelName;
            } else if (channelName && usernameInput.hasAttribute('readonly')) {
                // If username already has value, only update if it matches old channel name
                // This prevents overwriting user edits
            }
        }
        
        function toggleChatBotInputs() {
            const checkbox = document.getElementById('useSeparateChatBot');
            if (!checkbox) return;
            
            const enabled = checkbox.checked;
            
            // Get all chat bot inputs and buttons
            const inputs = [
                document.getElementById('twitchChatBotUsername'),
                document.getElementById('twitchChatBotAccessToken'),
                document.getElementById('twitchChatBotRefreshToken'),
                document.getElementById('twitchChatBotClientId'),
                document.getElementById('generateChatBotToken'),
                document.getElementById('connectChatBotBtn')
            ];
            
            // Get all chat bot visibility toggle buttons
            const buttons = [
                ...document.querySelectorAll('button[onclick="toggleChatBotAccessTokenVisibility()"]'),
                ...document.querySelectorAll('button[onclick="toggleChatBotRefreshTokenVisibility()"]')
            ];
            
            inputs.forEach(input => {
                if (input) {
                    input.disabled = !enabled;
                    if (input.tagName === 'INPUT') {
                        input.style.opacity = enabled ? '1' : '0.5';
                        input.style.cursor = enabled ? 'text' : 'not-allowed';
                    } else if (input.tagName === 'BUTTON') {
                        input.style.opacity = enabled ? '1' : '0.5';
                        input.style.cursor = enabled ? 'pointer' : 'not-allowed';
                    }
                }
            });
            
            buttons.forEach(button => {
                if (button) {
                    button.disabled = !enabled;
                    button.style.opacity = enabled ? '1' : '0.5';
                    button.style.cursor = enabled ? 'pointer' : 'not-allowed';
                }
            });
            
            // If disabled, mirror main account values
            if (!enabled) {
                mirrorMainAccountToChatBot();
            } else {
                // Clear chat bot values when enabling
                document.getElementById('twitchChatBotUsername').value = '';
                document.getElementById('twitchChatBotAccessToken').value = '';
                document.getElementById('twitchChatBotRefreshToken').value = '';
                document.getElementById('twitchChatBotClientId').value = '';
            }
        }
        
        function mirrorMainAccountToChatBot() {
            // Mirror main account credentials to chat bot (when checkbox is unchecked)
            const mainUsername = document.getElementById('twitchBotUsername').value;
            const mainAccessToken = document.getElementById('twitchAccessToken').value;
            const mainRefreshToken = document.getElementById('twitchRefreshToken').value;
            const mainClientId = document.getElementById('twitchClientId').value;
            
            document.getElementById('twitchChatBotUsername').value = mainUsername;
            document.getElementById('twitchChatBotAccessToken').value = mainAccessToken;
            document.getElementById('twitchChatBotRefreshToken').value = mainRefreshToken;
            document.getElementById('twitchChatBotClientId').value = mainClientId;
        }
        
        async function disconnectTwitchAccount(accountType) {
            if (!window.electronAPI) return;
            
            try {
                await window.electronAPI.disconnectTwitch();
                
                // Update UI
                const statusIcon = document.getElementById('twitchStatusIcon');
                const statusText = document.getElementById('twitchStatusText');
                if (statusIcon && statusText) {
                    statusIcon.textContent = '‚ö™';
                    statusText.textContent = 'Not Connected';
                }
                
                // Hide disconnect buttons, show connect buttons
                const disconnectMainBtn = document.getElementById('disconnectMainBtn');
                const disconnectChatBotBtn = document.getElementById('disconnectChatBotBtn');
                const connectMainBtn = document.querySelector('button[onclick="connectTwitchAccount(\'main\')"]');
                const connectChatBotBtn = document.getElementById('connectChatBotBtn');
                
                if (disconnectMainBtn) disconnectMainBtn.style.display = 'none';
                if (disconnectChatBotBtn) disconnectChatBotBtn.style.display = 'none';
                if (connectMainBtn) connectMainBtn.style.display = 'block';
                if (connectChatBotBtn) connectChatBotBtn.style.display = 'block';
                
                alert('‚úÖ Disconnected from Twitch');
            } catch (e) {
                console.error('Error disconnecting:', e);
                alert('‚ùå Error disconnecting: ' + e.message);
            }
        }
        
        async function connectTwitchAccount(accountType) {
            const button = accountType === 'main' 
                ? document.querySelector('button[onclick="connectTwitchAccount(\'main\')"]')
                : document.getElementById('connectChatBotBtn');
            
            const originalText = button ? button.textContent : '';
            if (button) {
                button.disabled = true;
                button.textContent = '‚è≥ Connecting...';
            }
            
            try {
                // Track connection attempt time
                window.lastConnectAttempt = Date.now();
                
                // Save and connect (this triggers immediate reconnection in main process)
                await saveTwitchConfig();
                
                // Poll for connection status with timeout
                let attempts = 0;
                const maxAttempts = 30; // 15 seconds max (increased for slower connections)
                let connectionError = null;
                
                // Set up error listener for this connection attempt
                const errorListener = (data) => {
                    connectionError = data;
                };
                window.electronAPI.onTwitchError(errorListener);
                
                const checkConnection = async () => {
                    attempts++;
                    const status = await window.electronAPI.getTwitchStatus();
                    
                    if (status.connected) {
                        // Remove error listener
                        window.electronAPI.onTwitchError(() => {}); // Clear listener
                        if (button) {
                            button.disabled = false;
                            button.textContent = originalText;
                        }
                        updateTwitchStatusFromMain();
                        return; // Success!
                    }
                    
                    // Check if we got an error
                    if (connectionError) {
                        window.electronAPI.onTwitchError(() => {}); // Clear listener
                        if (button) {
                            button.disabled = false;
                            button.textContent = originalText;
                        }
                        updateTwitchStatusFromMain();
                        
                        let errorMsg = '‚ùå Connection failed. ';
                        if (connectionError.error && connectionError.error.toLowerCase().includes('authentication')) {
                            errorMsg = '‚ùå Authentication failed. Please check your Access Token and Client ID are correct and try again.';
                        } else if (connectionError.error) {
                            errorMsg += connectionError.error;
                        } else {
                            errorMsg += 'Please check your credentials.';
                        }
                        
                        alert(errorMsg);
                        connectionError = null; // Reset
                        return;
                    }
                    
                    if (attempts < maxAttempts) {
                        setTimeout(checkConnection, 500);
                    } else {
                        // Timeout - connection might have failed
                        window.electronAPI.onTwitchError(() => {}); // Clear listener
                        if (button) {
                            button.disabled = false;
                            button.textContent = originalText;
                        }
                        updateTwitchStatusFromMain();
                        
                        // Show helpful timeout message
                        alert('‚ö†Ô∏è Connection attempt timed out.\n\nThis usually means:\n‚Ä¢ Invalid Access Token\n‚Ä¢ Invalid Client ID\n‚Ä¢ Network connectivity issues\n\nPlease verify your credentials from the token generator and try again.');
                    }
                };
                
                // Start checking after a brief delay
                setTimeout(checkConnection, 1500);
                
            } catch (e) {
                console.error('Error connecting:', e);
                if (button) {
                    button.disabled = false;
                    button.textContent = originalText;
                }
                alert('‚ùå Error connecting: ' + e.message);
            }
        }
        
        function updateTwitchConfig() {
            // If chat bot checkbox is unchecked, mirror main account values
            const checkbox = document.getElementById('useSeparateChatBot');
            if (checkbox && !checkbox.checked) {
                mirrorMainAccountToChatBot();
            }
        }

        async function saveTwitchConfig() {
            if (!window.electronAPI) {
                alert('This feature is only available in the desktop app.');
                return;
            }
            
            const useSeparateBot = document.getElementById('useSeparateChatBot').checked;
            
            const config = {
                botUsername: document.getElementById('twitchBotUsername').value.trim(),
                channelName: document.getElementById('twitchChannelName').value.trim(),
                accessToken: document.getElementById('twitchAccessToken').value.trim(),
                refreshToken: document.getElementById('twitchRefreshToken').value.trim(),
                clientId: document.getElementById('twitchClientId').value.trim(),
                chatBotUsername: useSeparateBot ? document.getElementById('twitchChatBotUsername').value.trim() : '',
                chatBotAccessToken: useSeparateBot ? document.getElementById('twitchChatBotAccessToken').value.trim() : '',
                chatBotRefreshToken: useSeparateBot ? document.getElementById('twitchChatBotRefreshToken').value.trim() : '',
                chatBotClientId: useSeparateBot ? document.getElementById('twitchChatBotClientId').value.trim() : ''
            };
            
            // If not using separate bot, use main account credentials for chat bot
            if (!useSeparateBot) {
                config.chatBotUsername = config.botUsername;
                config.chatBotAccessToken = config.accessToken;
                config.chatBotRefreshToken = config.refreshToken;
                config.chatBotClientId = config.clientId;
            }
            
            if (!config.botUsername || !config.accessToken || !config.channelName) {
                alert('Please fill in all required fields: Username, Access Token, and Channel Name');
                return;
            }
            
            // Client ID is recommended but not strictly required for basic chat reading
            if (!config.clientId) {
                const proceed = confirm('‚ö†Ô∏è Client ID is not set. This is recommended for full functionality.\n\nContinue without Client ID?');
                if (!proceed) return;
            }
            
            // If using separate bot, validate bot credentials
            if (useSeparateBot && config.chatBotUsername && !config.chatBotAccessToken) {
                alert('‚ö†Ô∏è Chat Bot Username provided but no Access Token. Please provide both or uncheck "Use separate bot".');
                return;
            }
            
            try {
                const result = await window.electronAPI.saveTwitchConfig(config);
                if (result.success) {
                    // Configuration saved - connection will be attempted automatically
                    // Poll for connection status
                    setTimeout(async () => {
                        await updateTwitchStatusFromMain();
                    }, 1000);
                } else {
                    alert('Error saving config: ' + (result.error || 'Unknown error'));
                }
            } catch (e) {
                console.error('Error saving Twitch config:', e);
                alert('Error saving configuration: ' + e.message);
            }
        }

        async function updateTwitchStatus(config) {
            const statusIcon = document.getElementById('twitchStatusIcon');
            const statusText = document.getElementById('twitchStatusText');
            const configDisplay = document.getElementById('twitchConfigDisplay');
            const usernameDisplay = document.getElementById('twitchUsernameDisplay');
            const channelDisplay = document.getElementById('twitchChannelDisplay');
            
            // Check actual connection status from main process
            let isConnected = false;
            if (window.electronAPI) {
                try {
                    const status = await window.electronAPI.getTwitchStatus();
                    isConnected = status.connected;
                } catch (e) {
                    console.error('Error getting Twitch status:', e);
                }
            }
            
            // Update based on actual connection status
            if (isConnected && config && config.botUsername && config.channelName) {
                statusIcon.textContent = 'üü¢';
                statusText.textContent = 'Connected';
                configDisplay.style.display = 'block';
                usernameDisplay.textContent = config.botUsername;
                channelDisplay.textContent = config.channelName;
                const disconnectMainBtn = document.getElementById('disconnectMainBtn');
                const connectMainBtn = document.querySelector('button[onclick="connectTwitchAccount(\'main\')"]');
                if (disconnectMainBtn) disconnectMainBtn.style.display = 'block';
                if (connectMainBtn) connectMainBtn.style.display = 'none';
            } else if (config && config.botUsername && config.accessToken && config.channelName) {
                // Has credentials but not connected yet
                // Only show "Connecting..." if it hasn't been more than 15 seconds
                const lastConnectTime = window.lastConnectAttempt || 0;
                const timeSinceConnect = Date.now() - lastConnectTime;
                
                if (timeSinceConnect > 16000) {
                    statusIcon.textContent = 'üî¥';
                    statusText.textContent = 'Connection Failed';
                } else {
                    statusIcon.textContent = 'üü°';
                    statusText.textContent = 'Connecting...';
                }
                configDisplay.style.display = 'block';
                usernameDisplay.textContent = config.botUsername;
                channelDisplay.textContent = config.channelName;
                const disconnectMainBtn = document.getElementById('disconnectMainBtn');
                const connectMainBtn = document.querySelector('button[onclick="connectTwitchAccount(\'main\')"]');
                if (disconnectMainBtn) disconnectMainBtn.style.display = 'none';
                if (connectMainBtn) connectMainBtn.style.display = 'block';
            } else {
                statusIcon.textContent = '‚ö™';
                statusText.textContent = 'Not Connected';
                configDisplay.style.display = 'none';
                const disconnectMainBtn = document.getElementById('disconnectMainBtn');
                const connectMainBtn = document.querySelector('button[onclick="connectTwitchAccount(\'main\')"]');
                if (disconnectMainBtn) disconnectMainBtn.style.display = 'none';
                if (connectMainBtn) connectMainBtn.style.display = 'block';
            }
        }
        
        // Listen for real-time connection status updates (set up on page load)
        function setupTwitchStatusListeners() {
            if (window.electronAPI) {
                window.electronAPI.onTwitchConnected(() => {
                    updateTwitchStatusFromMain();
                    // Show disconnect buttons when connected
                    const disconnectMainBtn = document.getElementById('disconnectMainBtn');
                    const disconnectChatBotBtn = document.getElementById('disconnectChatBotBtn');
                    const connectMainBtn = document.querySelector('button[onclick="connectTwitchAccount(\'main\')"]');
                    const connectChatBotBtn = document.getElementById('connectChatBotBtn');
                    
                    if (disconnectMainBtn) disconnectMainBtn.style.display = 'block';
                    if (disconnectChatBotBtn && connectChatBotBtn && !connectChatBotBtn.disabled) disconnectChatBotBtn.style.display = 'block';
                    if (connectMainBtn) connectMainBtn.style.display = 'none';
                    if (connectChatBotBtn) connectChatBotBtn.style.display = 'none';
                });
                
                window.electronAPI.onTwitchDisconnected((data) => {
                    updateTwitchStatusFromMain();
                    // Hide disconnect buttons when disconnected
                    const disconnectMainBtn = document.getElementById('disconnectMainBtn');
                    const disconnectChatBotBtn = document.getElementById('disconnectChatBotBtn');
                    const connectMainBtn = document.querySelector('button[onclick="connectTwitchAccount(\'main\')"]');
                    const connectChatBotBtn = document.getElementById('connectChatBotBtn');
                    
                    if (disconnectMainBtn) disconnectMainBtn.style.display = 'none';
                    if (disconnectChatBotBtn) disconnectChatBotBtn.style.display = 'none';
                    if (connectMainBtn) connectMainBtn.style.display = 'block';
                    if (connectChatBotBtn) connectChatBotBtn.style.display = 'block';
                    
                    // Show disconnect reason if provided
                    if (data && data.reason && !data.reason.includes('Requested')) {
                        console.log('Disconnected:', data.reason);
                    }
                });
                
                // Listen for potential members updates (viewers from Twitch chat)
                window.electronAPI.onPotentialMembersUpdate((chatters) => {
                    console.log('Potential members updated:', chatters.length, 'chatters');
                    // Refresh members list to include new chatters
                    if (document.getElementById('membersList')) {
                        loadDashboardMembers();
                    }
                });
                
                window.electronAPI.onTwitchError((data) => {
                    console.error('Twitch connection error:', data);
                    updateTwitchStatusFromMain();
                    
                    // Build comprehensive error message
                    let errorMsg = data.error || '‚ö†Ô∏è Twitch connection error.';
                    
                    // Add specific issue if available
                    if (data.specificIssue) {
                        errorMsg = `${data.error}\n\nüîç Issue: ${data.specificIssue}`;
                    }
                    
                    // Add troubleshooting steps
                    if (data.troubleshooting) {
                        errorMsg += '\n\nüîß How to fix:\n' + data.troubleshooting;
                    }
                    
                    // Add credential info for debugging (without exposing full token)
                    if (data.username || data.channel) {
                        errorMsg += '\n\nüìã Current configuration:';
                        if (data.username) {
                            errorMsg += `\n   Username: ${data.username}`;
                        }
                        if (data.channel) {
                            errorMsg += `\n   Channel: ${data.channel}`;
                        }
                    }
                    
                    // Update status to show error
                    const statusIcon = document.getElementById('twitchStatusIcon');
                    const statusText = document.getElementById('twitchStatusText');
                    if (statusIcon && statusText) {
                        statusIcon.textContent = 'üî¥';
                        statusText.textContent = data.specificIssue || 'Connection Failed';
                    }
                    
                    // Show detailed error alert with all information
                    alert(errorMsg);
                });

                // Twitch Chat tab: live messages
                window.electronAPI.onTwitchChatMessage((data) => {
                    const log = document.getElementById('twitchChatLog');
                    const empty = document.getElementById('twitchChatEmpty');
                    if (!log || !data || !data.message) return;
                    if (empty) empty.style.display = 'none';
                    const name = data.displayName || data.username || '?';
                    const color = (data.color && /^#?[0-9A-Fa-f]{6}$/.test(data.color)) ? (data.color.startsWith('#') ? data.color : '#' + data.color) : '#bf94ff';
                    const div = document.createElement('div');
                    div.className = 'chat-msg';
                    div.style.marginBottom = '6px';
                    div.style.wordBreak = 'break-word';
                    div.innerHTML = '<span class="chat-msg-user" style="color:' + color + ';font-weight:600;">' + escapeHtml(name) + '</span>: <span class="chat-msg-text">' + escapeHtml(String(data.message).slice(0, 500)) + '</span>';
                    log.appendChild(div);
                    const msgs = log.querySelectorAll(':scope > .chat-msg');
                    if (msgs.length > 500) msgs[0].remove();
                    const nearBottom = (log.scrollHeight - log.scrollTop - log.clientHeight) < 50;
                    if (nearBottom) log.scrollTop = log.scrollHeight;
                });
            }
        }
        
        async function updateTwitchStatusFromMain() {
            if (!window.electronAPI) return;
            
            try {
                const status = await window.electronAPI.getTwitchStatus();
                const config = await window.electronAPI.getTwitchConfig();
                
                const statusIcon = document.getElementById('twitchStatusIcon');
                const statusText = document.getElementById('twitchStatusText');
                const configDisplay = document.getElementById('twitchConfigDisplay');
                const usernameDisplay = document.getElementById('twitchUsernameDisplay');
                const channelDisplay = document.getElementById('twitchChannelDisplay');
                
                    if (status.connected && config && config.botUsername && config.channelName) {
                        statusIcon.textContent = 'üü¢';
                        statusText.textContent = 'Connected';
                        configDisplay.style.display = 'block';
                        usernameDisplay.textContent = config.botUsername;
                        channelDisplay.textContent = config.channelName;
                        
                        // Show disconnect buttons, hide connect buttons
                        const disconnectMainBtn = document.getElementById('disconnectMainBtn');
                        const disconnectChatBotBtn = document.getElementById('disconnectChatBotBtn');
                        const connectMainBtn = document.querySelector('button[onclick="connectTwitchAccount(\'main\')"]');
                        const connectChatBotBtn = document.getElementById('connectChatBotBtn');
                        
                        if (disconnectMainBtn) disconnectMainBtn.style.display = 'block';
                        if (disconnectChatBotBtn && !connectChatBotBtn.disabled) disconnectChatBotBtn.style.display = 'block';
                        if (connectMainBtn) connectMainBtn.style.display = 'none';
                        if (connectChatBotBtn) connectChatBotBtn.style.display = 'none';
                } else if (config && config.botUsername && config.accessToken && config.channelName) {
                    statusIcon.textContent = 'üü°';
                    statusText.textContent = 'Connecting...';
                    configDisplay.style.display = 'block';
                    usernameDisplay.textContent = config.botUsername;
                    channelDisplay.textContent = config.channelName;
                } else {
                    statusIcon.textContent = '‚ö™';
                    statusText.textContent = 'Not Connected';
                    configDisplay.style.display = 'none';
                }
            } catch (e) {
                console.error('Error updating Twitch status:', e);
            }
        }


        async function loadAppVersion() {
            if (!window.electronAPI) {
                const versionEl = document.getElementById('versionNumber');
                if (versionEl) {
                    versionEl.textContent = 'Localhost/Web';
                }
                return;
            }
            
            try {
                const result = await window.electronAPI.getAppVersion();
                if (result && result.version) {
                    const versionEl = document.getElementById('versionNumber');
                    if (versionEl) {
                        // Format version with 'v' prefix (e.g., "0.0.3" -> "v0.0.3")
                        const version = result.version.startsWith('v') ? result.version : `v${result.version}`;
                        versionEl.textContent = version;
                    }
                } else {
                    const versionEl = document.getElementById('versionNumber');
                    if (versionEl) {
                        versionEl.textContent = 'Unknown';
                    }
                }
            } catch (e) {
                console.error('Error loading app version:', e);
                const versionEl = document.getElementById('versionNumber');
                if (versionEl) {
                    versionEl.textContent = 'Error loading version';
                }
            }
        }

        // Prevent duplicate listeners
        let updateCheckerSetup = false;
        
        function setupUpdateChecker() {
            if (!window.electronAPI) return;
            if (updateCheckerSetup) {
                console.log('Update checker already setup, skipping duplicate registration');
                return;
            }
            updateCheckerSetup = true;
            
            // Listen for update status
            window.electronAPI.onUpdateStatus((data) => {
                if (data.status === 'checking') {
                    // Show checking status
                    console.log('Checking for updates...');
                    showNotification('üîç Checking for updates...');
                } else if (data.status === 'available') {
                    // Get version from DOM (already has 'v' prefix) or from data (needs 'v' prefix)
                    const domVersion = document.getElementById('versionNumber')?.textContent || '';
                    const dataVersion = data.version || '';
                    // Use DOM version if available (already formatted), otherwise format data version
                    const currentVersion = domVersion || (dataVersion ? `v${dataVersion}` : 'current');
                    const newVersion = dataVersion ? `v${dataVersion}` : 'new version';
                    if (confirm(`Update available: ${newVersion}\n\nYou have ${currentVersion}\n\nWould you like to download the update?`)) {
                        downloadUpdate();
                    }
                } else if (data.status === 'not-available') {
                    // Show fade-in/fade-out notification instead of alert
                    // Get version from DOM (already has 'v' prefix) or from data (needs 'v' prefix)
                    const domVersion = document.getElementById('versionNumber')?.textContent || '';
                    const dataVersion = data.version || '';
                    // Use DOM version if available (already formatted), otherwise format data version
                    const currentVersion = domVersion || (dataVersion ? `v${dataVersion}` : 'current');
                    showNotification(`‚úÖ You're up to date! (${currentVersion})`);
                } else if (data.status === 'downloaded') {
                    if (confirm(`Update v${data.version} downloaded and ready to install!\n\nInstall now? The app will restart.`)) {
                        installUpdate();
                    }
                } else if (data.status === 'error') {
                    // Check if it's a 404 (release not found) vs other errors
                    const errorMsg = data.error || 'Unknown error';
                    if (errorMsg.includes('404') || errorMsg.includes('not found')) {
                        // 404 could mean:
                        // 1. Repository doesn't exist or is private
                        // 2. No releases published yet
                        // 3. Repository name/owner is incorrect
                        showNotification('‚ÑπÔ∏è Unable to check for updates. Please verify:\n‚Ä¢ Repository exists and is public\n‚Ä¢ At least one release is published\n‚Ä¢ Repository name is correct');
                    } else {
                        showNotification(`‚ùå Update error: ${errorMsg}`);
                    }
                }
            });
            
            // Listen for download progress
            window.electronAPI.onUpdateProgress((progress) => {
                console.log(`Download progress: ${progress.percent.toFixed(1)}%`);
            });
        }

        async function checkForUpdates() {
            if (!window.electronAPI) {
                showNotification('This feature is only available in the desktop app.');
                return;
            }
            
            try {
                const result = await window.electronAPI.checkForUpdates();
                // All update status messages (including errors) are handled by onUpdateStatus listener
                // Only log here, don't show duplicate notifications
                if (result && result.success) {
                    console.log('Update check initiated');
                } else {
                    // The onUpdateStatus listener will handle showing the error
                    console.log('Update check returned:', result);
                }
            } catch (e) {
                // Only handle exceptions that occur before update check is initiated
                // (e.g., IPC call failed, not update-related errors)
                console.error('Error initiating update check:', e);
                showNotification(`‚ùå Failed to check for updates: ${e.message || 'Unknown error'}`);
            }
        }

        async function downloadUpdate() {
            if (!window.electronAPI) return;
            
            try {
                const result = await window.electronAPI.downloadUpdate();
                if (!result || !result.success) {
                    alert('Error downloading update: ' + (result?.error || 'Unknown error'));
                }
            } catch (e) {
                console.error('Error downloading update:', e);
                alert('Error downloading update: ' + e.message);
            }
        }

        async function installUpdate() {
            if (!window.electronAPI) return;
            
            try {
                const result = await window.electronAPI.installUpdate();
                if (!result || !result.success) {
                    alert('Error installing update: ' + (result?.error || 'Unknown error'));
                }
            } catch (e) {
                console.error('Error installing update:', e);
                alert('Error installing update: ' + e.message);
            }
        }

        // ============================================
        // SETTINGS MODAL - Sprite Path Management
        // ============================================
        
        let currentSpritePathInfo = null;
        
        async function openSettings() {
            const modal = document.getElementById('settingsModal');
            modal.classList.add('active');
            await loadSpritePathInfo();
            await loadWindowDimensionsInfo();
        }
        
        function closeSettings() {
            const modal = document.getElementById('settingsModal');
            modal.classList.remove('active');
        }
        
        async function loadSpritePathInfo() {
            if (!window.electronAPI) {
                document.getElementById('spritePathDisplay').textContent = 'Not available (Web version)';
                document.getElementById('spritePathInfo').textContent = 'Sprite path settings are only available in the desktop app.';
                return;
            }
            
            try {
                const pathInfo = await window.electronAPI.getSpritePath();
                currentSpritePathInfo = pathInfo;
                
                const display = document.getElementById('spritePathDisplay');
                const info = document.getElementById('spritePathInfo');
                const resetBtn = document.getElementById('resetSpritePathBtn');
                
                display.textContent = pathInfo.effectivePath || 'Not found';
                
                if (pathInfo.isCustom) {
                    info.innerHTML = `‚úÖ Using custom path<br>Default: ${pathInfo.defaultPath}`;
                    resetBtn.style.display = 'block';
                } else {
                    info.innerHTML = `‚úÖ Using default path`;
                    resetBtn.style.display = 'none';
                }
            } catch (error) {
                console.error('Error loading sprite path info:', error);
                document.getElementById('spritePathDisplay').textContent = 'Error loading path';
            }
        }
        
        // ============================================
        // SETTINGS MODAL - Window Dimensions Management
        // ============================================
        
        let currentWindowDimensions = null;
        
        async function loadWindowDimensionsInfo() {
            if (!window.electronAPI) {
                document.getElementById('windowWidth').value = '1920';
                document.getElementById('windowHeight').value = '1080';
                document.getElementById('windowDimensionsInfo').textContent = 'Not available (Web version)';
                document.getElementById('toggleLockBtn').style.display = 'none';
                return;
            }
            
            try {
                const dimensions = await window.electronAPI.getWindowDimensions();
                currentWindowDimensions = dimensions;
                
                document.getElementById('windowWidth').value = dimensions.width || 1920;
                document.getElementById('windowHeight').value = dimensions.height || 1080;
                
                const toggleBtn = document.getElementById('toggleLockBtn');
                if (toggleBtn) {
                    toggleBtn.textContent = dimensions.locked ? 'üîí Locked' : 'üîì Unlocked';
                    toggleBtn.style.background = dimensions.locked ? '#666' : '#444';
                    
                    // Disable inputs when locked
                    document.getElementById('windowWidth').disabled = dimensions.locked;
                    document.getElementById('windowHeight').disabled = dimensions.locked;
                }
                
                const info = document.getElementById('windowDimensionsInfo');
                if (info) {
                    info.textContent = dimensions.locked 
                        ? 'Window is locked - unlock to adjust dimensions'
                        : 'Window is unlocked - you can resize the window directly';
                }
            } catch (error) {
                console.error('Error loading window dimensions:', error);
                document.getElementById('windowDimensionsInfo').textContent = 'Error loading dimensions';
            }
        }
        
        async function toggleWindowLock() {
            if (!window.electronAPI) {
                showNotification('‚ùå Window settings are only available in the desktop app.');
                return;
            }
            
            try {
                const result = await window.electronAPI.toggleWindowLock();
                if (result.locked !== undefined) {
                    await loadWindowDimensionsInfo();
                    showNotification(result.locked ? 'üîí Window locked' : 'üîì Window unlocked');
                }
            } catch (error) {
                console.error('Error toggling window lock:', error);
                showNotification(`‚ùå Error: ${error.message || 'Unknown error'}`);
            }
        }
        
        async function applyWindowDimensions() {
            if (!window.electronAPI) {
                showNotification('‚ùå Window settings are only available in the desktop app.');
                return;
            }
            
            const width = parseInt(document.getElementById('windowWidth').value);
            const height = parseInt(document.getElementById('windowHeight').value);
            
            if (isNaN(width) || isNaN(height) || width < 640 || height < 360) {
                showNotification('‚ùå Please enter valid dimensions (min: 640x360)');
                return;
            }
            
            try {
                const result = await window.electronAPI.setWindowDimensions({ width, height });
                if (result.success) {
                    showNotification(`‚úÖ Window dimensions updated to ${width}x${height}`);
                    await loadWindowDimensionsInfo();
                } else {
                    showNotification(`‚ùå ${result.error || 'Failed to update dimensions'}`);
                }
            } catch (error) {
                console.error('Error setting window dimensions:', error);
                showNotification(`‚ùå Error: ${error.message || 'Unknown error'}`);
            }
        }
        
        async function browseSpritePath() {
            if (!window.electronAPI) {
                showNotification('‚ùå Sprite path settings are only available in the desktop app.');
                return;
            }
            
            try {
                const result = await window.electronAPI.setSpritePath();
                
                if (result.canceled) {
                    return; // User canceled
                }
                
                if (result.success) {
                    showNotification(`‚úÖ Sprite path updated!\n\n${result.path}\n\nPlease restart the server for changes to take effect.`);
                    await loadSpritePathInfo();
                    
                    // Notify user they may need to restart
                    if (confirm('Sprite path updated! The server needs to be restarted for changes to take effect.\n\nWould you like to restart the server now?')) {
                        // Stop and start server
                        if (window.electronAPI) {
                            await window.electronAPI.stopServer();
                            setTimeout(async () => {
                                await window.electronAPI.startServer();
                                showNotification('‚úÖ Server restarted with new sprite path!');
                            }, 1000);
                        }
                    }
                } else {
                    showNotification(`‚ùå ${result.error || 'Failed to set sprite path'}`);
                }
            } catch (error) {
                console.error('Error setting sprite path:', error);
                showNotification(`‚ùå Error: ${error.message || 'Unknown error'}`);
            }
        }
        
        async function resetSpritePath() {
            if (!window.electronAPI) {
                showNotification('‚ùå Sprite path settings are only available in the desktop app.');
                return;
            }
            
            if (!confirm('Reset sprite path to default?\n\nThis will use the automatically detected path.')) {
                return;
            }
            
            try {
                const result = await window.electronAPI.resetSpritePath();
                
                if (result.success) {
                    showNotification(`‚úÖ Sprite path reset to default!\n\n${result.path}\n\nPlease restart the server for changes to take effect.`);
                    await loadSpritePathInfo();
                    
                    // Notify user they may need to restart
                    if (confirm('Sprite path reset! The server needs to be restarted for changes to take effect.\n\nWould you like to restart the server now?')) {
                        // Stop and start server
                        if (window.electronAPI) {
                            await window.electronAPI.stopServer();
                            setTimeout(async () => {
                                await window.electronAPI.startServer();
                                showNotification('‚úÖ Server restarted with default sprite path!');
                            }, 1000);
                        }
                    }
                } else {
                    showNotification(`‚ùå ${result.error || 'Failed to reset sprite path'}`);
                }
            } catch (error) {
                console.error('Error resetting sprite path:', error);
                showNotification(`‚ùå Error: ${error.message || 'Unknown error'}`);
            }
        }
        
        // Listen for sprite path changes from Electron
        if (window.electronAPI) {
            window.electronAPI.onSpritePathChanged((data) => {
                console.log('Sprite path changed:', data);
                if (document.getElementById('settingsModal').classList.contains('active')) {
                    loadSpritePathInfo();
                }
            });
        }
        
        async function shutdownWidget() {
            if (!confirm('üõë Shutdown widget and all servers? This will stop the widget, close all connections, and shut down the server.')) {
                return;
            }
            
            try {
                // Send shutdown message to widget
                const widgetIframe = document.getElementById('widgetPreview');
                if (widgetIframe && widgetIframe.contentWindow) {
                    widgetIframe.contentWindow.postMessage({ type: 'shutdown' }, '*');
                }
                
                // If in Electron, also shutdown the app
                if (window.electronAPI) {
                    try {
                        await window.electronAPI.shutdownApp();
                    } catch (e) {
                        console.warn('Could not shutdown Electron app:', e);
                    }
                }
                
                // Stop local server if running (for localhost version)
                try {
                    const response = await fetch('http://localhost:3000/api/shutdown', {
                        method: 'POST'
                    });
                    if (response.ok) {
                        console.log('‚úÖ Server shutdown requested');
                    }
                } catch (e) {
                    console.warn('Could not shutdown server:', e);
                }
                
                // Clear widget preview
                if (widgetIframe) {
                    widgetIframe.src = 'about:blank';
                }
                
                alert('‚úÖ Widget and servers shutdown complete');
            } catch (error) {
                console.error('Error shutting down:', error);
                alert('‚ö†Ô∏è Some components may not have shutdown properly. Check console for details.');
            }
        }

        // Member management functions
        let memberManagementInterval = null;
        let memberMuteStates = {}; // Track muted users
        let memberStillStates = {}; // Track users who can't move

        // Load and display members (same as members window)
        let allMembers = [];
        let activeUsers = [];
        let memberVirtualList = null; // VirtualList instance for performance
        const DASH_ACTIVE_WINDOW_MS = 10 * 60 * 1000; // "recently active in chat" window
        let _dashboardMembersStatusInterval = null;
        
        async function loadDashboardMembers() {
            const membersList = document.getElementById('membersList');
            if (!membersList) return;
            
            if (!window.electronAPI) {
                membersList.innerHTML = '<div class="empty-state">Not available (Web version)</div>';
                return;
            }
            
            try {
                const [active, widgetDisplay, potential] = await Promise.all([
                    window.electronAPI.getActiveUsers(),
                    (window.electronAPI.getWidgetDisplayUsers && window.electronAPI.getWidgetDisplayUsers()) || Promise.resolve([]),
                    window.electronAPI.getPotentialMembers()
                ]);
                
                activeUsers = active;
                const userMap = new Map();
                const usernameToKey = new Map(); // usernameLower -> canonical key (prefer userId when known)
                const normName = (v) => (v ? String(v).toLowerCase() : '');
                const normId = (v) => (v == null ? '' : String(v));
                const keyFor = (userId, username) => {
                    const id = normId(userId);
                    const name = normName(username);
                    if (id) {
                        if (name) usernameToKey.set(name, id);
                        return id;
                    }
                    if (name) return usernameToKey.get(name) || name;
                    return '';
                };
                const upsert = (rec) => {
                    const key = keyFor(rec.userId, rec.username);
                    if (!key) return;
                    const existing = userMap.get(key);
                    if (existing) {
                        // Merge fields (prefer "joined", preserve username)
                        existing.joined = !!existing.joined || !!rec.joined;
                        if (rec.username) existing.username = existing.username || rec.username;
                        existing.userId = key; // keep canonical key
                        if (rec.color) existing.color = rec.color;
                        if (rec.twitchColor) existing.twitchColor = rec.twitchColor;
                        if (rec.lastMessage) existing.lastMessage = Math.max(existing.lastMessage || 0, rec.lastMessage);
                        // Prefer stronger source ordering
                        const rank = { main: 3, widget: 2, potential: 1, test: 0 };
                        if ((rank[rec.source] || 0) > (rank[existing.source] || 0)) existing.source = rec.source;
                    } else {
                        userMap.set(key, { ...rec, userId: key });
                    }
                };

                // Presence sets for restored calculation (a user is "restored" if in widget but not in main and not in chatters)
                const activeSet = new Set();
                const potentialSet = new Set();
                const widgetSet = new Set();
                const addPresence = (set, userId, username) => {
                    const id = normId(userId);
                    const name = normName(username);
                    if (id) set.add(id);
                    if (name) set.add(name);
                };
                active.forEach(u => addPresence(activeSet, u.userId, u.username));
                potential.forEach(p => addPresence(potentialSet, p.userId, p.username));
                (widgetDisplay || []).forEach(w => addPresence(widgetSet, w.userId, w.username));

                // 1) Main's activeUsers
                active.forEach(u => upsert({ username: u.username, userId: u.userId, joined: true, restored: false, source: 'main', twitchColor: u.twitchColor || null, color: u.color || null }));
                // 2) Widget's actual display users (includes restored from localStorage)
                (widgetDisplay || []).forEach(u => upsert({ username: u.username, userId: u.userId, joined: true, restored: true, source: 'widget', twitchColor: u.twitchColor || null, color: u.color || null }));
                // 3) Potential (chatters)
                potential.forEach(p => upsert({ username: p.username, userId: p.userId, joined: false, restored: false, source: 'potential', twitchColor: p.color || null, lastMessage: p.lastMessage || null }));
                
                const testUsers = ['TestUser1', 'TestUser2', 'TestUser3'];
                testUsers.forEach(testUser => {
                    upsert({ username: testUser, userId: testUser.toLowerCase(), joined: false, restored: false, source: 'test' });
                });

                // ========== FIX FOR RESTORED USERS DUPLICATES ==========
                // Clean up userMap to prevent duplicates when users have both userId and username entries
                const cleanedUserMap = new Map();
                const usernameToUserId = new Map();

                // First pass: build username -> userId mapping
                for (const [key, user] of userMap.entries()) {
                    const id = normId(user.userId);
                    const name = normName(user.username);
                    if (id && name) {
                        usernameToUserId.set(name, id);
                    }
                }

                // Second pass: merge entries and prevent duplicates
                for (const [key, user] of userMap.entries()) {
                    const id = normId(user.userId);
                    const name = normName(user.username);

                    // If this is a username-only entry and we have a userId for it, merge it
                    if (!id && name && usernameToUserId.has(name)) {
                        const realId = usernameToUserId.get(name);
                        const userIdEntry = userMap.get(realId);
                        if (userIdEntry) {
                            // Merge properties from username-only entry into userId entry
                            userIdEntry.username = userIdEntry.username || user.username;
                            userIdEntry.joined = userIdEntry.joined || user.joined;
                            userIdEntry.color = userIdEntry.color || user.color;
                            userIdEntry.twitchColor = userIdEntry.twitchColor || user.twitchColor;
                            if (user.lastMessage) {
                                userIdEntry.lastMessage = Math.max(userIdEntry.lastMessage || 0, user.lastMessage);
                            }
                            // Preserve the stronger source
                            const rank = { main: 3, widget: 2, potential: 1, test: 0 };
                            if ((rank[user.source] || 0) > (rank[userIdEntry.source] || 0)) {
                                userIdEntry.source = user.source;
                            }
                        }
                        continue; // Skip adding this username-only entry (it's been merged)
                    }

                    // Add to cleaned map
                    cleanedUserMap.set(key, user);
                }

                console.log('[Deduplication] Original entries:', userMap.size, 'Cleaned entries:', cleanedUserMap.size);
                // ========== END FIX ==========

                // Finalize restored flag after merging (avoid duplicate rows from userId vs username keys)
                allMembers = Array.from(cleanedUserMap.values()).map(m => {
                    const id = normId(m.userId);
                    const name = normName(m.username);
                    const inWidget = widgetSet.has(id) || (name && widgetSet.has(name));
                    const inActive = activeSet.has(id) || (name && activeSet.has(name));
                    const inPotential = potentialSet.has(id) || (name && potentialSet.has(name));
                    return {
                        ...m,
                        inCampfire: !!(inWidget || inActive),
                        inChat: !!inPotential,
                        restored: !!(inWidget && !inActive && !inPotential)
                    };
                });
                renderDashboardMembers();
                if (!_dashboardMembersStatusInterval) {
                    _dashboardMembersStatusInterval = setInterval(() => {
                        try { renderDashboardMembers(); } catch (e) { /* ignore */ }
                    }, 30 * 1000);
                }
            } catch (error) {
                console.error('Error loading members:', error);
                membersList.innerHTML = '<div class="empty-state">Error loading members</div>';
            }
        }
        
        function renderDashboardMembers() {
            const container = document.getElementById('membersList');
            if (!container) return;

            if (allMembers.length === 0) {
                container.innerHTML = '<div class="empty-state">No members found</div>';
                if (memberVirtualList) {
                    memberVirtualList.destroy();
                    memberVirtualList = null;
                }
                return;
            }

            // Initialize VirtualList if not already created
            if (!memberVirtualList) {
                // Clear container first
                container.innerHTML = '';

                memberVirtualList = new VirtualList({
                    container: container,
                    itemHeight: 60, // Approximate height of member-item
                    renderItem: (member, index) => createMemberElement(member, index),
                    bufferSize: 3
                });
            }

            // Update items
            memberVirtualList.setItems(allMembers);
        }

        // Helper function to create member DOM element
        function createMemberElement(member, index) {
            const now = Date.now();
            const hashColor = (username) => {
                const s = String(username || '');
                let hash = 0;
                for (let i = 0; i < s.length; i++) hash = s.charCodeAt(i) + ((hash << 5) - hash);
                const hue = Math.abs(hash % 360);
                return `hsl(${hue}, 70%, 60%)`;
            };

            const isTestUser = member.username && member.username.startsWith('TestUser');
            const memberId = 'member-' + String(member.userId || member.username || '').replace(/[^a-zA-Z0-9_-]/g, '_');
            const uid = escapeJsQuoted(member.userId || '');
            const uname = escapeJsQuoted(member.username || '');
            const unameHtml = escapeHtml(member.username || '');
            const inChat = !!member.inChat;
            const lastMessage = member.lastMessage || 0;
            const recentlyActive = !!(lastMessage && (now - lastMessage) <= DASH_ACTIVE_WINDOW_MS);
            const inCampfire = !!(member.inCampfire || member.joined);
            const status = inCampfire ? (inChat ? 'joined' : 'sleepy') : (recentlyActive ? 'active' : 'not-joined');
            const twitchColor = member.twitchColor || null;
            const joinedColor = twitchColor || hashColor(member.username);
            const nameColor = (status === 'joined' || status === 'sleepy') ? joinedColor : (status === 'active' ? '#fff' : '#777');
            const zzz = (status === 'sleepy') ? '<span class="member-zzz" title="In campfire, but not in chat (sleepy/disconnected?)">zzz</span>' : '';
            const statusText =
                (status === 'joined') ? 'Joined' :
                (status === 'sleepy') ? 'Sleeping' :
                (status === 'active') ? 'Active in chat' :
                'Not joined';

            const div = document.createElement('div');
            div.id = memberId;
            div.className = 'member-item';
            div.style.cssText = 'background: #1f1f1f; border: 1px solid #3a3a3a; border-radius: 6px; padding: 8px 12px; display: flex; justify-content: space-between; align-items: center; min-height: 40px;';

            if (isTestUser) {
                div.innerHTML = `
                    <div class="member-info" style="flex: 1; display: flex; align-items: center; gap: 10px;">
                        <span class="member-name" style="font-family: 'UsernameFont', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; font-weight: bold; font-size: 14px; color: #fff;">${unameHtml}</span>
                        <span class="member-status" style="font-size: 11px; color: #888;">${member.joined ? 'Joined' : 'Not joined'}</span>
                    </div>
                    <div class="member-actions" style="display: flex; gap: 8px; align-items: center;">
                        <button class="btn" onclick="dashboardOpenMemberEdit('${uid}', '${uname}')" style="padding: 6px 12px; background: #444; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">Edit</button>
                        <div class="toggle-switch ${member.joined ? 'active' : ''}" onclick="dashboardToggleTestUser('${uid}', '${uname}')" style="cursor: pointer; width: 50px; height: 24px; background: ${member.joined ? '#4caf50' : '#444'}; border-radius: 12px; position: relative; transition: background 0.3s; box-shadow: inset 0 1px 3px rgba(0,0,0,0.3);">
                            <div style="position: absolute; top: 2px; left: ${member.joined ? '28px' : '2px'}; width: 20px; height: 20px; background: white; border-radius: 50%; transition: left 0.3s ease; box-shadow: 0 2px 4px rgba(0,0,0,0.2);"></div>
                        </div>
                    </div>
                `;
            } else {
                const restoredIcon = member.restored ? '<span title="Restored from previous session; may have disconnected" style="margin-left:4px;opacity:0.85;">üìå</span>' : '';
                div.innerHTML = `
                    <div class="member-info" style="flex: 1; display: flex; align-items: center; gap: 10px;">
                        <span class="member-name status-${status}" style="font-family: 'UsernameFont', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; font-weight: bold; font-size: 14px; color: ${nameColor};">${unameHtml}</span>${zzz}${restoredIcon}
                        <span class="member-status" style="font-size: 11px; color: #888;">${statusText}</span>
                    </div>
                    <div class="member-actions" style="display: flex; gap: 8px; align-items: center;">
                        ${member.joined
                            ? `<button class="btn danger" onclick="dashboardLeaveMember('${uid}', '${uname}')" style="padding: 6px 12px; background: #ff4444; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">Leave</button>`
                            : `<button class="btn" onclick="dashboardJoinMember('${uid}', '${uname}')" style="padding: 6px 12px; background: #4caf50; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">Join</button>`
                        }
                        <button class="btn" onclick="dashboardOpenMemberEdit('${uid}', '${uname}')" style="padding: 6px 12px; background: #444; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">Edit</button>
                    </div>
                `;
            }

            return div;
        }

        // Helper functions (if not already defined)
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function escapeJsQuoted(text) {
            return String(text || '').replace(/'/g, "\\'").replace(/"/g, '\\"');
        }
        
        // Dashboard member control functions
        async function dashboardToggleTestUser(userId, username) {
            if (!window.electronAPI) return;
            
            try {
                const widgetUsers = await window.electronAPI.getWidgetUsers();
                const isInWidget = widgetUsers.find(w => {
                    const wUserId = (w.userId || '').toLowerCase();
                    const wUsername = (w.username || '').toLowerCase();
                    const checkUserId = (userId || '').toLowerCase();
                    const checkUsername = (username || '').toLowerCase();
                    return wUserId === checkUserId || wUsername === checkUsername;
                });
                
                if (isInWidget) {
                    // Remove user
                    const result = await window.electronAPI.removeTestUserFromWidget(userId, username);
                    if (!result || !result.success) {
                        console.error('Failed to remove test user:', result);
                        alert('Failed to remove test user: ' + (result?.error || 'Unknown error'));
                        return;
                    }
                    console.log('Test user removed:', username);
                } else {
                    // Add user
                    const result = await window.electronAPI.addTestUserToWidget(userId, username);
                    if (!result || !result.success) {
                        console.error('Failed to add test user:', result);
                        alert('Failed to add test user: ' + (result?.error || 'Unknown error'));
                        return;
                    }
                    console.log('Test user added:', username);
                }
                
                // Refresh members list to update toggle states
                if (typeof loadDashboardMembers === 'function') {
                    await loadDashboardMembers();
                }
                
                // Sync preview iframe
                const iframe = document.getElementById('fullWidgetPreview');
                if (iframe && iframe.contentWindow) {
                    setTimeout(async () => {
                        const updatedUsers = await window.electronAPI.getWidgetUsers();
                        iframe.contentWindow.postMessage({
                            type: 'syncFullState',
                            users: updatedUsers
                        }, '*');
                    }, 200);
                }
                
                // Refresh members list after toggle
                await loadDashboardMembers();
            } catch (e) {
                console.error('Error toggling test user:', e);
                alert('Error toggling test user: ' + e.message);
            }
        }
        
        async function dashboardJoinMember(userId, username) {
            if (!window.electronAPI) return;
            await window.electronAPI.joinMember(userId, username);
            // Refresh members list
            await loadDashboardMembers();
        }
        
        async function dashboardLeaveMember(userId, username) {
            if (!window.electronAPI) return;
            if (!confirm('Remove this member from the campfire?')) return;
            await window.electronAPI.kickMember(userId);
            // Refresh members list
            await loadDashboardMembers();
        }
        
        async function dashboardOpenMemberEdit(userId, username) {
            if (!window.electronAPI) return;
            // Open Viewer Dashboard (sprite settings) for this member
            if (window.electronAPI.openMemberDashboard) {
                await window.electronAPI.openMemberDashboard(userId, username);
            } else {
                alert(`Edit settings for ${username} - Viewer Dashboard not available`);
            }
        }

        function toggleMute(userId, username) {
            const key = userId || username;
            memberMuteStates[key] = !memberMuteStates[key];
            
            // Send mute state to widget
            const iframe = document.getElementById('fullWidgetPreview');
            if (iframe && iframe.contentWindow) {
                iframe.contentWindow.postMessage({
                    type: 'memberMute',
                    userId: userId,
                    username: username,
                    muted: memberMuteStates[key]
                }, '*');
            }
            
            // Save to localStorage
            localStorage.setItem('memberMuteStates', JSON.stringify(memberMuteStates));
            
            loadDashboardMembers();
        }

        function toggleStill(userId, username) {
            const key = userId || username;
            memberStillStates[key] = !memberStillStates[key];
            
            // Send still state to widget
            const iframe = document.getElementById('fullWidgetPreview');
            if (iframe && iframe.contentWindow) {
                iframe.contentWindow.postMessage({
                    type: 'memberStill',
                    userId: userId,
                    username: username,
                    still: memberStillStates[key]
                }, '*');
            }
            
            // Save to localStorage
            localStorage.setItem('memberStillStates', JSON.stringify(memberStillStates));
            
            loadDashboardMembers();
        }

        function kickMember(userId, username) {
            if (!confirm(`Are you sure you want to kick ${username} from the campfire?`)) {
                return;
            }

            // Remove from widget
            const iframe = document.getElementById('fullWidgetPreview');
            if (iframe && iframe.contentWindow) {
                iframe.contentWindow.postMessage({
                    type: 'kickMember',
                    userId: userId,
                    username: username
                }, '*');
            }

            // Remove from localStorage
            try {
                const savedUsers = localStorage.getItem('campfireUsers');
                const users = savedUsers ? JSON.parse(savedUsers) : [];
                const filtered = users.filter(u => (u.userId && u.userId !== userId) && (u.username !== username));
                localStorage.setItem('campfireUsers', JSON.stringify(filtered));
            } catch (e) {
                console.error('Error removing member:', e);
            }

            // Remove from mute/still states
            const key = userId || username;
            delete memberMuteStates[key];
            delete memberStillStates[key];
            localStorage.setItem('memberMuteStates', JSON.stringify(memberMuteStates));
            localStorage.setItem('memberStillStates', JSON.stringify(memberStillStates));

            loadDashboardMembers();
        }

        // Load mute/still states on init
        function loadMemberStates() {
            try {
                const savedMutes = localStorage.getItem('memberMuteStates');
                if (savedMutes) memberMuteStates = JSON.parse(savedMutes);
                
                const savedStills = localStorage.getItem('memberStillStates');
                if (savedStills) memberStillStates = JSON.parse(savedStills);
            } catch (e) {
                console.error('Error loading member states:', e);
            }
        }

        // Update switchTab to refresh members list
        const originalSwitchTab = switchTab;
        switchTab = function(tabName, element) {
            originalSwitchTab(tabName, element);
            if (tabName === 'members') {
                loadDashboardMembers();
                // Refresh every 2 seconds when on members tab
                if (memberManagementInterval) clearInterval(memberManagementInterval);
                memberManagementInterval = setInterval(loadDashboardMembers, 2000);
            } else if (tabName === 'botmessages') {
                if (typeof loadBotMessages === 'function') loadBotMessages();
            } else {
                if (memberManagementInterval) {
                    clearInterval(memberManagementInterval);
                    memberManagementInterval = null;
                }
            }
        };

        // Initialize member states on load
        loadMemberStates();

        // Show fade-in/fade-out notification
        function showNotification(message) {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.classList.add('show');
            
            // Fade out after 1 second
            setTimeout(() => {
                notification.classList.remove('show');
            }, 1000);
        }

        // Show confirmation popup
        let confirmationCallback = null;
        function showConfirmation(title, message, callback) {
            confirmationCallback = callback;
            document.getElementById('confirmationTitle').textContent = title;
            document.getElementById('confirmationMessage').textContent = message;
            document.getElementById('confirmationPopup').classList.add('show');
        }

        // Close confirmation popup
        function closeConfirmation(confirmed) {
            document.getElementById('confirmationPopup').classList.remove('show');
            if (confirmationCallback) {
                if (confirmed) {
                    confirmationCallback();
                }
                confirmationCallback = null;
            }
        }

        // ========== BOT MESSAGES FUNCTIONALITY ==========
        const botMessages = [
            { id: 'welcome', name: 'Welcome Message', enabled: true, text: 'Welcome to the campfire! üî•' },
            { id: 'join', name: 'User Joined', enabled: true, text: '{user} joined the campfire!' },
            { id: 'leave', name: 'User Left', enabled: false, text: '{user} left the campfire.' },
            { id: 'reminder', name: 'Periodic Reminder', enabled: false, text: 'Join the campfire with !join' }
        ];

        function loadBotMessages() {
            const container = document.getElementById('botMessagesList');
            if (!container) return;

            container.innerHTML = botMessages.map(msg => `
                <div class="bot-message-item" style="background: #1f1f1f; padding: 15px; border-radius: 6px; border: 1px solid #3a3a3a;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <strong style="color: #fff;">${msg.name}</strong>
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                            <input type="checkbox" ${msg.enabled ? 'checked' : ''}
                                   onchange="toggleBotMessage('${msg.id}', this.checked)"
                                   style="width: 16px; height: 16px; cursor: pointer;">
                            <span style="font-size: 12px; color: #888;">Enabled</span>
                        </label>
                    </div>
                    <div style="display: flex; gap: 10px;">
                        <input type="text" value="${msg.text}"
                               id="botmsg-${msg.id}"
                               style="flex: 1; padding: 8px; background: #2a2a2a; border: 1px solid #444; border-radius: 4px; color: #fff; font-size: 13px;">
                        <button class="button-secondary" onclick="saveBotMessage('${msg.id}')" style="padding: 8px 16px;">
                            üíæ Save
                        </button>
                    </div>
                </div>
            `).join('');
        }

        function toggleBotMessage(id, enabled) {
            const msg = botMessages.find(m => m.id === id);
            if (msg) {
                msg.enabled = enabled;
                saveBotMessagesConfig();
            }
        }

        function saveBotMessage(id) {
            const input = document.getElementById(`botmsg-${id}`);
            const msg = botMessages.find(m => m.id === id);
            if (msg && input) {
                msg.text = input.value;
                saveBotMessagesConfig();
                showNotification('Bot message saved!');
            }
        }

        async function saveBotMessagesConfig() {
            if (window.electronAPI && window.electronAPI.saveBotMessages) {
                await window.electronAPI.saveBotMessages(botMessages);
            } else {
                localStorage.setItem('botMessages', JSON.stringify(botMessages));
            }
        }
        // ========== END BOT MESSAGES FUNCTIONALITY ==========
    </script>

    <!-- Notification popup -->
    <div id="notification" class="notification"></div>

    <!-- Confirmation popup -->
    <div id="confirmationPopup" class="confirmation-popup">
        <h3 id="confirmationTitle">Confirm Action</h3>
        <p id="confirmationMessage"></p>
        <div class="confirmation-buttons">
            <button class="cancel-btn" onclick="closeConfirmation(false)">Cancel</button>
            <button class="confirm-btn" onclick="closeConfirmation(true)">Confirm</button>
        </div>
    </div>
</body>
</html>
