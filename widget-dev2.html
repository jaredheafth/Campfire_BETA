<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Campfire Widget - Visual Display</title>
    <style>
        /* Custom font for usernames and chat bubbles */
        @font-face {
            font-family: 'UsernameFont';
            src: url('fonts/w95fa.woff2') format('woff2'),
                 url('fonts/w95fa.woff') format('woff'),
                 url('fonts/W95FA.otf') format('opentype'),
                 url('fonts/username-font.woff2') format('woff2'),
                 url('fonts/username-font.woff') format('woff'),
                 url('fonts/username-font.ttf') format('truetype'),
                 url('fonts/username-font.otf') format('opentype');
            font-weight: normal;
            font-style: normal;
            font-display: swap; /* Show fallback font immediately, swap when custom font loads */
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background: transparent !important; /* Ensure transparent for OBS */
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
        }
        
        html {
            background: transparent !important; /* Ensure HTML is also transparent */
        }

        .widget-container {
            width: 100%;
            height: 100%;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .campfire-area {
            position: relative;
            width: 300px;
            height: 300px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .campfire-graphic {
            width: 800px; /* Much larger to allow glow to fade naturally */
            height: 800px; /* Much larger to allow glow to fade naturally */
            object-fit: contain;
            z-index: 10;
            position: relative;
            overflow: visible; /* Allow glow to extend beyond container */
            background: transparent; /* No background */
            border: none; /* No border */
            box-shadow: none; /* No box shadow on container */
            /* Center the container content */
            display: flex;
            align-items: center;
            justify-content: center;
            /* Streamer-adjustable campfire vertical offset */
            transform: translateY(var(--campfire-y-offset, 0px));
            will-change: transform;
        }

        /* 3D Layering - Front users (bottom of circle) */
        .user-shape.front-layer {
            z-index: 15;
        }

        /* 3D Layering - Back users (top of circle) */
        .user-shape.back-layer {
            z-index: 5;
        }

        .campfire-graphic img,
        .campfire-graphic video {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        .circle-container {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            /* Remove transform from container - we'll apply perspective to individual elements */
        }

        .user-shape {
            position: absolute;
            width: 40px; /* Default, will be overridden by spriteSize setting */
            height: 40px; /* Default, will be overridden by spriteSize setting */
            transform-origin: center;
            transition: left 0.3s ease, top 0.3s ease, z-index 0s; /* Only transition position, not transforms */
            z-index: 5;
            outline: none; /* Remove any outline */
        }
        
        /* Disable transitions during exit animation for smooth animation */
        .user-shape.leaving {
            transition: none !important;
        }
        
        .user-shape .shape {
            transform-origin: center;
        }
        
        .user-shape .shape.flipped {
            transform: scaleX(-1);
        }

        .user-shape .shape {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: 2px solid transparent; /* Start transparent - only show if fallback circle is needed */
            /* No box-shadow - removed to eliminate bubble effect around sprites */
            box-shadow: none;
            outline: none !important; /* Remove outline that might create unwanted circles */
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            color: white;
            font-weight: bold;
            overflow: visible; /* Allow sprites to extend beyond if needed */
        }
        
        /* Ensure sprites (any with background-image) have no shadows, borders, or circular clipping */
        .user-shape .shape[style*="background-image"] {
            box-shadow: none !important;
            filter: drop-shadow(none) !important;
            border: none !important;
            border-radius: 0 !important;
            outline: none !important; /* Remove outline that might create unwanted circles */
            overflow: visible !important; /* Prevent clipping of sprite edges */
            background-size: contain !important; /* Ensure full sprite is visible */
        }

        .user-shape .username {
            position: absolute;
            top: -25px;
            left: 50%;
            transform: translateX(-50%);
            white-space: nowrap;
            /* Removed background box - using text stroke instead */
            padding: 2px 4px;
            font-size: 14px; /* Increased from 12px for better readability */
            font-weight: 600;
            font-family: 'UsernameFont', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            pointer-events: none;
            z-index: 100; /* Always above sprites - use high z-index so usernames layer correctly relative to each other */
            /* Outside stroke effect using text-shadow (no -webkit-text-stroke to avoid covering font) */
            /* Multiple shadows positioned around text create an outside-only outline */
            text-shadow: 
                -1px -1px 0 #000,
                1px -1px 0 #000,
                -1px 1px 0 #000,
                1px 1px 0 #000,
                0 -1px 0 #000,
                0 1px 0 #000,
                -1px 0 0 #000,
                1px 0 0 #000,
                0 0 2px #000; /* Additional blur for smoother outline */
            transition: opacity 0.3s ease, color 0.3s ease;
        }

        .user-shape .chat-message {
            position: absolute;
            top: -25px;
            left: 50%;
            transform: translateX(-50%);
            background: #0d0d0d;
            color: #fff;
            padding: 4px 8px;
            font-family: 'UsernameFont', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            border: 2px solid #fff;
            border-radius: 0;
            font-size: 11px;
            font-weight: 500;
            pointer-events: none;
            z-index: 25;
            min-width: 0;
            max-width: 150px;
            width: max-content;
            white-space: normal;
            word-break: normal;
            word-wrap: break-word;
            text-align: center;
            opacity: 0;
            transition: opacity 0.25s ease;
            box-shadow: none;
            /* Pixel/notched corners (Gameboy/Pok√©mon-ish) without changing colors */
            clip-path: polygon(
                0 4px, 2px 4px, 2px 2px, 4px 2px, 4px 0,
                calc(100% - 4px) 0,
                calc(100% - 4px) 2px, calc(100% - 2px) 2px, calc(100% - 2px) 4px, 100% 4px,
                100% calc(100% - 4px),
                calc(100% - 2px) calc(100% - 4px), calc(100% - 2px) calc(100% - 2px), calc(100% - 4px) calc(100% - 2px), calc(100% - 4px) 100%,
                4px 100%,
                4px calc(100% - 2px), 2px calc(100% - 2px), 2px calc(100% - 4px), 0 calc(100% - 4px)
            );
        }

        .user-shape .chat-message .chat-emote {
            height: 2.2em; /* 2x emote size */
            width: auto;
            vertical-align: middle;
        }

        .user-shape .chat-message.show {
            opacity: 1;
        }

        .user-shape .chat-message.fade-out {
            opacity: 0;
        }

        .user-shape.entering {
            animation: popIn 0.5s ease-out forwards;
        }

        .user-shape.leaving {
            animation: liftFadeOut 0.6s ease-in forwards;
            /* Override any inline transforms during exit animation */
            transform-origin: center bottom;
            /* Ensure animation can override positioning */
            will-change: transform, opacity;
        }
        
        /* Apply preserved scale to the shape during exit */
        .user-shape.leaving .shape {
            transform: scaleX(var(--exit-scaleX, 1)) scaleY(var(--exit-scaleY, 1)) !important;
        }

        .user-shape.idle {
            animation: floatIdle 3s ease-in-out infinite;
        }

        .user-shape.moving {
            animation: bounceWalk 0.6s ease-in-out infinite;
        }

        @keyframes popIn {
            0% {
                transform: scale(0) rotateY(0deg) translateY(0);
                opacity: 0;
            }
            50% {
                transform: scale(1.1) rotateY(180deg) translateY(0);
            }
            100% {
                transform: scale(1) rotateY(360deg) translateY(0);
                opacity: 1;
            }
        }

        @keyframes floatIdle {
            0%, 100% {
                transform: translateY(0px) scale(1);
            }
            50% {
                transform: translateY(-3px) scale(1); /* More subtle float - reduced from -8px */
            }
        }

        @keyframes bounceWalk {
            0%, 100% {
                transform: translateY(0px) scaleY(1);
            }
            25% {
                transform: translateY(-5px) scaleY(0.95);
            }
            50% {
                transform: translateY(-10px) scaleY(0.9);
            }
            75% {
                transform: translateY(-5px) scaleY(0.95);
            }
        }

        @keyframes liftFadeOut {
            0% {
                transform: translateY(0) scale(1);
                opacity: 1;
            }
            100% {
                transform: translateY(var(--lift-distance, -40px)) scale(1);
                opacity: 0;
            }
        }

        /* Debug circle visualization (hidden by default) */
        .debug-circle {
            position: absolute;
            border: none; /* Removed dashed border */
            border-radius: 50%;
            pointer-events: none;
            display: none; /* Hide debug circle */
        }

        /* Desktop App Menu Bar */
        .desktop-menu-bar {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: none; /* Hidden by default, shown only in desktop app */
            z-index: 999999 !important; /* Very high z-index to ensure it's on top */
            flex-direction: row;
            align-items: center;
            gap: 8px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 13px;
            pointer-events: auto; /* Ensure it can be clicked */
            /* Dragging is enabled when the window is frameless (Title Bar disabled). */
            -webkit-app-region: no-drag;
            transition: transform 0.3s ease-out, opacity 0.3s ease-out;
            opacity: 1;
            /* Give the whole bar a visible base so it doesn't vanish on transparent windows */
            padding: 6px;
            background: rgba(18, 18, 18, 0.92);
            border: 1px solid rgba(255, 255, 255, 0.14);
            border-radius: 10px;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.55);
        }

        body.frameless .desktop-menu-bar {
            -webkit-app-region: drag;
        }

        .desktop-menu-bar.desktop-app {
            display: flex !important; /* Force display */
        }

        .desktop-menu-bar.hidden {
            transform: translateX(-50%) translateY(-60px);
            opacity: 0;
            pointer-events: none;
        }

        .menu-button {
            padding: 8px 14px;
            min-height: 32px;
            background: rgba(28, 28, 28, 0.95);
            backdrop-filter: none;
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 6px;
            color: #fff;
            cursor: pointer;
            -webkit-app-region: no-drag;
            transition: all 0.2s;
            font-size: 12px;
            white-space: nowrap;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .menu-button:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .menu-button:active {
            background: rgba(255, 255, 255, 0.15);
        }

        .menu-button.primary {
            background: rgba(255, 107, 53, 0.3);
            border-color: rgba(255, 107, 53, 0.5);
        }

        .menu-button.primary:hover {
            background: rgba(255, 107, 53, 0.5);
            border-color: rgba(255, 107, 53, 0.7);
        }

        .menu-button.danger {
            background: rgba(255, 59, 48, 0.3);
            border-color: rgba(255, 59, 48, 0.5);
        }

        .menu-button.danger:hover {
            background: rgba(255, 59, 48, 0.5);
            border-color: rgba(255, 59, 48, 0.7);
        }
        
        .menu-button-square {
            width: 32px;
            height: 32px;
            padding: 0;
            background: rgba(28, 28, 28, 0.95);
            backdrop-filter: none;
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 6px;
            color: #fff;
            cursor: pointer;
            -webkit-app-region: no-drag;
            transition: all 0.2s;
            font-size: 18px;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-weight: 600;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .menu-button-square:hover {
            border-color: rgba(255, 255, 255, 0.3);
            transform: translateY(-1px);
        }
        
        .menu-button-square:active {
            transform: translateY(0);
        }
        
        .menu-button-square.success {
            background: rgba(76, 175, 80, 0.3);
            border-color: rgba(76, 175, 80, 0.5);
        }
        
        .menu-button-square.success:hover {
            background: rgba(76, 175, 80, 0.5);
            border-color: rgba(76, 175, 80, 0.7);
        }
        
        .menu-button-square.danger {
            background: rgba(244, 67, 54, 0.3);
            border-color: rgba(244, 67, 54, 0.5);
        }
        
        .menu-button-square.danger:hover {
            background: rgba(244, 67, 54, 0.5);
            border-color: rgba(244, 67, 54, 0.7);
        }

        .menu-spacer {
            flex: 1;
        }

        .menu-status {
            padding: 6px 12px;
            min-height: 32px;
            font-size: 11px;
            color: rgba(255, 255, 255, 0.6);
            display: flex;
            align-items: center;
            gap: 6px;
            background: rgba(28, 28, 28, 0.95);
            backdrop-filter: none;
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            -webkit-app-region: no-drag;
        }

        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #ff3b30;
        }

        .status-indicator.connected {
            background: #34c759;
        }
        
        /* ============================================
           INTEGRATED DASHBOARD OVERLAY
           ============================================ */
        .dashboard-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            /* Keep the overlay clickable for close-on-backdrop, but don't darken the entire scene */
            background: transparent;
            backdrop-filter: none;
            z-index: 50000;
            display: none;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .dashboard-overlay.active {
            display: flex;
            opacity: 1;
        }
        
        .dashboard-panel {
            background: #1f1f1f;
            border: 1px solid #3a3a3a;
            border-radius: 12px;
            width: 600px;
            height: 500px;
            display: flex;
            flex-direction: column;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.9);
            overflow: hidden;
        }
        
        .dashboard-header {
            padding: 15px 20px;
            border-bottom: 1px solid #3a3a3a;
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: #1a1a1a;
            flex-shrink: 0;
        }
        
        .dashboard-title {
            font-size: 18px;
            font-weight: 600;
            color: #fff;
        }
        
        .dashboard-close {
            background: none;
            border: none;
            color: #888;
            font-size: 28px;
            cursor: pointer;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: all 0.2s;
        }
        
        .dashboard-close:hover {
            background: #333;
            color: #fff;
        }
        
        .dashboard-tabs {
            display: flex;
            gap: 0;
            padding: 0 20px;
            background: #1a1a1a;
            border-bottom: 1px solid #3a3a3a;
            overflow-x: auto;
            flex-shrink: 0;
        }
        
        .dashboard-tab {
            padding: 12px 16px;
            background: none;
            border: none;
            color: #888;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
            white-space: nowrap;
        }
        
        .dashboard-tab:hover {
            color: #fff;
            background: #252525;
        }
        
        .dashboard-tab.active {
            color: #667eea;
            border-bottom-color: #667eea;
        }
        
        .dashboard-content {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }
        
        .dashboard-section {
            display: none !important;
        }
        
        .dashboard-section.active {
            display: block !important;
        }
        
        .form-group {
            margin-bottom: 20px;
        }
        
        .form-group label {
            display: block;
            font-size: 13px;
            font-weight: 600;
            color: #aaa;
            margin-bottom: 6px;
        }
        
        .form-group input,
        .form-group select {
            width: 100%;
            padding: 10px 12px;
            background: #2a2a2a;
            border: 1px solid #3a3a3a;
            border-radius: 6px;
            color: #fff;
            font-size: 14px;
            transition: all 0.2s;
        }
        
        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: #667eea;
            background: #333;
        }
        
        .form-hint {
            display: block;
            font-size: 11px;
            color: #666;
            margin-top: 4px;
        }
        
        .button {
            padding: 10px 16px;
            background: #667eea;
            color: #fff;
            border: none;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .button:hover {
            background: #5568d3;
        }
        
        .button-secondary {
            background: #3a3a3a;
        }
        
        .button-secondary:hover {
            background: #4a4a4a;
        }
        
        .button-danger {
            background: #ff4444;
        }
        
        .button-danger:hover {
            background: #cc0000;
        }
        
        .test-users-section {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        
        .members-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 10px;
        }
        
        .member-item {
            padding: 10px 12px;
            background: #2a2a2a;
            border: 1px solid #3a3a3a;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .member-name {
            font-weight: 600;
            color: #fff;
        }
        .member-name.status-not-joined { color: #777; }
        .member-name.status-active { color: #fff; }
        .member-name.status-joined { }
        .member-name.status-sleepy {
            animation: sleepyPulse 2.4s ease-in-out infinite;
        }
        .member-zzz {
            margin-left: 6px;
            font-size: 11px;
            letter-spacing: 1px;
            opacity: 0.75;
            animation: zzzFloat 1.8s ease-in-out infinite;
            user-select: none;
        }
        @keyframes sleepyPulse {
            0%, 100% { opacity: 0.55; }
            50% { opacity: 1; }
        }
        @keyframes zzzFloat {
            0%, 100% { opacity: 0.35; transform: translateY(0); }
            50% { opacity: 0.95; transform: translateY(-2px); }
        }
        
        .member-status {
            font-size: 11px;
            color: #888;
            margin-left: 8px;
        }
        
        .member-actions {
            display: flex;
            gap: 6px;
        }
        
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 8px 0;
        }
        
        .checkbox-group input[type="checkbox"] {
            width: auto;
            margin: 0;
        }
    </style>
</head>
<body>
    <!-- Desktop App Menu Bar (only visible in Electron) -->
    <div class="desktop-menu-bar" id="desktopMenuBar">
        <button class="menu-button" id="btnSettings">‚öôÔ∏è</button>
        <button class="menu-button" id="btnMembers">Members</button>
        <button class="menu-button-square success" id="btnShowAll">‚úì</button>
        <button class="menu-button-square danger" id="btnHideAll">‚úï</button>
        <button class="menu-button" id="btnDashboard">Dashboard</button>
        <div class="menu-spacer"></div>
        <div class="menu-status">
            <div class="status-indicator" id="statusIndicator"></div>
            <span id="statusText">Disconnected</span>
        </div>
        <button class="menu-button-square danger" id="btnKickAllUsers" title="Kick all (non-test) users">‚òÅÔ∏è</button>
        <button class="menu-button-square success" id="btnJoinAllUsers" title="Join all users (non-test)">üî•</button>
        <button class="menu-button danger" id="btnEnd">End</button>
    </div>
    
    <!-- Integrated Dashboard Overlay -->
    <div class="dashboard-overlay" id="dashboardOverlay">
        <div class="dashboard-panel">
            <div class="dashboard-header">
                <button class="dashboard-close" onclick="closeDashboard()">√ó</button>
            </div>
            
            <div class="dashboard-tabs" id="dashboardTabs">
                <button class="dashboard-tab active" onclick="switchDashboardTab('quick')">Quick Settings</button>
                <button class="dashboard-tab" onclick="switchDashboardTab('members')">Members</button>
            </div>
            
            <div class="dashboard-content">
                <!-- Quick Settings Tab -->
                <div class="dashboard-section active" id="quickSection">
                    <h3 style="color: #fff; margin-bottom: 15px;">‚ö° Quick Settings</h3>
                    
                    <div class="form-group">
                        <label for="spriteMode">Sprite Mode</label>
                        <select id="spriteMode" onchange="updateSpriteMode()">
                            <option value="circles">CIRCLES</option>
                            <option value="circle">SHADOWS</option>
                            <option value="rpg-characters">ADVENTURERS (pixel characters)</option>
                            <option value="pixel-morphs">MORPHS (animated morphs)</option>
                            <option value="custom">CUSTOM (upload your own)</option>
                        </select>
                    </div>
                    
                    <div class="form-group">
                        <label for="maxUsers">Maximum Users</label>
                        <input type="number" id="maxUsers" value="20" min="1" max="50" onchange="updateMaxUsers()">
                        <span class="form-hint">Maximum number of users around the campfire</span>
                    </div>
                    
                    <div class="form-group">
                        <label for="joinMethod">Join Method</label>
                        <select id="joinMethod" onchange="updateJoinMethod()">
                            <option value="command">Chat Command (!join)</option>
                            <option value="emote">Emote</option>
                            <option value="cheer">Cheer/Bits</option>
                        </select>
                    </div>
                    
                    <div class="form-group" id="quickCheerSettings" style="display: none;">
                        <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px; align-items: start;">
                            <div>
                                <label for="quickCheerType" style="display: block; margin-bottom: 8px;">Payment Type</label>
                                <select id="quickCheerType">
                                    <option value="bits">Bits</option>
                                    <option value="channel-points">Channel Points</option>
                                </select>
                            </div>
                            <div>
                                <label for="quickCheerAmount" style="display: block; margin-bottom: 8px;">Amount</label>
                                <input type="number" id="quickCheerAmount" value="100" min="1">
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Members Tab -->
                <div class="dashboard-section" id="membersSection">
                    <h3 style="color: #fff; margin-bottom: 15px;">üë• Campfire Members</h3>
                    <div class="members-list" id="membersList">
                        <p style="color: #888;">No members yet. Users will appear here when they join.</p>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="widget-container">
        <div class="campfire-area">
            <div class="circle-container" id="circleContainer">
                <!-- Debug circle (optional, for visualization) -->
                <div class="debug-circle" id="debugCircle"></div>
                
                <!-- User shapes will be dynamically added here -->
            </div>
            
            <div class="campfire-graphic" id="campfireGraphic">
                <!-- Campfire GIF/video will be inserted here -->
            </div>
        </div>
    </div>

    <script>
        // ============================================
        // MENU BAR - Check if we should show it
        // ============================================
        // Hide menu bar in preview/test contexts (iframe, popup windows, etc.)
        const isPreviewContext = window.self !== window.top || window.opener !== null || window.location.search.includes('preview=true') || window.location.search.includes('test=true');
        
        if (isPreviewContext) {
            console.log('[Menu Bar] Hiding menu bar - in preview/test context');
            const menuBar = document.getElementById('desktopMenuBar');
            if (menuBar) {
                menuBar.style.display = 'none';
            }
        }
        
        class CampfireWidget {
            constructor() {
                console.log('CampfireWidget constructor called');
                this.users = [];
                this.settings = this.loadSettings();
                console.log('Settings loaded:', this.settings);
                this.circleRadius = 120;
                this.circleAngle = this.settings.circleAngle || 0; // 0 = top-down, 90 = side-view
                this.maxUsers = this.settings.maxUsers || 20;
                this.animationFrame = null;
                
                console.log('Calling init()...');
                this.init();
                console.log('Init completed');
            }

            loadSettings() {
                // First, try to load from URL parameters (for Custom Widget)
                const urlParams = new URLSearchParams(window.location.search);
                const urlSettings = {};
                
                if (urlParams.has('graphic')) urlSettings.campfireGraphicUrl = decodeURIComponent(urlParams.get('graphic'));
                if (urlParams.has('angle')) urlSettings.circleAngle = parseInt(urlParams.get('angle'));
                if (urlParams.has('joinMethod')) urlSettings.joinMethod = urlParams.get('joinMethod');
                if (urlParams.has('command')) urlSettings.command = urlParams.get('command');
                if (urlParams.has('emoteName')) urlSettings.emoteName = urlParams.get('emoteName');
                if (urlParams.has('maxUsers')) urlSettings.maxUsers = parseInt(urlParams.get('maxUsers'));
                if (urlParams.has('shapeStyle')) urlSettings.shapeStyle = urlParams.get('shapeStyle');
                if (urlParams.has('subOnly')) urlSettings.subscriberOnly = urlParams.get('subOnly') === 'true';
                if (urlParams.has('subTier2')) urlSettings.subTier2Only = urlParams.get('subTier2') === 'true';
                if (urlParams.has('subTier3')) urlSettings.subTier3Only = urlParams.get('subTier3') === 'true';
                if (urlParams.has('vipOnly')) urlSettings.vipOnly = urlParams.get('vipOnly') === 'true';
                if (urlParams.has('primeOnly')) urlSettings.primeOnly = urlParams.get('primeOnly') === 'true';
                if (urlParams.has('bits')) urlSettings.bitsRequired = parseInt(urlParams.get('bits'));
                if (urlParams.has('glowSize')) urlSettings.glowSize = parseInt(urlParams.get('glowSize'));
                if (urlParams.has('glowIntensity')) urlSettings.glowIntensity = parseInt(urlParams.get('glowIntensity'));
                if (urlParams.has('shadowIntensity')) urlSettings.shadowIntensity = parseInt(urlParams.get('shadowIntensity'));
                if (urlParams.has('glowSpread')) urlSettings.glowSpread = parseInt(urlParams.get('glowSpread'));
                if (urlParams.has('animatedGlow')) urlSettings.animatedGlow = urlParams.get('animatedGlow') === 'true';
                if (urlParams.has('flickerOpacity')) urlSettings.flickerOpacity = parseInt(urlParams.get('flickerOpacity'));
                if (urlParams.has('flickerSpread')) urlSettings.flickerSpread = parseInt(urlParams.get('flickerSpread'));
                if (urlParams.has('spriteMode')) urlSettings.spriteMode = urlParams.get('spriteMode');
                if (urlParams.has('fireSize')) urlSettings.fireSize = parseInt(urlParams.get('fireSize'));
                if (urlParams.has('spriteSize')) urlSettings.spriteSize = parseInt(urlParams.get('spriteSize'));
                if (urlParams.has('spriteDefaultDirection')) urlSettings.spriteDefaultDirection = urlParams.get('spriteDefaultDirection');
                
                // Load sprite data from localStorage (always check for latest)
                const defaultSprite = localStorage.getItem('defaultSpriteData');
                const customSprite = localStorage.getItem('customSpriteData');
                
                // If URL params exist, use them (Custom Widget mode)
                if (Object.keys(urlSettings).length > 0) {
                    if (defaultSprite) urlSettings.defaultSpriteData = defaultSprite;
                    if (customSprite) urlSettings.customSpriteData = customSprite;
                    return { ...this.getDefaultSettings(), ...urlSettings };
                }
                
                // Otherwise, try to load from LocalStorage (set by dashboard)
                const saved = localStorage.getItem('campfireWidgetSettings');
                if (saved) {
                    try {
                        const settings = { ...this.getDefaultSettings(), ...JSON.parse(saved) };
                        // Always load latest sprite data from localStorage
                        if (defaultSprite) settings.defaultSpriteData = defaultSprite;
                        if (customSprite) settings.customSpriteData = customSprite;
                        return settings;
                    } catch (e) {
                        console.error('Error loading settings:', e);
                    }
                }
                
                // Also check localStorage for sprites even if no settings saved
                if (defaultSprite || customSprite) {
                    const settings = this.getDefaultSettings();
                    if (defaultSprite) settings.defaultSpriteData = defaultSprite;
                    if (customSprite) settings.customSpriteData = customSprite;
                    return settings;
                }
                
                // Return default settings
                return this.getDefaultSettings();
            }

            getDefaultSettings() {
                return {
                    campfireMethod: 'url',
                    campfireGraphicUrl: '',
                    campfireGraphicData: '',
                    campfireYOffset: 50, // 0‚Äì100, where 50 = centered
                    widgetBackground: 'black', // 'transparent' | 'black' | 'white' | 'green'
                    useNativeFrame: true,
                    circleAngle: 64,
                    joinMethod: 'command',
                    command: '!join',
                    emoteName: '',
                    maxUsers: 20,
                    shapeStyle: 'circle',
                    subscriberOnly: false,
                    subTier2Only: false,
                    subTier3Only: false,
                    vipOnly: false,
                    primeOnly: false,
                    bitsRequired: 0,
                    glowSize: 500,
                    glowIntensity: 77,
                    shadowIntensity: 91,
                    glowSpread: 64,
                    animatedGlow: true,
                    flickerOpacity: 25,
                    flickerSpread: 55,
                    spriteMode: 'circles',
                    defaultSpriteData: '',
                    customSpriteData: '',
                    shadowSprites: [],
                    rpgSprites: [],
                    morphSprites: [],
                    fireSize: 48,
                    spriteSize: 40,
                    spriteDefaultDirection: 'left', // 'left' or 'right'
                    enableUserGrouping: false, // If true, users group near each other; if false, even distribution
                    userGroupingDistance: 15 // Minimum degrees between users when grouping (default 15¬∞)
                };
            }
            
            // Get a random sprite from a collection
            getRandomSprite(collection) {
                if (!collection || collection.length === 0) return null;
                return collection[Math.floor(Math.random() * collection.length)];
            }
            
            // Get sprite for user based on mode and user preferences
            getUserSprite(user) {
                const spriteMode = this.settings.spriteMode || 'circles';
                // For circle/circles modes: use getCircleSpriteColor (checks saved colors first, then Twitch color)
                // For other modes: use getViewerColor (for sprite colorization if needed, but usernames use getTwitchColor)
                const viewerColor = (spriteMode === 'circle' || spriteMode === 'circles') 
                    ? this.getCircleSpriteColor(user.username, user.userId)
                    : (user.color || this.getViewerColor(user.username, user.userId));
                
                // Ensure sprite collections are arrays
                if (!Array.isArray(this.settings.rpgSprites)) this.settings.rpgSprites = [];
                if (!Array.isArray(this.settings.shadowSprites)) this.settings.shadowSprites = [];
                if (!Array.isArray(this.settings.morphSprites)) this.settings.morphSprites = [];
                
                // Debug: Log sprite availability (only once per user)
                if (!user.assignedSprite && !user.selectedSprite && !user._spriteLogged) {
                    console.log(`[getUserSprite] ${user.username} - Mode: ${spriteMode}, RPG: ${this.settings.rpgSprites.length}, Shadows: ${this.settings.shadowSprites.length}, Morph: ${this.settings.morphSprites.length}`);
                    user._spriteLogged = true;
                }
                
                if (spriteMode === 'rpg-characters') {
                    // RPG mode: use random sprite (or user's selected one)
                    // Initialize spritesByMode if needed
                    if (!user.spritesByMode) user.spritesByMode = {};

                    // User's saved RPG sprite (from Viewer Dashboard / persistence).
                    // Only applies when spriteMode is RPG so mode switching actually updates everyone.
                    if (user.selectedSprite) {
                        const spriteData = typeof user.selectedSprite === 'string'
                            ? user.selectedSprite
                            : (user.selectedSprite.data || user.selectedSprite);
                        if (spriteData) {
                            user.spritesByMode['rpg-characters'] = spriteData;
                            return { data: spriteData, colorize: false };
                        }
                    }
                    
                    // Check if user already has a sprite for this mode
                    if (user.spritesByMode['rpg-characters']) {
                        return {
                            data: user.spritesByMode['rpg-characters'],
                            colorize: false
                        };
                    }
                    
                    const rpgSprites = this.settings.rpgSprites || [];
                    if (rpgSprites.length === 0) {
                        console.warn(`[getUserSprite] No RPG sprites available for ${user.username}, using fallback`);
                    }
                    const sprite = this.getRandomSprite(rpgSprites);
                    if (sprite && sprite.data) {
                        // Store the assigned sprite so it doesn't change on updates
                        user.spritesByMode['rpg-characters'] = sprite.data;
                        return {
                            data: sprite.data,
                            colorize: false // RPG sprites aren't colorized
                        };
                    }
                    // Fallback: Use colored circle (ALL modes fall back to circles when sprites fail)
                    console.warn(`[getUserSprite] No valid RPG sprite found for ${user.username}, falling back to colored circle`);
                    const svgCircle = 'data:image/svg+xml;base64,' + btoa(`
                        <svg width="40" height="40" xmlns="http://www.w3.org/2000/svg">
                            <circle cx="20" cy="20" r="18" fill="${viewerColor}" stroke="${viewerColor}" stroke-width="2"/>
                        </svg>
                    `);
                    user.spritesByMode['rpg-characters'] = svgCircle;
                    return {
                        data: svgCircle,
                        colorize: false,
                        color: viewerColor
                    };
                } else if (spriteMode === 'circles') {
                    // Circles mode: use simple colored SVG circles (Twitch username color or saved custom color)
                    // Initialize spritesByMode if needed
                    if (!user.spritesByMode) user.spritesByMode = {};
                    
                    // Check if user already has a sprite for this mode
                    if (user.spritesByMode['circles']) {
                        return {
                            data: user.spritesByMode['circles'],
                            colorize: false, // Already colored
                            color: viewerColor
                        };
                    }
                    
                    // Create a colored SVG circle with the user's color
                    const svgCircle = 'data:image/svg+xml;base64,' + btoa(`
                        <svg width="40" height="40" xmlns="http://www.w3.org/2000/svg">
                            <circle cx="20" cy="20" r="18" fill="${viewerColor}" stroke="${viewerColor}" stroke-width="2"/>
                        </svg>
                    `);
                    user.spritesByMode['circles'] = svgCircle;
                    return {
                        data: svgCircle,
                        colorize: false, // Already colored
                        color: viewerColor
                    };
                } else if (spriteMode === 'circle') {
                    // Circle/Shadows mode: use shadow sprites and colorize them
                    // Initialize spritesByMode if needed
                    if (!user.spritesByMode) user.spritesByMode = {};
                    
                    // Check if user already has a sprite for this mode
                    if (user.spritesByMode['circle']) {
                        return {
                            data: user.spritesByMode['circle'],
                            colorize: true,
                            color: viewerColor
                        };
                    }
                    
                    const shadowSprites = this.settings.shadowSprites || [];
                    const sprite = this.getRandomSprite(shadowSprites);
                    if (sprite && sprite.data) {
                        user.spritesByMode['circle'] = sprite.data;
                        return {
                            data: sprite.data,
                            colorize: true,
                            color: viewerColor
                        };
                    }
                    
                    // Fallback: Create a colored SVG circle (ALL modes fall back to circles when sprites fail)
                    console.warn(`[getUserSprite] No shadow sprites available for ${user.username}, using SVG circle fallback`);
                    const svgCircle = 'data:image/svg+xml;base64,' + btoa(`
                        <svg width="40" height="40" xmlns="http://www.w3.org/2000/svg">
                            <circle cx="20" cy="20" r="18" fill="${viewerColor}" stroke="${viewerColor}" stroke-width="2"/>
                        </svg>
                    `);
                    user.spritesByMode['circle'] = svgCircle;
                    return {
                        data: svgCircle,
                        colorize: false, // Already colored
                        color: viewerColor
                    };
                } else if (spriteMode === 'pixel-morphs') {
                    // Morph mode: use random morph sprite and colorize it
                    // Initialize spritesByMode if needed
                    if (!user.spritesByMode) user.spritesByMode = {};
                    
                    // Check if user already has a sprite for this mode
                    if (user.spritesByMode['pixel-morphs']) {
                        return {
                            data: user.spritesByMode['pixel-morphs'],
                            colorize: true,
                            color: viewerColor
                        };
                    }
                    
                    const morphSprites = this.settings.morphSprites || [];
                    const sprite = this.getRandomSprite(morphSprites);
                    if (sprite && sprite.data) {
                        user.spritesByMode['pixel-morphs'] = sprite.data;
                        return {
                            data: sprite.data,
                            colorize: true,
                            color: viewerColor
                        };
                    }
                    // Fallback: Create a colored SVG circle (ALL modes fall back to circles when sprites fail)
                    console.warn(`[getUserSprite] No morph sprites available for ${user.username}, using circle fallback`);
                    const svgCircle = 'data:image/svg+xml;base64,' + btoa(`
                        <svg width="40" height="40" xmlns="http://www.w3.org/2000/svg">
                            <circle cx="20" cy="20" r="18" fill="${viewerColor}" stroke="${viewerColor}" stroke-width="2"/>
                        </svg>
                    `);
                    user.spritesByMode['pixel-morphs'] = svgCircle;
                    return {
                        data: svgCircle,
                        colorize: false,
                        color: viewerColor
                    };
                } else if (spriteMode === 'custom') {
                    // Custom mode: use custom sprite (not colorized)
                    if (this.settings.customSpriteData) {
                        return {
                            data: this.settings.customSpriteData,
                            colorize: false
                        };
                    }
                }
                
                // Fallback: ALL modes fall back to colored SVG circles when sprites fail
                console.warn(`[getUserSprite] No sprite found for ${user.username} in mode ${spriteMode}, using circle fallback`);
                const svgCircle = 'data:image/svg+xml;base64,' + btoa(`
                    <svg width="40" height="40" xmlns="http://www.w3.org/2000/svg">
                        <circle cx="20" cy="20" r="18" fill="${viewerColor}" stroke="${viewerColor}" stroke-width="2"/>
                    </svg>
                `);
                if (!user.spritesByMode) user.spritesByMode = {};
                user.spritesByMode[spriteMode] = svgCircle;
                return {
                    data: svgCircle,
                    colorize: false,
                    color: viewerColor
                };
            }

            init() {
                console.log('Init() called');
                // Always reload sprite data and campfire graphic from localStorage on init
                const defaultSprite = localStorage.getItem('defaultSpriteData');
                const customSprite = localStorage.getItem('customSpriteData');
                const campfireGraphic = localStorage.getItem('campfireGraphicData');
                if (defaultSprite) this.settings.defaultSpriteData = defaultSprite;
                if (customSprite) this.settings.customSpriteData = customSprite;
                if (campfireGraphic) this.settings.campfireGraphicData = campfireGraphic;
                
                // Load sprite collections
                const shadowSprites = localStorage.getItem('shadowSprites');
                const rpgSprites = localStorage.getItem('rpgSprites');
                const morphSprites = localStorage.getItem('morphSprites');
                
                if (shadowSprites) {
                    try {
                        this.settings.shadowSprites = JSON.parse(shadowSprites);
                        if (!Array.isArray(this.settings.shadowSprites)) {
                            this.settings.shadowSprites = [];
                        }
                    } catch (e) {
                        console.error('Error parsing shadowSprites:', e);
                        this.settings.shadowSprites = [];
                    }
                } else {
                    this.settings.shadowSprites = [];
                }
                
                if (rpgSprites) {
                    try {
                        this.settings.rpgSprites = JSON.parse(rpgSprites);
                        if (!Array.isArray(this.settings.rpgSprites)) {
                            this.settings.rpgSprites = [];
                        }
                        console.log(`Loaded ${this.settings.rpgSprites.length} RPG sprites from localStorage`);
                    } catch (e) {
                        console.error('Error parsing rpgSprites:', e);
                        this.settings.rpgSprites = [];
                    }
                } else {
                    console.warn('No RPG sprites found in localStorage');
                    this.settings.rpgSprites = [];
                }
                
                if (morphSprites) {
                    try {
                        this.settings.morphSprites = JSON.parse(morphSprites);
                        if (!Array.isArray(this.settings.morphSprites)) {
                            this.settings.morphSprites = [];
                        }
                    } catch (e) {
                        console.error('Error parsing morphSprites:', e);
                        this.settings.morphSprites = [];
                    }
                } else {
                    this.settings.morphSprites = [];
                }
                
                console.log('Sprite mode:', this.settings.spriteMode);
                console.log('Sprite collections loaded - RPG:', this.settings.rpgSprites.length, 'Shadows:', this.settings.shadowSprites.length, 'Morph:', this.settings.morphSprites.length);
                
                console.log('Setting up campfire graphic...');
                this.setupCampfireGraphic();
                this.applyCampfireYOffset();
                this.applyWidgetBackground();
                this.applyNativeFrameMode();
                console.log('Updating circle transform...');
                this.updateCircleTransform();
                
                // Load persisted users from localStorage
                this.loadPersistedUsers();
                
                // Remove any test users that might have been loaded (they should only be added via toggle)
                const testUsers = this.users.filter(u => u.username && u.username.startsWith('TestUser'));
                if (testUsers.length > 0) {
                    console.log(`Removing ${testUsers.length} test users that were loaded (they should only be added via toggle)`);
                    testUsers.forEach(user => {
                        this.removeUser(user.username);
                    });
                }
                
                // Force showTestUsers to false on startup (default: not present)
                if (this.settings.showTestUsers !== false) {
                    this.settings.showTestUsers = false;
                    // Save settings to localStorage
                    try {
                        localStorage.setItem('campfireWidgetSettings', JSON.stringify(this.settings));
                    } catch (e) {
                        console.error('Error saving settings:', e);
                    }
                }
                
                // Only show test users if explicitly enabled (default: false)
                // Test users are only added when "Show Test Users" toggle is ON
                if (this.settings.showTestUsers === true) {
                    console.log('Test users enabled, setting up mock users...');
                    this.setupMockUsers();
                }
                
                // Start random movement for ALL users (NPC movement)
                // Users with their dashboard open (activeViewer) won't move - they control their sprite manually
                // When they close their dashboard, activeViewer is cleared and movement automatically resumes
                if (!this._randomMovementStarted) {
                    setTimeout(() => {
                        console.log('Starting random movement for all users...');
                        this.startRandomMovement();
                        this._randomMovementStarted = true;
                    }, 1000); // Start after 1 second to let users load
                }
                
                console.log('Init complete, users:', this.users.length);
            }
            
            savePersistedUsers() {
                // Save current users to localStorage (excluding test users)
                const persistedUsers = this.users.filter(u => !u.username.startsWith('TestUser'));
                try {
                    localStorage.setItem('campfireUsers', JSON.stringify(persistedUsers));
                    console.log(`Saved ${persistedUsers.length} users to localStorage`);
                    
                    // Also save complete widget state for viewer dashboard access
                    const widgetState = {
                        users: this.users.map(u => ({
                            userId: u.userId,
                            username: u.username,
                            displayName: u.displayName,
                            color: u.color,
                            selectedSprite: u.selectedSprite,
                            angle: u.angle
                        })),
                        timestamp: Date.now()
                    };
                    localStorage.setItem('campfireWidgetState', JSON.stringify(widgetState));
                } catch (e) {
                    console.error('Error saving users to localStorage:', e);
                }
            }
            
            loadPersistedUsers() {
                // Load users from localStorage and restore them
                // IMPORTANT: Filter out test users - they should only be added via toggle
                try {
                    const savedUsers = localStorage.getItem('campfireUsers');
                    if (savedUsers) {
                        const users = JSON.parse(savedUsers);
                        // Filter out any test users that might have been saved
                        const realUsers = users.filter(u => !u.username || !u.username.startsWith('TestUser'));
                        console.log(`Loading ${realUsers.length} persisted users from localStorage (filtered ${users.length - realUsers.length} test users)`);
                        realUsers.forEach(userData => {
                            // Restore user and create element
                            this.users.push(userData);
                            // Create element for restored user
                            this.createUserElement(userData);
                        });
                    }
                } catch (e) {
                    console.error('Error loading persisted users:', e);
                }
            }

            setupCampfireGraphic() {
                console.log('setupCampfireGraphic() called');
                const container = document.getElementById('campfireGraphic');
                if (!container) {
                    console.error('Campfire graphic container not found!');
                    return;
                }
                console.log('Container found:', container);
                console.log('Container display:', window.getComputedStyle(container).display);
                console.log('Container visibility:', window.getComputedStyle(container).visibility);
                console.log('Container opacity:', window.getComputedStyle(container).opacity);
                
                // Check for uploaded graphic first, then URL
                const uploadedData = this.settings.campfireGraphicData || localStorage.getItem('campfireGraphicData');
                const url = this.settings.campfireGraphicUrl;
                const graphicSource = uploadedData || url;
                
                console.log('Graphic source:', uploadedData ? 'uploaded' : (url ? 'URL' : 'none (using default)'));
                
                // Calculate perspective transform for glow
                // Cap glow angle at 77 degrees to prevent it from getting too thin
                // User orbit can go to 90, but glow visual stops at 77
                const glowAngle = Math.min(this.circleAngle, 77);
                const angleRad = (glowAngle * Math.PI) / 180;
                const scaleY = Math.cos(angleRad);
                
                if (!graphicSource) {
                    // Get glow settings
                    const glowSize = this.settings.glowSize || 500;
                    const glowIntensity = this.settings.glowIntensity || 77;
                    const shadowIntensity = this.settings.shadowIntensity || 91;
                    const glowSpread = this.settings.glowSpread || 64;
                    const animatedGlow = this.settings.animatedGlow !== false; // Default to true
                    
                    // Calculate opacity values based on intensity (0-100% maps to 0-0.5 opacity)
                    const baseOpacity = (glowIntensity / 100) * 0.5;
                    const shadowOpacity = (shadowIntensity / 100);
                    
                    // Calculate gradient stops based on spread
                    const stop1 = Math.max(0, glowSpread * 0.25);
                    const stop2 = Math.max(5, glowSpread * 0.4);
                    const stop3 = Math.max(10, glowSpread * 0.55);
                    const stop4 = Math.max(15, glowSpread * 0.7);
                    const stop5 = Math.max(20, glowSpread * 0.85);
                    
                    // Build glow gradient with dynamic stops
                    const glowGradient = `radial-gradient(ellipse at center, 
                        rgba(255, 107, 53, ${baseOpacity}) 0%, 
                        rgba(247, 147, 30, ${baseOpacity * 0.7}) ${stop1}%, 
                        rgba(255, 204, 2, ${baseOpacity * 0.5}) ${stop2}%, 
                        rgba(255, 204, 2, ${baseOpacity * 0.3}) ${stop3}%, 
                        rgba(255, 204, 2, ${baseOpacity * 0.15}) ${stop4}%, 
                        transparent ${glowSpread}%)`;
                    
                    // Flicker glow (front-of-campfire layer)
                    const flickerSize = (this.settings.flickerSize || glowSize);
                    const flickerOpacity = this.settings.flickerOpacity || 25; // 0-100
                    const flickerSpread = this.settings.flickerSpread || 55; // 20-100

                    // Flicker gradient (front layer)
                    const flickerBaseOpacity = Math.max(0, Math.min(1, (flickerOpacity / 100) * 0.6));
                    const f1 = Math.max(0, flickerSpread * 0.25);
                    const f2 = Math.max(5, flickerSpread * 0.45);
                    const flickerGradient = `radial-gradient(ellipse at center,
                        rgba(255, 255, 255, ${flickerBaseOpacity * 0.15}) 0%,
                        rgba(255, 204, 2, ${flickerBaseOpacity * 0.7}) ${f1}%,
                        rgba(255, 107, 53, ${flickerBaseOpacity * 0.35}) ${f2}%,
                        transparent ${flickerSpread}%)`;

                    // Default placeholder with natural transparent glow (no borders, follows angle)
                    console.log('Creating default campfire glow...');
                    container.innerHTML = `
                        <div id="campfireGlow" style="position: absolute; width: ${glowSize}px; height: ${glowSize}px; left: 50%; top: 50%; transform: translate(-50%, -50%) scaleY(${scaleY});
                                    background: ${glowGradient};
                                    pointer-events: none; border: none; outline: none; box-shadow: none; transition: background 0.3s ease;">
                        </div>
                        <div id="campfireFlicker" style="position: absolute; width: ${flickerSize}px; height: ${flickerSize}px; left: 50%; top: 50%; transform: translate(-50%, -50%) scaleY(${scaleY});
                                    background: ${flickerGradient};
                                    pointer-events: none; border: none; outline: none; box-shadow: none; transition: background 0.3s ease; z-index: 12;">
                        </div>
                        <div id="campfireEmoji" style="position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); z-index: 11; font-size: ${this.settings.fireSize || 48}px; filter: none; pointer-events: none;">üî•</div>
                    `;
                    console.log('Campfire graphic HTML set, container.innerHTML length:', container.innerHTML.length);
                    
                    // Start animation if enabled
                    if (animatedGlow) {
                        this.startGlowAnimation();
                    }
                    
                    return;
                }

                // Get glow settings (always create glow, even for custom graphics)
                const glowSize = this.settings.glowSize || 500;
                const glowIntensity = this.settings.glowIntensity || 77;
                const shadowIntensity = this.settings.shadowIntensity || 91;
                const glowSpread = this.settings.glowSpread || 64;
                const animatedGlow = this.settings.animatedGlow !== false; // Default to true
                
                // Calculate opacity values based on intensity (0-100% maps to 0-0.5 opacity)
                const baseOpacity = (glowIntensity / 100) * 0.5;
                const shadowOpacity = (shadowIntensity / 100);
                
                // Calculate gradient stops based on spread
                const stop1 = Math.max(0, glowSpread * 0.25);
                const stop2 = Math.max(5, glowSpread * 0.4);
                const stop3 = Math.max(10, glowSpread * 0.55);
                const stop4 = Math.max(15, glowSpread * 0.7);
                const stop5 = Math.max(20, glowSpread * 0.85);
                
                // Build glow gradient with dynamic stops
                const glowGradient = `radial-gradient(ellipse at center, 
                    rgba(255, 107, 53, ${baseOpacity}) 0%, 
                    rgba(247, 147, 30, ${baseOpacity * 0.7}) ${stop1}%, 
                    rgba(255, 204, 2, ${baseOpacity * 0.5}) ${stop2}%, 
                    rgba(255, 204, 2, ${baseOpacity * 0.3}) ${stop3}%, 
                    rgba(255, 204, 2, ${baseOpacity * 0.15}) ${stop4}%, 
                    transparent ${glowSpread}%)`;
                
                // Use uploaded data if available, otherwise use URL
                const fireSize = this.settings.fireSize || 48;
                let graphicHTML = '';
                
                // Always create glow element first (behind the graphic)
                graphicHTML = `<div id="campfireGlow" style="position: absolute; width: ${glowSize}px; height: ${glowSize}px; left: 50%; top: 50%; transform: translate(-50%, -50%) scaleY(${scaleY}); 
                            background: ${glowGradient}; 
                            pointer-events: none; border: none; outline: none; box-shadow: none; transition: background 0.3s ease; z-index: 10;">
                        </div>`;
                
                if (uploadedData) {
                    // Check if it's a video or image based on data URL
                    if (uploadedData.startsWith('data:video/')) {
                        graphicHTML += `<video autoplay loop muted playsinline style="width: ${fireSize}px; height: ${fireSize}px; object-fit: contain; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); z-index: 11; filter: none;"><source src="${uploadedData}"></video>`;
                    } else {
                        graphicHTML += `<img src="${uploadedData}" alt="Campfire" style="width: ${fireSize}px; height: ${fireSize}px; object-fit: contain; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); z-index: 11; filter: none;">`;
                    }
                } else if (url) {
                    // Check if it's a video or image
                    const extension = url.split('.').pop().toLowerCase();
                    if (['mp4', 'webm', 'mov'].includes(extension)) {
                        graphicHTML += `<video autoplay loop muted playsinline style="width: ${fireSize}px; height: ${fireSize}px; object-fit: contain; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); z-index: 11; filter: none;"><source src="${url}" type="video/${extension}"></video>`;
                    } else {
                        graphicHTML += `<img src="${url}" alt="Campfire" style="width: ${fireSize}px; height: ${fireSize}px; object-fit: contain; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); z-index: 11; filter: none;">`;
                    }
                }
                
                // Flicker glow (front-of-campfire layer)
                const flickerSize = (this.settings.flickerSize || glowSize);
                const flickerOpacity = this.settings.flickerOpacity || 25; // 0-100
                const flickerSpread = this.settings.flickerSpread || 55; // 20-100

                // Flicker gradient (sits in front of the campfire image)
                const flickerBaseOpacity = Math.max(0, Math.min(1, (flickerOpacity / 100) * 0.6));
                const f1 = Math.max(0, flickerSpread * 0.25);
                const f2 = Math.max(5, flickerSpread * 0.45);
                const flickerGradient = `radial-gradient(ellipse at center,
                    rgba(255, 255, 255, ${flickerBaseOpacity * 0.15}) 0%,
                    rgba(255, 204, 2, ${flickerBaseOpacity * 0.7}) ${f1}%,
                    rgba(255, 107, 53, ${flickerBaseOpacity * 0.35}) ${f2}%,
                    transparent ${flickerSpread}%)`;

                // Front-of-campfire flicker layer (above the campfire image)
                graphicHTML += `<div id="campfireFlicker" style="position: absolute; width: ${flickerSize}px; height: ${flickerSize}px; left: 50%; top: 50%; transform: translate(-50%, -50%) scaleY(${scaleY});
                            background: ${flickerGradient};
                            pointer-events: none; border: none; outline: none; box-shadow: none; transition: background 0.3s ease; z-index: 12;">
                    </div>`;

                container.innerHTML = graphicHTML;
                console.log('Campfire graphic HTML set, length:', graphicHTML.length);
                console.log('Container innerHTML after set:', container.innerHTML.substring(0, 200));
                
                // Verify elements were created
                const glow = document.getElementById('campfireGlow');
                const emoji = document.getElementById('campfireEmoji');
                console.log('Campfire glow element:', glow ? 'found' : 'NOT FOUND');
                console.log('Campfire emoji element:', emoji ? 'found' : 'NOT FOUND');
                const flicker = document.getElementById('campfireFlicker');
                console.log('Campfire flicker element:', flicker ? 'found' : 'NOT FOUND');
                
                // Start animation if enabled
                if (animatedGlow) {
                    this.startGlowAnimation();
                }
            }

            applyCampfireYOffset() {
                const el = document.getElementById('campfireGraphic');
                if (!el) return;
                const v = parseInt(this.settings.campfireYOffset ?? 50, 10);
                // Map 0‚Äì100 ‚Üí -200px..+200px (50 = 0px)
                const px = (v - 50) * 4;
                el.style.setProperty('--campfire-y-offset', `${px}px`);
            }

            applyWidgetBackground() {
                const choice = String(this.settings.widgetBackground || 'black').toLowerCase();
                let bg = 'transparent';
                if (choice === 'black') bg = '#000000';
                else if (choice === 'white') bg = '#ffffff';
                else if (choice === 'green') bg = '#00ff00'; // chroma key green

                // Force background at the document level (base CSS sets transparent).
                try { document.documentElement.style.setProperty('background', bg, 'important'); } catch (e) {}
                try { document.body.style.setProperty('background', bg, 'important'); } catch (e) {}
            }

            applyNativeFrameMode() {
                const useNativeFrame = this.settings.useNativeFrame !== false;
                const isWindows = /Windows/i.test(navigator.userAgent || '');
                const wantsTransparent = String(this.settings.widgetBackground || 'black').toLowerCase() === 'transparent';
                // On Windows we force frameless when using a transparent window (stability).
                const effectiveFrameless = (!useNativeFrame) || (isWindows && wantsTransparent);
                // When frameless, enable drag region on the in-widget menu bar (see CSS `body.frameless`).
                try { document.body.classList.toggle('frameless', effectiveFrameless); } catch (e) {}
            }

            updateCircleTransform() {
                // Hide debug circle (no longer needed)
                const debugCircle = document.getElementById('debugCircle');
                if (debugCircle) {
                    debugCircle.style.display = 'none';
                }
                
                // Calculate perspective transform for glow
                // Cap glow angle at 77 degrees to prevent it from getting too thin
                // User orbit can go to 90, but glow visual stops at 77
                const glowAngle = Math.min(this.circleAngle, 77);
                const angleRad = (glowAngle * Math.PI) / 180;
                const scaleY = Math.cos(angleRad);
                
                // Update campfire glow to match angle perspective
                const glow = document.getElementById('campfireGlow');
                if (glow) {
                    glow.style.transform = `translate(-50%, -50%) scaleY(${scaleY})`;
                }
                
                // Reposition all users (perspective is applied in positionUserElement)
                this.repositionUsers();
            }

            addUser(username, userData = {}) {
                // Check if user already exists - if so, just update their data
                const existingUser = this.users.find(u => u.username === username || (userData.userId && u.userId === userData.userId));
                if (existingUser) {
                    // Update existing user
                    Object.assign(existingUser, userData);
                    this.updateUserElement(existingUser);
                    return;
                }

                // Check max users
                if (this.users.length >= this.maxUsers) {
                    // Remove oldest user
                    const oldest = this.users.shift();
                    this.removeUserElement(oldest.id);
                }

                const user = {
                    id: `user-${Date.now()}-${Math.random()}`,
                    username: username,
                    angle: userData.angle !== undefined ? userData.angle : this.calculateNextAngle(),
                    userId: userData.userId || null,
                    ...userData
                };

                this.users.push(user);
                this.createUserElement(user);
                // Save to localStorage for persistence
                this.savePersistedUsers();
            }

            moveUser(username, direction, speed = 15) {
                // Try to find user by username or displayName
                const user = this.users.find(u => {
                    if (u.username === username || u.displayName === username) return true;
                    if (u.userId && localStorage.getItem('activeViewer')) {
                        try {
                            const activeViewer = JSON.parse(localStorage.getItem('activeViewer'));
                            return activeViewer && activeViewer.userId === u.userId;
                        } catch (e) {
                            return false;
                        }
                    }
                    return false;
                });
                
                if (!user) {
                    console.log('User not found for movement:', username);
                    return;
                }
                
                // Check if user is "still" (movement disabled)
                if (user.still) {
                    return; // Don't allow movement
                }

                // Calculate if user is in front or behind fire based on perspective
                // Users in front (bottom half) need reversed controls for intuitive movement
                const angleRad = (user.angle * Math.PI) / 180;
                const baseY = Math.sin(angleRad) * this.circleRadius;
                const angleRadTransform = (this.circleAngle * Math.PI) / 180;
                const perspectiveY = baseY * Math.cos(angleRadTransform);
                
                // Determine if user is in front of fire (positive Y = bottom half = front)
                const isInFront = perspectiveY > 0;
                
                // Simple approach: flip direction when in front so RIGHT always moves right visually
                // If in front: flip direction (so RIGHT visually moves right)
                const effectiveDirection = isInFront ? -direction : direction;

                // Move user around circle using effective direction
                const angleStep = speed;
                user.angle += effectiveDirection * angleStep;
                
                // Normalize angle to 0-360
                if (user.angle < 0) user.angle += 360;
                if (user.angle >= 360) user.angle -= 360;

                // Flip sprite horizontally based on visual movement direction
                // Calculate visual direction: what direction is the sprite actually moving on screen?
                // When in front: effectiveDirection is flipped, so we need to check the actual screen movement
                // We can determine this by checking if angle is increasing or decreasing
                // For sprite flip: right movement = flip, left movement = normal
                const angleChange = effectiveDirection * angleStep;
                // If angle is increasing (positive change), sprite moves clockwise (right when behind, left when in front)
                // If angle is decreasing (negative change), sprite moves counter-clockwise (left when behind, right when in front)
                // For visual: when in front, counter-clockwise = right visually, clockwise = left visually
                const visualMovingRight = isInFront ? (angleChange < 0) : (angleChange > 0);
                this.flipSprite(user.id, visualMovingRight ? 1 : -1);

                // Set moving animation
                this.setUserMoving(user.id, true);
                
                // Reposition user
                this.positionUserElement(user);
            }
            
            flipSprite(userId, direction) {
                // Flip sprite horizontally based on movement direction and default sprite direction
                const element = document.getElementById(userId);
                if (!element) return;
                
                const shape = element.querySelector('.shape');
                if (!shape) return;
                
                // Get sprite default direction for current mode (defaults to 'left' if not set)
                const currentMode = this.settings.spriteMode || 'circles';
                const defaultDirection = (this.settings.spriteDefaultDirections && this.settings.spriteDefaultDirections[currentMode])
                    || this.settings.spriteDefaultDirection // Legacy fallback
                    || 'left';
                
                // Determine if sprite should be flipped
                // direction: 1 = moving right, -1 = moving left
                // If default is LEFT:
                //   - Moving LEFT (-1) = normal (not flipped)
                //   - Moving RIGHT (1) = flipped
                // If default is RIGHT:
                //   - Moving LEFT (-1) = flipped
                //   - Moving RIGHT (1) = normal (not flipped)
                
                let shouldFlip = false;
                if (defaultDirection === 'left') {
                    // Sprite faces left by default, so flip when moving right
                    shouldFlip = (direction === 1);
                } else {
                    // Sprite faces right by default, so flip when moving left
                    shouldFlip = (direction === -1);
                }
                
                // Update flipped class for CSS (for backwards compatibility)
                if (shouldFlip) {
                    shape.classList.add('flipped');
                } else {
                    shape.classList.remove('flipped');
                }
                
                // Recalculate transform with perspective scaling (if positionUserElement was already called)
                // Get the current transform to preserve perspective scaling
                const currentTransform = shape.style.transform;
                if (currentTransform && currentTransform.includes('scaleY')) {
                    // Extract the scaleY value from current transform
                    const scaleYMatch = currentTransform.match(/scaleY\(([^)]+)\)/);
                    if (scaleYMatch) {
                        const scaleYValue = scaleYMatch[1];
                        const flipDirection = shouldFlip ? -1 : 1;
                        // Reapply transform with updated flip direction
                        const scaleXMatch = currentTransform.match(/scaleX\(([^)]+)\)/);
                        if (scaleXMatch) {
                            // Extract scaleX value (without flip direction)
                            const scaleXValue = parseFloat(scaleXMatch[1]);
                            const baseScale = Math.abs(scaleXValue);
                            shape.style.transform = `scaleX(${flipDirection * baseScale}) scaleY(${scaleYValue})`;
                        } else {
                            // No scaleX yet, use scaleY value for both
                            shape.style.transform = `scaleX(${flipDirection * parseFloat(scaleYValue)}) scaleY(${scaleYValue})`;
                        }
                    }
                } else {
                    // If no perspective scaling yet, just apply flip (perspective will be added in positionUserElement)
                    // This is handled by the CSS class, so we don't need to do anything here
                }
            }

            stopUserMovement(userId) {
                // Stop movement animation when key is released
                this.setUserMoving(userId, false);
            }

            buildMessageWithEmotes(message, emotes) {
                const esc = (s) => {
                    if (s == null) return '';
                    return String(s).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
                };
                const escAttr = (s) => {
                    if (s == null) return '';
                    return String(s)
                        .replace(/&/g, '&amp;')
                        .replace(/</g, '&lt;')
                        .replace(/>/g, '&gt;')
                        .replace(/"/g, '&quot;')
                        .replace(/'/g, '&#39;');
                };
                const third = (window.__thirdPartyEmotes && typeof window.__thirdPartyEmotes === 'object') ? window.__thirdPartyEmotes : {};
                const renderTextWithThirdParty = (text) => {
                    if (!text) return '';
                    // Split by whitespace but keep delimiters so spacing is preserved
                    return String(text).split(/(\s+)/).map(part => {
                        if (!part) return '';
                        if (/^\s+$/.test(part)) return esc(part);
                        // Allow common punctuation around emote codes
                        const m = part.match(/^([(\[{<"']*)(.*?)([)\]}>,"'.!?;:]*)$/);
                        const pre = m ? m[1] : '';
                        const core = m ? m[2] : part;
                        const post = m ? m[3] : '';
                        const url = core && third[core];
                        if (url && typeof url === 'string' && /^https?:\/\//.test(url)) {
                            return `${esc(pre)}<img src="${escAttr(url)}" alt="${escAttr(core)}" class="chat-emote chat-emote-third">${esc(post)}`;
                        }
                        return esc(part);
                    }).join('');
                };
                if (!message) return '';
                if (!emotes) return renderTextWithThirdParty(message);
                const list = [];
                if (typeof emotes === 'string' && emotes) {
                    emotes.split('/').forEach(part => {
                        const i = part.indexOf(':');
                        if (i <= 0) return;
                        const id = part.slice(0, i);
                        if (!/^\d+$/.test(id)) return;
                        part.slice(i + 1).split(',').forEach(r => {
                            const [a, b] = r.split('-').map(Number);
                            if (!isNaN(a) && !isNaN(b)) list.push({ id, start: a, end: b });
                        });
                    });
                } else if (emotes && typeof emotes === 'object') {
                    Object.keys(emotes).forEach(id => {
                        if (!/^\d+$/.test(String(id))) return;
                        const arr = Array.isArray(emotes[id]) ? emotes[id] : [emotes[id]];
                        (arr || []).forEach(r => {
                            const [a, b] = String(r).split('-').map(Number);
                            if (!isNaN(a) && !isNaN(b)) list.push({ id: String(id), start: a, end: b });
                        });
                    });
                }
                if (list.length === 0) return renderTextWithThirdParty(message);
                list.sort((a, b) => a.start - b.start);
                const segs = [];
                let pos = 0;
                for (const { id, start, end } of list) {
                    if (start > pos) segs.push({ t: 'text', v: message.slice(pos, start) });
                    segs.push({ t: 'emote', id });
                    pos = end + 1;
                }
                if (pos < message.length) segs.push({ t: 'text', v: message.slice(pos) });
                const url = (id) => `https://static-cdn.jtvnw.net/emoticons/v2/${id}/static/dark/2.0`;
                return segs.map(s => s.t === 'text' ? renderTextWithThirdParty(s.v) : `<img src="${url(s.id)}" alt="" class="chat-emote">`).join('');
            }

            showChatMessage(username, message, userId = null, emotes = null) {
                const u = username ? String(username).toLowerCase() : '';
                const uid = userId ? String(userId) : '';
                const user = this.users.find(uu =>
                    (uid && uu.userId && String(uu.userId) === uid) ||
                    (u && (uu.username || '').toLowerCase() === u)
                );
                if (!user) return;
                if (user.muted) return;

                const element = document.getElementById(user.id);
                if (!element) return;
                const usernameLabel = element.querySelector('.username');
                if (!usernameLabel) return;

                // Remove existing chat message if any (cancel its timeouts so we don't restore username too early)
                const existingMessage = element.querySelector('.chat-message');
                if (existingMessage) {
                    if (existingMessage._timeoutId) clearTimeout(existingMessage._timeoutId);
                    if (existingMessage._restoreId) clearTimeout(existingMessage._restoreId);
                    existingMessage.remove();
                }
                const prevOpacity = usernameLabel.style.opacity;
                usernameLabel.style.opacity = '0';

                const chatMessage = document.createElement('div');
                chatMessage.className = 'chat-message';
                chatMessage.innerHTML = this.buildMessageWithEmotes(message, emotes);
                // Align the bubble to the username position (username top varies by sprite mode)
                try {
                    const t = window.getComputedStyle(usernameLabel).top;
                    if (t) chatMessage.style.top = t;
                    const z = window.getComputedStyle(usernameLabel).zIndex;
                    if (z) chatMessage.style.zIndex = z;
                } catch (e) { /* ignore */ }
                element.appendChild(chatMessage);

                setTimeout(() => chatMessage.classList.add('show'), 10);

                chatMessage._timeoutId = setTimeout(() => {
                    chatMessage.classList.remove('show');
                    chatMessage.classList.add('fade-out');
                    chatMessage._restoreId = setTimeout(() => {
                        chatMessage.remove();
                        usernameLabel.style.opacity = prevOpacity || '';
                    }, 250);
                }, 3000);
            }

            calculateNextAngle() {
                // If no users exist, start at angle 0
                if (this.users.length === 0) return 0;
                
                // Check if grouping is enabled (default: false for even distribution)
                const enableGrouping = this.settings.enableUserGrouping === true; // Must be explicitly true
                const minDistance = this.settings.userGroupingDistance || 15; // Minimum degrees between users (default 15¬∞)
                
                if (enableGrouping && this.users.length > 0) {
                    // Grouping mode: Find best spot near existing users
                    // Get all existing angles
                    const existingAngles = this.users.map(u => {
                        // Normalize angles to 0-360
                        let angle = u.angle;
                        if (angle < 0) angle += 360;
                        if (angle >= 360) angle -= 360;
                        return angle;
                    }).sort((a, b) => a - b);
                    
                    // Try to find a spot near existing users (within minDistance)
                    // First, try spots near each existing user
                    let bestAngle = null;
                    let bestScore = -1;
                    
                    for (let i = 0; i < existingAngles.length; i++) {
                        const baseAngle = existingAngles[i];
                        // Try angles on both sides of this user (¬±minDistance to ¬±minDistance*2)
                        for (const offset of [minDistance, -minDistance, minDistance * 1.5, -minDistance * 1.5]) {
                            let candidateAngle = baseAngle + offset;
                            // Normalize to 0-360
                            if (candidateAngle < 0) candidateAngle += 360;
                            if (candidateAngle >= 360) candidateAngle -= 360;
                            
                            // Check if this spot is valid (not too close to any existing user)
                            const isValid = existingAngles.every(existing => {
                                let diff = Math.abs(candidateAngle - existing);
                                if (diff > 180) diff = 360 - diff; // Wrap around
                                return diff >= minDistance;
                            });
                            
                            if (isValid) {
                                // Calculate score: closer to baseAngle = higher score
                                const distance = Math.min(Math.abs(offset), Math.abs(360 - Math.abs(offset)));
                                const score = 1 / (1 + distance); // Higher score for closer spots
                                if (score > bestScore) {
                                    bestScore = score;
                                    bestAngle = candidateAngle;
                                }
                            }
                        }
                    }
                    
                    // If we found a good grouping spot, use it
                    if (bestAngle !== null) {
                        return bestAngle;
                    }
                    // Otherwise, fall through to even distribution
                }
                
                // Even distribution mode (default): Distribute users evenly around circle
                // This prevents exact same locations by spacing them out
                const spacing = 360 / (this.users.length + 1);
                return spacing * this.users.length;
            }

            createUserElement(user) {
                const container = document.getElementById('circleContainer');
                const element = document.createElement('div');
                element.className = 'user-shape'; // Don't add 'entering' class yet - wait for sprite to load
                element.id = user.id;
                
                // Apply sprite size from settings
                const spriteSize = this.settings.spriteSize || 40;
                element.style.width = `${spriteSize}px`;
                element.style.height = `${spriteSize}px`;
                
                const shape = document.createElement('div');
                shape.className = 'shape';
                
                // Get viewer color for circle/circles sprites (saved color takes precedence, then Twitch color)
                // For other modes, this is less critical since sprites aren't colorized the same way
                const spriteMode = this.settings.spriteMode || 'circles';
                let viewerColor = (spriteMode === 'circle' || spriteMode === 'circles')
                    ? this.getCircleSpriteColor(user.username, user.userId)
                    : (user.color || this.getViewerColor(user.username, user.userId));
                
                // Save the color back to the user object for future reference
                if (viewerColor && !user.color) {
                    user.color = viewerColor;
                }
                
                // Get sprite for this user FIRST
                const spriteInfo = this.getUserSprite(user);
                
                // For sprites: Hide element initially until sprite loads
                // For fallback: Don't hide - show immediately
                const hasSprite = spriteInfo && spriteInfo.data;
                if (hasSprite) {
                    // CRITICAL: Hide element completely - use visibility AND opacity AND ensure no background shows
                    // Set these BEFORE appending to DOM to prevent any flash
                    element.style.display = 'none';
                    element.style.visibility = 'hidden';
                    element.style.opacity = '0';
                }
                
                // IMMEDIATELY clear all default styles to prevent circle from showing
                // Do this BEFORE checking if sprite exists, so no circle shows during loading
                shape.style.background = 'transparent';
                shape.style.backgroundColor = 'transparent';
                shape.style.backgroundImage = 'none';
                shape.style.border = 'none';
                shape.style.borderRadius = '0';
                shape.style.boxShadow = 'none';
                shape.style.outline = 'none';
                shape.style.borderColor = 'transparent';
                shape.style.borderWidth = '0';
                shape.style.borderStyle = 'none';
                // Force remove any CSS border/outline that might be showing
                shape.style.setProperty('background', 'transparent', 'important');
                shape.style.setProperty('border', 'none', 'important');
                shape.style.setProperty('outline', 'none', 'important');
                
                if (spriteInfo && spriteInfo.data) {
                    // Shape is already cleared above - sprite will be added next
                    shape.style.background = 'transparent';
                    shape.style.backgroundColor = 'transparent';
                    shape.style.backgroundImage = 'none';
                    shape.style.border = 'none';
                    shape.style.borderRadius = '0';
                    shape.style.boxShadow = 'none';
                    shape.style.outline = 'none';
                    // Force remove with important
                    shape.style.setProperty('background', 'transparent', 'important');
                    shape.style.setProperty('border', 'none', 'important');
                    shape.style.setProperty('outline', 'none', 'important');
                    
                    // Use sprite - create img element for GIF animation control
                    const spriteImg = document.createElement('img');
                    spriteImg.style.width = '100%';
                    spriteImg.style.height = '100%';
                    spriteImg.style.objectFit = 'contain';
                    spriteImg.style.objectPosition = 'center';
                    spriteImg.style.display = 'block';
                    spriteImg.style.boxShadow = 'none';
                    spriteImg.style.border = 'none';
                    spriteImg.style.borderRadius = '0';
                    spriteImg.style.overflow = 'visible';
                    
                    // Check if it's an SVG (fallback circle) - make it pixelated/low-res
                    if (spriteInfo.data && spriteInfo.data.includes('data:image/svg+xml')) {
                        spriteImg.style.imageRendering = 'pixelated';
                        spriteImg.style.imageRendering = '-moz-crisp-edges';
                        spriteImg.style.imageRendering = 'crisp-edges';
                    }
                    
                    // Apply colorization if needed (for circle and morph modes)
                    if (spriteInfo.colorize && spriteInfo.color) {
                        spriteImg.style.filter = `brightness(0) saturate(100%) ${this.colorToFilter(spriteInfo.color)}`;
                    } else {
                        spriteImg.style.filter = 'none';
                    }
                    
                    // Set up sprite to start invisible - will be shown only after it loads
                    spriteImg.style.opacity = '0';
                    // Don't use transition - let the element's popIn animation handle the appearance
                    
                    // Store reference to element on spriteImg so onload handler can access it
                    spriteImg._element = element;
                    spriteImg._shape = shape;
                    spriteImg._spriteMode = this.settings.spriteMode || 'circles';
                    
                        // Function to show element after sprite is ready
                        let showElementWithSprite = () => {
                            // Make sprite fully visible immediately (no transition) - element animation handles the effect
                            spriteImg.style.opacity = '1';
                            // Double-check background is transparent when sprite loads successfully
                            shape.style.background = 'transparent';
                            shape.style.backgroundColor = 'transparent';
                            shape.style.backgroundImage = 'none';
                            shape.style.border = 'none';
                            shape.style.outline = 'none';
                            // Force remove border/outline with important
                            shape.style.setProperty('border', 'none', 'important');
                            shape.style.setProperty('outline', 'none', 'important');
                            
                            // Only show element and start entering animation AFTER sprite loads
                            const elem = spriteImg._element;
                            if (elem) {
                                // Check if element was already visible (i.e., this is an update, not a new user)
                                const wasVisible = elem.style.visibility === 'visible' || 
                                                 elem.style.display === '' || 
                                                 elem.classList.contains('idle') ||
                                                 elem.classList.contains('entering');
                                
                                if (!wasVisible) {
                                    // NEW user: add 'entering' BEFORE showing so popIn 0% (opacity 0) applies on first paint.
                                    // If we show first and add 'entering' later, 1‚Äì2 frames render at full opacity = flash.
                                    elem.classList.add('entering');
                                    elem.style.opacity = ''; // no inline opacity; popIn controls it
                                    elem.style.display = '';
                                    elem.style.visibility = 'visible';
                                    // Remove entering after animation and add idle
                                    setTimeout(() => {
                                        if (elem && elem.classList.contains('entering')) {
                                            elem.classList.remove('entering');
                                            const spriteMode = spriteImg._spriteMode || 'circles';
                                            if (spriteMode !== 'rpg-characters') {
                                                elem.classList.add('idle');
                                                const randomDelay = Math.random() * 3;
                                                elem.style.animationDelay = `${randomDelay}s`;
                                            }
                                        }
                                    }, 500);
                                } else {
                                    // Update: restore visibility without animation
                                    elem.style.display = '';
                                    elem.style.visibility = 'visible';
                                    elem.style.opacity = '1';
                                    // For updates, just ensure idle animation is present (if appropriate)
                                    const spriteMode = spriteImg._spriteMode || 'circles';
                                    if (spriteMode !== 'rpg-characters' && !elem.classList.contains('idle')) {
                                        elem.classList.add('idle');
                                        const randomDelay = Math.random() * 3;
                                        elem.style.animationDelay = `${randomDelay}s`;
                                    }
                                }
                            }
                        };
                    
                    // Handle successful sprite load
                    spriteImg.onload = showElementWithSprite;
                    
                    // Handle image load errors
                    spriteImg.onerror = () => {
                        console.error(`[createUserElement] Failed to load sprite for ${user.username}`);
                        spriteImg.remove();
                        shape._spriteImg = null;
                        // Fall back to default shape ONLY if sprite actually failed to load
                        // Make sure to clear any sprite-related styles first
                        shape.style.backgroundImage = 'none';
                        shape.style.background = `linear-gradient(135deg, ${viewerColor || '#667eea'} 0%, ${this.adjustColor(viewerColor || '#667eea', -20)} 100%)`;
                        shape.style.border = '2px solid rgba(255, 255, 255, 0.8)';
                        shape.style.borderRadius = '50%';
                        shape.style.filter = 'none';
                        shape.style.outline = 'none'; // Still remove outline
                        
                        // Show element with fallback shape - sprite failed, show default circle
                        const elem = spriteImg._element;
                        if (elem) {
                            // Always show fallback, even if element was already visible
                            elem.style.display = '';
                            elem.style.visibility = 'visible';
                            elem.style.opacity = '1';
                            elem.classList.add('entering');
                            setTimeout(() => {
                                if (elem && elem.classList.contains('entering')) {
                                    elem.classList.remove('entering');
                                    const spriteMode = spriteImg._spriteMode || 'circle';
                                    if (spriteMode !== 'rpg-characters') {
                                        elem.classList.add('idle');
                                        const randomDelay = Math.random() * 3;
                                        elem.style.animationDelay = `${randomDelay}s`;
                                    }
                                }
                            }, 500);
                        }
                    };
                    
                    // Store reference to img and add to DOM immediately
                    // This allows the entering animation to play while sprite loads
                    shape._spriteImg = spriteImg;
                    shape.appendChild(spriteImg);
                    
                    // NO MORE STAGGERED DELAYS - they cause issues when users are added sequentially
                    // SVG data URLs load instantly anyway, GIFs load async via blob URLs
                    // Just use a simple incremental delay for GIF desynchronization only
                    const loadIndex = Date.now(); // Use timestamp for uniqueness instead of counter
                    const randomSeed = Math.floor(Math.random() * 1000000); // Unique seed per load
                    
                    // DEFER sprite loading until AFTER element is in DOM
                    // Store the loading function to be called later
                    element._loadSpriteFunction = () => {
                        // Load sprite with staggered delay to prevent race conditions
                        const loadSprite = () => {
                            // Check if it's a data URL
                            if (spriteInfo.data.startsWith('data:')) {
                                // Check if it's SVG - SVG data URLs work fine directly, no need for blob conversion
                                // (Blob conversion is only needed for GIFs to desynchronize animations)
                                if (spriteInfo.data.includes('data:image/svg+xml')) {
                                    // SVG data URL - loads synchronously, show IMMEDIATELY
                                    // CRITICAL: Disable onload handler FIRST to prevent race condition
                                    // The onload handler sets opacity to 0 then uses RAF which can fail
                                    spriteImg.onload = null;
                                    
                                    spriteImg.src = spriteInfo.data;
                                    console.log(`[createUserElement] SVG set for ${user.username}, showing immediately`);
                                    
                                    // Show sprite immediately
                                    spriteImg.style.opacity = '1';
                                    
                                    // Clear background to ensure only sprite shows
                                    shape.style.background = 'transparent';
                                    shape.style.backgroundColor = 'transparent';
                                    shape.style.backgroundImage = 'none';
                                    shape.style.border = 'none';
                                    shape.style.outline = 'none';
                                    shape.style.setProperty('border', 'none', 'important');
                                    shape.style.setProperty('outline', 'none', 'important');
                                    
                                    // Use the element reference directly from closure (guaranteed correct)
                                    // Don't rely on document.getElementById which can fail
                                    const elem = element; // Direct reference from closure
                                    console.log(`[createUserElement] Showing element for ${user.username} directly`);
                                    elem.style.display = '';
                                    elem.style.visibility = 'visible';
                                    elem.style.opacity = '1';
                                    elem.classList.add('entering');
                                    
                                    // Remove entering animation after it completes
                                    setTimeout(() => {
                                        if (elem && elem.classList.contains('entering')) {
                                            elem.classList.remove('entering');
                                            const spriteMode = spriteImg._spriteMode || 'circles';
                                            if (spriteMode !== 'rpg-characters') {
                                                elem.classList.add('idle');
                                                const randomDelay = Math.random() * 3;
                                                elem.style.animationDelay = `${randomDelay}s`;
                                            }
                                        }
                                    }, 500);
                                    
                                    // Clear timeout since we're showing immediately
                                    if (loadTimeout) clearTimeout(loadTimeout);
                                } else {
                                    // GIF or other data URL - convert to blob URL for cache-busting and desync
                                    fetch(spriteInfo.data)
                                        .then(response => response.blob())
                                        .then(blob => {
                                            const blobUrl = URL.createObjectURL(blob);
                                            spriteImg.src = blobUrl;
                                            // Store blob URL for cleanup later
                                            spriteImg._blobUrl = blobUrl;
                                            // Check if already loaded
                                            setTimeout(() => {
                                                if (spriteImg.complete && spriteImg.naturalWidth > 0 && spriteImg.naturalHeight > 0) {
                                                    showElementWithSprite();
                                                }
                                            }, 10);
                                        })
                                        .catch(error => {
                                            console.error(`[createUserElement] Failed to convert data URL to blob for ${user.username}:`, error);
                                            // Fallback to using data URL directly
                                            spriteImg.src = spriteInfo.data;
                                            setTimeout(() => {
                                                if (spriteImg.complete && spriteImg.naturalWidth > 0 && spriteImg.naturalHeight > 0) {
                                                    showElementWithSprite();
                                                }
                                            }, 10);
                                        });
                                }
                            } else {
                                // For regular URLs, add cache-busting parameters
                                const separator = spriteInfo.data.includes('?') ? '&' : '?';
                                spriteImg.src = spriteInfo.data + separator + 't=' + randomSeed + '&r=' + Date.now();
                                // Check if image is already loaded (cached) - must check AFTER setting src
                                checkImageLoaded();
                            }
                        };
                        
                        // Check if sprite is already loaded (cached images)
                        const checkImageLoaded = () => {
                            // Use setTimeout to allow browser to set complete/naturalWidth
                            setTimeout(() => {
                                if (spriteImg.complete && spriteImg.naturalWidth > 0 && spriteImg.naturalHeight > 0) {
                                    // Image is already loaded (cached), show immediately
                                    showElementWithSprite();
                                }
                            }, 10); // Small delay to ensure browser has set the properties
                        };
                        
                        // Fallback timeout - if sprite doesn't load within 3 seconds AFTER load starts, show with fallback
                        let loadTimeout = null;
                        
                        // Clear timeout when sprite loads successfully
                        const originalShowElement = showElementWithSprite;
                        showElementWithSprite = () => {
                            if (loadTimeout) clearTimeout(loadTimeout);
                            originalShowElement();
                        };
                        
                        // Store reference to this specific sprite load to prevent conflicts
                        spriteImg._loadIndex = loadIndex;
                        
                        // Start the timeout when sprite load begins (3 second fallback)
                        loadTimeout = setTimeout(() => {
                            const elem = spriteImg._element;
                            if (elem) {
                                // Sprite didn't load in time - show error or fallback
                                console.warn(`[createUserElement] Sprite load timeout for ${user.username}, showing fallback`);
                                // Try to show element even if sprite failed
                                if (spriteImg.complete && spriteImg.naturalWidth > 0) {
                                    // Image exists - try showing
                                    showElementWithSprite();
                                } else if (spriteImg.onerror) {
                                    // Sprite never loaded - trigger error handler
                                    spriteImg.onerror();
                                }
                            }
                        }, 3000);
                        
                        // ALWAYS call loadSprite - no conditions that could fail
                        loadSprite();
                    };
                    
                    // Clear background-image if it exists (already cleared above, but ensure it stays clear)
                    shape.style.backgroundImage = 'none';
                    shape.style.backgroundSize = 'none';
                    shape.style.backgroundPosition = 'none';
                    shape.style.backgroundRepeat = 'none';
                    shape.style.boxShadow = 'none';
                    shape.style.overflow = 'visible';
                    shape.style.outline = 'none'; // Ensure no outline
                    // Force remove with important to override any CSS
                    shape.style.setProperty('outline', 'none', 'important');
                    shape.style.setProperty('border', 'none', 'important');
                    shape.style.setProperty('border-color', 'transparent', 'important');
                }
                
                // Fallback: no sprite or invalid sprite data
                // ONLY apply fallback styles if there's NO sprite
                if (!hasSprite) {
                    // Show default colored circle (only if no sprite was found)
                    const shapeStyle = this.settings.shapeStyle || 'circle';
                    if (shapeStyle === 'square') {
                        shape.style.borderRadius = '4px';
                    } else {
                        shape.style.borderRadius = '50%';
                    }
                    // Apply color to default shape (only if no sprite was found)
                    if (viewerColor) {
                        shape.style.backgroundImage = 'none';
                        shape.style.background = `linear-gradient(135deg, ${viewerColor} 0%, ${this.adjustColor(viewerColor, -20)} 100%)`;
                        shape.style.setProperty('border', '2px solid rgba(255, 255, 255, 0.8)', 'important');
                        // Only show border if we're actually using the fallback circle
                        shape.style.outline = 'none'; // Still remove outline
                    }
                    shape.style.filter = 'none';
                }
                
                const usernameLabel = document.createElement('div');
                usernameLabel.className = 'username';
                usernameLabel.textContent = user.username;
                
                // Adjust username position and color based on sprite mode (spriteMode already declared earlier)
                if (spriteMode === 'rpg-characters') {
                    usernameLabel.style.top = '35px'; // Much lower position for RPG sprites (below sprite)
                    // RPG mode: use Twitch color with black stroke
                    const twitchColor = this.getTwitchColor(user.username, user.userId);
                    usernameLabel.style.color = twitchColor;
                } else if (spriteMode === 'pixel-morphs') {
                    usernameLabel.style.top = '-25px'; // Default position for morph sprites
                    // MORPH mode: use Twitch color with black stroke
                    const twitchColor = this.getTwitchColor(user.username, user.userId);
                    usernameLabel.style.color = twitchColor;
                } else {
                    // CIRCLE/CIRCLES mode: use Twitch username color (or hash fallback) like other modes
                    usernameLabel.style.top = '-25px'; // Default position for circle/circles sprites
                    const twitchColor = this.getTwitchColor(user.username, user.userId);
                    usernameLabel.style.color = twitchColor;
                }
                
                // Check if username overlaps with sprite and make transparent if needed
                this.checkUsernameOverlap(usernameLabel, user);
                
                element.appendChild(shape);
                element.appendChild(usernameLabel);
                
                // Hide element initially - will be shown after sprite loads (if sprite exists)
                // For fallback shapes (no sprite), show immediately
                // hasSprite is already declared earlier in this function
                if (hasSprite) {
                    // Completely hide element until sprite loads - use display: none BEFORE appending
                    // This prevents any flash of empty square
                    element.style.display = 'none';
                    // Also ensure shape has no background that could show through
                    shape.style.background = 'transparent';
                    shape.style.backgroundColor = 'transparent';
                    shape.style.border = 'none';
                } else {
                    // No sprite - show element immediately with entering animation
                    element.style.opacity = '1';
                    element.classList.add('entering');
                    // Remove entering animation class after animation and add idle (gentle float)
                    setTimeout(() => {
                        element.classList.remove('entering');
                        const spriteMode = this.settings.spriteMode || 'circle';
                        if (spriteMode !== 'rpg-characters') {
                            element.classList.add('idle'); // This applies the gentle float animation
                            // Add random animation delay so sprites don't float in sync
                            const randomDelay = Math.random() * 3; // 0-3 seconds random delay
                            element.style.animationDelay = `${randomDelay}s`;
                        }
                    }, 500);
                }
                
                // Append element to DOM
                container.appendChild(element);
                this.positionUserElement(user);
                
                // NOW that element is in DOM, load the sprite IMMEDIATELY
                // appendChild is synchronous - element IS in DOM now, no need to wait
                if (element._loadSpriteFunction) {
                    element._loadSpriteFunction();
                    delete element._loadSpriteFunction; // Clean up
                }
                
                // For sprites: Element is hidden, will be shown in spriteImg.onload
                // For fallback (no sprite): Show immediately with entering animation
                if (!hasSprite) {
                    // No sprite - show element immediately with entering animation
                    element.style.display = '';
                    element.style.visibility = 'visible';
                    element.style.opacity = '1';
                    element.classList.add('entering');
                    // Remove entering animation class after animation and add idle (gentle float)
                    setTimeout(() => {
                        element.classList.remove('entering');
                        const spriteMode = this.settings.spriteMode || 'circle';
                        if (spriteMode !== 'rpg-characters') {
                            element.classList.add('idle'); // This applies the gentle float animation
                            // Add random animation delay so sprites don't float in sync
                            const randomDelay = Math.random() * 3; // 0-3 seconds random delay
                            element.style.animationDelay = `${randomDelay}s`;
                        }
                    }, 500);
                }
                // If hasSprite: Element stays hidden until spriteImg.onload shows it
            }

            updateUserElement(user) {
                // Update existing user element with new data
                const element = document.getElementById(user.id);
                if (!element) return;
                // Don't update during exit animation
                if (element.classList.contains('leaving')) return;

                // Get updated color for circle/circles sprites (saved color takes precedence, then Twitch color)
                const spriteMode = this.settings.spriteMode || 'circles';
                let viewerColor = (spriteMode === 'circle' || spriteMode === 'circles')
                    ? this.getCircleSpriteColor(user.username, user.userId)
                    : (user.color || this.getViewerColor(user.username, user.userId));
                
                // Save the color back to the user object for future reference
                if (viewerColor && !user.color) {
                    user.color = viewerColor;
                }
                
                const shape = element.querySelector('.shape');
                const usernameLabel = element.querySelector('.username');

                if (shape) {
                    // Get sprite for this user
                    const spriteInfo = this.getUserSprite(user);
                    
                    if (spriteInfo && spriteInfo.data) {
                        // Capture if user was already visible BEFORE hiding (to skip entering animation on mere updates)
                        // Include 'moving' so NPCs mid-walk don't get mistaken for new and re-animate
                        const skipEnteringAnimation = element.classList.contains('idle') || element.classList.contains('entering') || element.classList.contains('moving');
                        
                        // CRITICAL: Hide element completely BEFORE removing old sprite and loading new one
                        // This prevents empty squares from being visible during sprite swap
                        element.style.display = 'none';
                        element.style.visibility = 'hidden';
                        element.style.opacity = '0';
                        
                        // Remove default background and border from shape when using sprites
                        // IMPORTANT: Clear ALL background properties to prevent circle from showing
                        shape.style.background = 'transparent';
                        shape.style.backgroundColor = 'transparent';
                        shape.style.backgroundImage = 'none';
                        shape.style.border = 'none';
                        shape.style.borderRadius = '0';
                        shape.style.boxShadow = 'none';
                        shape.style.outline = 'none';
                        // Force remove with important
                        shape.style.setProperty('background', 'transparent', 'important');
                        shape.style.setProperty('border', 'none', 'important');
                        shape.style.setProperty('outline', 'none', 'important');
                        
                        // Always remove existing img to ensure clean state
                        const existingImg = shape.querySelector('img');
                        if (existingImg) {
                            // Clean up blob URL if it exists
                            if (existingImg._blobUrl) {
                                URL.revokeObjectURL(existingImg._blobUrl);
                            }
                            existingImg.remove();
                            shape._spriteImg = null;
                        }
                        
                        // Create new img element
                        const spriteImg = document.createElement('img');
                        spriteImg.style.width = '100%';
                        spriteImg.style.height = '100%';
                        spriteImg.style.objectFit = 'contain';
                        spriteImg.style.objectPosition = 'center';
                        spriteImg.style.display = 'block';
                        spriteImg.style.boxShadow = 'none';
                        spriteImg.style.border = 'none';
                        spriteImg.style.borderRadius = '0';
                        spriteImg.style.overflow = 'visible';
                        
                        // Check if it's an SVG (fallback circle) - make it pixelated/low-res
                        if (spriteInfo.data && spriteInfo.data.includes('data:image/svg+xml')) {
                            spriteImg.style.imageRendering = 'pixelated';
                            spriteImg.style.imageRendering = '-moz-crisp-edges';
                            spriteImg.style.imageRendering = 'crisp-edges';
                        }
                        
                        // Apply colorization if needed (for circle and morph modes)
                        if (spriteInfo.colorize && spriteInfo.color) {
                            spriteImg.style.filter = `brightness(0) saturate(100%) ${this.colorToFilter(spriteInfo.color)}`;
                        } else {
                            spriteImg.style.filter = 'none';
                        }
                        
                        // Set up sprite to start invisible - will be shown only after it loads
                        spriteImg.style.opacity = '0';
                        // Don't use transition - let the element's popIn animation handle the appearance
                        
                        // Store reference to element on spriteImg so onload handler can access it
                        spriteImg._element = element;
                        spriteImg._shape = shape;
                        spriteImg._spriteMode = this.settings.spriteMode || 'circles';
                        
                        // Function to show element after sprite is ready
                        let showElementWithSprite = () => {
                            // Make sprite fully visible immediately (no transition) - element animation handles the effect
                            spriteImg.style.opacity = '1';
                            // Double-check background is transparent when sprite loads successfully
                            shape.style.background = 'transparent';
                            shape.style.backgroundColor = 'transparent';
                            shape.style.backgroundImage = 'none';
                            shape.style.border = 'none';
                            shape.style.outline = 'none';
                            // Force remove border/outline with important
                            shape.style.setProperty('border', 'none', 'important');
                            shape.style.setProperty('outline', 'none', 'important');
                            
                            // Show element now that sprite is loaded - restore visibility
                            if (element) {
                                element.style.display = '';
                                element.style.visibility = 'visible';
                                
                                if (skipEnteringAnimation) {
                                    // Just restore visibility, no entering animation (user was already on screen)
                                    element.style.opacity = '1';
                                    if (!element.classList.contains('idle') && !element.classList.contains('moving')) {
                                        element.classList.add('idle');
                                        const randomDelay = Math.random() * 3;
                                        element.style.animationDelay = `${randomDelay}s`;
                                    }
                                } else {
                                    // New or was hidden - use entering animation
                                    element.style.opacity = '';
                                    requestAnimationFrame(() => {
                                        requestAnimationFrame(() => {
                                            element.classList.add('entering');
                                            setTimeout(() => {
                                                if (element && element.classList.contains('entering')) {
                                                    element.classList.remove('entering');
                                                    const spriteMode = spriteImg._spriteMode || 'circles';
                                                    if (spriteMode !== 'rpg-characters') {
                                                        element.classList.add('idle');
                                                        const randomDelay = Math.random() * 3;
                                                        element.style.animationDelay = `${randomDelay}s`;
                                                    }
                                                }
                                            }, 500);
                                        });
                                    });
                                }
                            }
                        };
                        
                        // Handle image load errors
                        spriteImg.onerror = () => {
                            console.error(`[updateUserElement] Failed to load sprite for ${user.username}`);
                            spriteImg.remove();
                            shape._spriteImg = null;
                            // Fall back to default shape ONLY if sprite actually failed to load
                            // Make sure to clear any sprite-related styles first
                            shape.style.backgroundImage = 'none';
                            shape.style.background = `linear-gradient(135deg, ${viewerColor || '#667eea'} 0%, ${this.adjustColor(viewerColor || '#667eea', -20)} 100%)`;
                            shape.style.border = '2px solid rgba(255, 255, 255, 0.8)';
                            shape.style.borderRadius = '50%';
                            shape.style.filter = 'none';
                            
                            // Show element with fallback shape - sprite failed, show default circle
                            if (element) {
                                element.style.display = '';
                                element.style.visibility = 'visible';
                                if (skipEnteringAnimation) {
                                    element.style.opacity = '1';
                                    if (!element.classList.contains('idle') && !element.classList.contains('moving')) {
                                        element.classList.add('idle');
                                        const randomDelay = Math.random() * 3;
                                        element.style.animationDelay = `${randomDelay}s`;
                                    }
                                } else {
                                    element.classList.add('entering');
                                    requestAnimationFrame(() => {
                                        requestAnimationFrame(() => {
                                            setTimeout(() => {
                                                if (element && element.classList.contains('entering')) {
                                                    element.classList.remove('entering');
                                                    const spriteMode = spriteImg._spriteMode || 'circles';
                                                    if (spriteMode !== 'rpg-characters') {
                                                    element.classList.add('idle');
                                                    const randomDelay = Math.random() * 3;
                                                    element.style.animationDelay = `${randomDelay}s`;
                                                    }
                                                }
                                            }, 500);
                                        });
                                    });
                                }
                            }
                        };
                        
                        // Handle successful sprite load - show element with animation
                        spriteImg.onload = showElementWithSprite;
                        
                        shape._spriteImg = spriteImg;
                        shape.appendChild(spriteImg);
                        
                        const randomSeed = Math.floor(Math.random() * 1000000); // Random cache-busting seed
                        
                        // Declare loadTimeout variable first so it's in scope for all functions
                        let loadTimeout = null;
                        
                        // Check if image is already loaded (cached images)
                        const checkImageLoaded = () => {
                            // Use setTimeout to allow browser to set complete/naturalWidth
                            setTimeout(() => {
                                if (spriteImg.complete && spriteImg.naturalWidth > 0 && spriteImg.naturalHeight > 0) {
                                    // Image is already loaded (cached), show immediately
                                    if (loadTimeout) clearTimeout(loadTimeout);
                                    showElementWithSprite();
                                }
                            }, 50); // Increased delay to ensure browser has set the properties
                        };
                        
                        // Load sprite immediately (no delays in update path)
                        const loadSprite = () => {
                            // Check if it's a data URL
                            if (spriteInfo.data.startsWith('data:')) {
                                // SVG data URL - show immediately, avoid onload race
                                if (spriteInfo.data.includes('data:image/svg+xml')) {
                                    spriteImg.onload = null;
                                    spriteImg.src = spriteInfo.data;
                                    spriteImg.style.opacity = '1';
                                    
                                    shape.style.background = 'transparent';
                                    shape.style.backgroundColor = 'transparent';
                                    shape.style.backgroundImage = 'none';
                                    shape.style.border = 'none';
                                    shape.style.outline = 'none';
                                    shape.style.setProperty('border', 'none', 'important');
                                    shape.style.setProperty('outline', 'none', 'important');
                                    
                                    element.style.display = '';
                                    element.style.visibility = 'visible';
                                    element.style.opacity = '1';
                                    element.classList.add('entering');
                                    
                                    setTimeout(() => {
                                        if (element && element.classList.contains('entering')) {
                                            element.classList.remove('entering');
                                            const spriteMode = spriteImg._spriteMode || 'circles';
                                            if (spriteMode !== 'rpg-characters') {
                                                element.classList.add('idle');
                                                const randomDelay = Math.random() * 3;
                                                element.style.animationDelay = `${randomDelay}s`;
                                            }
                                        }
                                    }, 500);
                                    return;
                                }
                                
                                // GIF or other data URL - convert to blob for cache-busting/desync
                                fetch(spriteInfo.data)
                                    .then(response => response.blob())
                                    .then(blob => {
                                        const blobUrl = URL.createObjectURL(blob);
                                        spriteImg.src = blobUrl;
                                        spriteImg._blobUrl = blobUrl;
                                        checkImageLoaded();
                                    })
                                    .catch(error => {
                                        console.error(`[updateUserElement] Failed to convert data URL to blob for ${user.username}:`, error);
                                        spriteImg.src = spriteInfo.data;
                                        checkImageLoaded();
                                    });
                            } else {
                                // For regular URLs, add cache-busting parameters
                                const separator = spriteInfo.data.includes('?') ? '&' : '?';
                                spriteImg.src = spriteInfo.data + separator + 't=' + randomSeed + '&r=' + Date.now();
                                checkImageLoaded();
                            }
                        };
                        
                        // Fallback timeout - ensure element is shown even if sprite fails
                        loadTimeout = setTimeout(() => {
                            if (element && element.style.display === 'none') {
                                console.warn(`[updateUserElement] Sprite load timeout for ${user.username}, showing element anyway`);
                                // Force show element - sprite may have loaded but onload didn't fire
                                element.style.display = '';
                                element.style.visibility = 'visible';
                                element.style.opacity = '1';
                                if (!element.classList.contains('entering')) {
                                    element.classList.add('entering');
                                }
                                setTimeout(() => {
                                    if (element && element.classList.contains('entering')) {
                                        element.classList.remove('entering');
                                        const spriteMode = this.settings.spriteMode || 'circle';
                                        if (spriteMode !== 'rpg-characters') {
                                            element.classList.add('idle');
                                        }
                                    }
                                }, 500);
                            }
                            // Also check for actual fallback needed
                            if (element && !shape.querySelector('img') && !shape.style.backgroundImage) {
                                console.warn(`[updateUserElement] Sprite failed for ${user.username}, showing fallback`);
                                if (spriteImg.complete && spriteImg.naturalWidth > 0) {
                                    showElementWithSprite();
                                } else if (spriteImg.onerror) {
                                    spriteImg.onerror();
                                }
                            }
                        }, 3000);
                        
                        const originalShowElement = showElementWithSprite;
                        showElementWithSprite = () => {
                            clearTimeout(loadTimeout);
                            originalShowElement();
                        };
                        
                        // Always load immediately
                        loadSprite();
                        
                        // Clear background-image if it exists (from old code)
                        shape.style.backgroundImage = 'none';
                        shape.style.backgroundSize = 'none';
                        shape.style.backgroundPosition = 'none';
                        shape.style.backgroundRepeat = 'none';
                        shape.style.background = 'transparent';
                        shape.style.backgroundColor = 'transparent';
                        shape.style.boxShadow = 'none';
                        shape.style.border = 'none';
                        shape.style.borderRadius = '0';
                        shape.style.overflow = 'visible';
                    } else {
                        // Fallback: no sprite or invalid sprite data
                        // Remove any img element if present
                        const existingImgFallback = shape.querySelector('img');
                        if (existingImgFallback) {
                            existingImgFallback.remove();
                            shape._spriteImg = null;
                        }
                        // Show default colored circle
                        if (viewerColor) {
                            shape.style.backgroundImage = 'none';
                            shape.style.background = `linear-gradient(135deg, ${viewerColor} 0%, ${this.adjustColor(viewerColor, -20)} 100%)`;
                            shape.style.border = '2px solid rgba(255, 255, 255, 0.8)';
                            shape.style.borderRadius = '50%';
                            shape.style.filter = 'none';
                        }
                        // CRITICAL: Show element even if sprite failed - ensure visibility
                        element.style.display = '';
                        element.style.visibility = 'visible';
                        element.style.opacity = '1';
                        element.classList.add('entering');
                        setTimeout(() => {
                            if (element && element.classList.contains('entering')) {
                                element.classList.remove('entering');
                                const spriteMode = this.settings.spriteMode || 'circles';
                                if (spriteMode !== 'rpg-characters') {
                                    element.classList.add('idle');
                                }
                            }
                        }, 500);
                    }
                }

                if (usernameLabel) {
                    // Adjust username position and color based on sprite mode
                    const spriteMode = this.settings.spriteMode || 'circles';
                    if (spriteMode === 'rpg-characters') {
                        usernameLabel.style.top = '35px'; // Much lower position for RPG sprites (below sprite)
                        // RPG mode: use Twitch color with black stroke
                        const twitchColor = this.getTwitchColor(user.username, user.userId);
                        usernameLabel.style.color = twitchColor;
                    } else if (spriteMode === 'pixel-morphs') {
                        usernameLabel.style.top = '-25px'; // Default position for morph sprites
                        // MORPH mode: use Twitch color with black stroke
                        const twitchColor = this.getTwitchColor(user.username, user.userId);
                        usernameLabel.style.color = twitchColor;
                    } else {
                        // CIRCLE/CIRCLES mode: use Twitch username color (or hash fallback) like other modes
                        usernameLabel.style.top = '-25px'; // Default position for circle/circles sprites
                        const twitchColor = this.getTwitchColor(user.username, user.userId);
                        usernameLabel.style.color = twitchColor;
                    }
                    // Username z-index and opacity will be updated in positionUserElement
                    // Recheck overlap after color update
                    this.checkUsernameOverlap(usernameLabel, user);

                    // Keep any visible chat bubble anchored to the username position
                    const chatMessage = element.querySelector('.chat-message');
                    if (chatMessage) {
                        try {
                            chatMessage.style.top = window.getComputedStyle(usernameLabel).top;
                            chatMessage.style.zIndex = window.getComputedStyle(usernameLabel).zIndex;
                        } catch (e) { /* ignore */ }
                    }
                }

                // Reposition if angle changed
                this.positionUserElement(user);
            }

            getViewerColor(username, userId) {
                // Try to get viewer color from localStorage
                let viewerColors = {};
                try {
                    const saved = localStorage.getItem('allViewerColors');
                    if (saved) viewerColors = JSON.parse(saved);
                } catch (e) {}

                // Check by userId first, then username
                if (userId && viewerColors[userId]) {
                    return viewerColors[userId].color;
                }

                // Check by username
                for (const key in viewerColors) {
                    if (viewerColors[key].username === username || viewerColors[key].displayName === username) {
                        return viewerColors[key].color;
                    }
                }

                // Return null to use default (Twitch username color would be applied by chat API)
                return null;
            }
            
            getTwitchColor(username, userId) {
                // Prefer real Twitch color when we have it (from tags.color)
                const u = this.users.find(uu =>
                    (userId && uu.userId && String(uu.userId) === String(userId)) ||
                    (username && (uu.username || '').toLowerCase() === (username || '').toLowerCase())
                );
                if (u && u.twitchColor && /^#?[0-9A-Fa-f]{6}$/.test(String(u.twitchColor).replace(/^#/, ''))) {
                    const c = String(u.twitchColor);
                    return c.startsWith('#') ? c : '#' + c;
                }
                // Fallback: deterministic hash from username
                let hash = 0;
                const nameToHash = username || '';
                for (let i = 0; i < nameToHash.length; i++) {
                    hash = nameToHash.charCodeAt(i) + ((hash << 5) - hash);
                }
                
                // Convert hash to HSL hue (0-360), then to hex
                const hue = Math.abs(hash % 360);
                const saturation = 70;
                const lightness = 60;
                
                // Convert HSL to RGB to Hex
                const h = hue / 360;
                const s = saturation / 100;
                const l = lightness / 100;
                
                let r, g, b;
                if (s === 0) {
                    r = g = b = l;
                } else {
                    const hue2rgb = (p, q, t) => {
                        if (t < 0) t += 1;
                        if (t > 1) t -= 1;
                        if (t < 1/6) return p + (q - p) * 6 * t;
                        if (t < 1/2) return q;
                        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                        return p;
                    };
                    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                    const p = 2 * l - q;
                    r = hue2rgb(p, q, h + 1/3);
                    g = hue2rgb(p, q, h);
                    b = hue2rgb(p, q, h - 1/3);
                }
                
                const toHex = (n) => {
                    const hex = Math.round(n * 255).toString(16);
                    return hex.length === 1 ? '0' + hex : hex;
                };
                
                return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
            }
            
            getCircleSpriteColor(username, userId) {
                // Get color for circle SPRITES (not usernames)
                // Custom saved color takes precedence, then Twitch color, then default
                
                // First check for saved custom color (only applies to circle sprites)
                let viewerColors = {};
                try {
                    const saved = localStorage.getItem('allViewerColors');
                    if (saved) viewerColors = JSON.parse(saved);
                } catch (e) {}

                // Check by userId first, then username
                if (userId && viewerColors[userId]) {
                    return viewerColors[userId].color;
                }

                // Check by username
                for (const key in viewerColors) {
                    if (viewerColors[key].username === username || viewerColors[key].displayName === username) {
                        return viewerColors[key].color;
                    }
                }
                
                // No saved color - use Twitch color (deterministic hash-based)
                return this.getTwitchColor(username, userId);
            }

            updateUserColor(user) {
                const el = document.getElementById(user.id);
                const shape = el?.querySelector('.shape');
                if (!shape) return;
                const mode = this.settings.spriteMode || 'circle';
                const c = user.color || this.getCircleSpriteColor(user.username, user.userId) || this.getViewerColor(user.username, user.userId) || '#bf94ff';
                if (mode === 'circle' || mode === 'circles') {
                    shape.style.background = `linear-gradient(135deg, ${c} 0%, ${this.adjustColor(c, -20)} 100%)`;
                    shape.style.backgroundImage = shape.style.backgroundImage || 'none';
                } else if (mode === 'pixel-morphs') {
                    shape.style.filter = this.colorToFilter(c);
                }
            }

            updateUserSprite(user) {
                // Sprite changes need to trigger full reload via updateUserElement to:
                // 1) Properly load RPG sprites (which use <img> elements, not backgroundImage)
                // 2) Handle sprite loading with animations
                // 3) Trigger the "entering" animation when sprite changes
                const element = document.getElementById(user.id);
                if (!element) return;
                // Remove idle/entering classes so the entering animation plays again when sprite changes
                element.classList.remove('idle', 'entering');
                // Call updateUserElement which handles sprite reloading properly
                this.updateUserElement(user);
            }

            updateUsernameTwitchColor(user) {
                const el = document.getElementById(user.id);
                const label = el?.querySelector('.username');
                if (!label) return;
                const c = user.twitchColor && /^#?[0-9A-Fa-f]{6}$/i.test(String(user.twitchColor).replace(/^#/, ''))
                    ? (user.twitchColor.startsWith('#') ? user.twitchColor : '#' + user.twitchColor)
                    : this.getTwitchColor(user.username, user.userId);
                label.style.color = c;
            }

            colorToFilter(color) {
                // Convert hex color to CSS filter for coloring black sprites
                const hex = color.replace('#', '');
                const r = parseInt(hex.substr(0, 2), 16);
                const g = parseInt(hex.substr(2, 2), 16);
                const b = parseInt(hex.substr(4, 2), 16);
                
                // Create filter to colorize black sprite
                return `invert(${r / 255}) sepia(1) saturate(5) hue-rotate(${this.rgbToHue(r, g, b)}deg)`;
            }

            rgbToHue(r, g, b) {
                r /= 255;
                g /= 255;
                b /= 255;
                const max = Math.max(r, g, b);
                const min = Math.min(r, g, b);
                let h = 0;
                
                if (max === min) {
                    h = 0;
                } else if (max === r) {
                    h = ((g - b) / (max - min)) % 6;
                } else if (max === g) {
                    h = (b - r) / (max - min) + 2;
                } else {
                    h = (r - g) / (max - min) + 4;
                }
                
                h = Math.round(h * 60);
                if (h < 0) h += 360;
                return h;
            }

            adjustColor(color, amount) {
                // Simple color adjustment for gradient
                const hex = color.replace('#', '');
                const r = Math.max(0, Math.min(255, parseInt(hex.substr(0, 2), 16) + amount));
                const g = Math.max(0, Math.min(255, parseInt(hex.substr(2, 2), 16) + amount));
                const b = Math.max(0, Math.min(255, parseInt(hex.substr(4, 2), 16) + amount));
                return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
            }

            positionUserElement(user) {
                const element = document.getElementById(user.id);
                if (!element) return;
                // Don't reposition during exit animation
                if (element.classList.contains('leaving')) return;
                
                const angleRad = (user.angle * Math.PI) / 180;
                
                // Calculate base circle position (always perfect circle)
                const baseX = Math.cos(angleRad) * this.circleRadius;
                const baseY = Math.sin(angleRad) * this.circleRadius;
                
                // Apply perspective transform ONLY to Y coordinate (not the element itself)
                // angle 0 = no perspective (top-down view)
                // angle 90 = full perspective (side view - Y becomes 0)
                const angleRadTransform = (this.circleAngle * Math.PI) / 180;
                const perspectiveY = baseY * Math.cos(angleRadTransform);
                
                // Center in the campfire area (300x300 container)
                const centerX = 150; // Half of campfire-area width
                const centerY = 150; // Half of campfire-area height
                
                // Get sprite size for proper centering
                const spriteSize = this.settings.spriteSize || 40;
                const spriteOffset = spriteSize / 2; // Half of sprite size for centering
                
                // Adjust vertical position based on view angle for better perspective
                // At 90 degrees (side view), raise sprites up so their feet aren't under the fire
                // Interpolate: 0px at 0¬∞, -7px at 45¬∞, -15px at 90¬∞
                let verticalAdjustment = 0;
                if (this.circleAngle <= 45) {
                    // Linear from 0¬∞ to 45¬∞: 0px to -7px
                    verticalAdjustment = -(this.circleAngle / 45) * 7;
                } else {
                    // Linear from 45¬∞ to 90¬∞: -7px to -15px
                    const progress = (this.circleAngle - 45) / 45; // 0 at 45¬∞, 1 at 90¬∞
                    verticalAdjustment = -7 - (progress * 8); // Start at -7, add -8 more
                }
                
                // Position element - X stays the same, only Y gets perspective
                element.style.left = `${centerX + baseX - spriteOffset}px`;
                element.style.top = `${centerY + perspectiveY - spriteOffset + verticalAdjustment}px`;
                
                // Set z-index based on Y position around the circle
                // Top of circle (baseY = -circleRadius) = furthest back = lowest z-index (5)
                // Bottom of circle (baseY = +circleRadius) = closest/front = highest z-index (24)
                // Z-index increases continuously as you go from top to bottom around the circle
                // This ensures correct layering: sprites closer to bottom are always in front
                const minZIndex = 5; // Furthest back (top of circle)
                const maxZIndex = 24; // Closest/front (bottom of circle)
                const zIndexRange = maxZIndex - minZIndex;
                
                // Normalize baseY from -circleRadius (top) to +circleRadius (bottom) to 0-1
                // Then map to z-index range
                const normalizedY = (baseY + this.circleRadius) / (2 * this.circleRadius); // 0 to 1
                const zIndex = minZIndex + Math.floor(normalizedY * zIndexRange);
                element.style.zIndex = zIndex;
                
                // Also set class for campfire layering (sprites behind campfire need lower z-index than fire)
                // Campfire is at z-index 10-11, so sprites with z-index < 10 are behind it
                if (zIndex < 10) {
                    element.classList.remove('front-layer');
                    element.classList.add('back-layer');
                } else {
                    element.classList.remove('back-layer');
                    element.classList.add('front-layer');
                }
                
                // Apply perspective-based scaling to sprite
                // When perspective is top-down (scaleY = 1), no scaling difference
                // When perspective is side-view (scaleY = 0), maximum scaling difference
                // Top sprites (baseY < 0) are smaller, bottom sprites (baseY > 0) are larger
                const scaleY = Math.cos(angleRadTransform);
                const perspectiveFactor = 1 - scaleY; // 0 when top-down, 1 when side-view
                const scaleAmount = 0.17; // 17% size difference at maximum perspective
                
                // baseY ranges from -1 (top) to +1 (bottom)
                // Calculate scale multiplier: 1 + (perspectiveFactor * baseY * scaleAmount)
                // Top (baseY = -1): 1 - (perspectiveFactor * scaleAmount) = smaller
                // Bottom (baseY = +1): 1 + (perspectiveFactor * scaleAmount) = larger
                // Sides (baseY = 0): 1 = normal size
                const normalizedBaseY = baseY / this.circleRadius; // Normalize to -1 to +1
                const scaleMultiplier = 1 + (perspectiveFactor * normalizedBaseY * scaleAmount);
                
                // Apply scaling to the shape element, combining with flip if needed
                const shape = element.querySelector('.shape');
                if (shape) {
                    // Check if sprite is flipped (for movement direction)
                    const isFlipped = shape.classList.contains('flipped');
                    const flipDirection = isFlipped ? -1 : 1;
                    
                    // Combine perspective scale with flip: scaleX handles flip, scaleY handles perspective
                    shape.style.transform = `scaleX(${flipDirection * scaleMultiplier}) scaleY(${scaleMultiplier})`;
                }
                
                // Update username z-index and opacity to match sprite layering
                const usernameLabel = element.querySelector('.username');
                if (usernameLabel) {
                    // Username z-index should match sprite z-index (so they layer together)
                    usernameLabel.style.zIndex = zIndex.toString();
                    
                    // Usernames get darker as they go backward (top of circle)
                    // Top of circle (baseY = -circleRadius) = darkest (0.5 opacity)
                    // Bottom of circle (baseY = +circleRadius) = brightest (1.0 opacity)
                    const opacityRange = 0.5; // 0.5 to 1.0
                    const minOpacity = 0.5;
                    const usernameOpacity = minOpacity + (normalizedY * opacityRange);
                    usernameLabel.style.opacity = usernameOpacity.toString();
                    
                    this.checkUsernameOverlap(usernameLabel, user);

                    // Keep chat bubble aligned with username if visible
                    const chatMessage = element.querySelector('.chat-message');
                    if (chatMessage) {
                        chatMessage.style.zIndex = zIndex.toString();
                        try {
                            chatMessage.style.top = window.getComputedStyle(usernameLabel).top;
                        } catch (e) { /* ignore */ }
                    }
                }
            }
            
            checkUsernameOverlap(usernameLabel, user) {
                // Check if username is too close to sprite center (overlapping)
                // Username is positioned at top: -25px, so if user is at top of circle,
                // username might overlap with sprite
                const element = document.getElementById(user.id);
                if (!element) return;
                
                // Get the angle - if user is near top (angle 270 or -90 degrees), username overlaps
                const angle = user.angle;
                // Check if angle is in the top quadrant (270¬∞ ¬± 45¬∞ or -90¬∞ ¬± 45¬∞)
                const normalizedAngle = ((angle % 360) + 360) % 360;
                const isTopQuadrant = (normalizedAngle >= 225 && normalizedAngle <= 315);
                
                // Also check vertical position - if user is high on screen, username might overlap
                const rect = element.getBoundingClientRect();
                const shapeRect = element.querySelector('.shape')?.getBoundingClientRect();
                
                if (shapeRect && usernameLabel) {
                    const usernameRect = usernameLabel.getBoundingClientRect();
                    // Check if username bottom overlaps with sprite top
                    const overlap = usernameRect.bottom > shapeRect.top;
                    
                    if (isTopQuadrant || overlap) {
                        // Make username more transparent when overlapping
                        usernameLabel.style.opacity = '0.7';
                    } else {
                        usernameLabel.style.opacity = '1';
                    }
                }
            }

            repositionUsers() {
                this.users.forEach(user => {
                    this.positionUserElement(user);
                });
            }

            removeUserElement(userId) {
                const element = document.getElementById(userId);
                if (element) {
                    // Clean up blob URLs to prevent memory leaks
                    const spriteImg = element.querySelector('img');
                    if (spriteImg && spriteImg._blobUrl) {
                        URL.revokeObjectURL(spriteImg._blobUrl);
                    }
                    
                    // Remove any existing animation classes
                    element.classList.remove('entering', 'idle', 'moving');
                    
                    // Stop any transitions that might interfere with exit animation
                    element.style.transition = 'none';
                    
                    // Calculate lift distance based on sprite size for better visual effect
                    // Larger sprites need more lift distance, smaller sprites need less
                    const spriteSize = this.settings.spriteSize || 40;
                    // Base lift is 40px, scale it proportionally to sprite size
                    // For 40px sprite: 40px lift, for 80px sprite: 80px lift, etc.
                    const liftDistance = Math.max(30, spriteSize); // Minimum 30px, scales with size
                    
                    // Set CSS variable for the animation to use
                    element.style.setProperty('--lift-distance', `-${liftDistance}px`);
                    
                    // Preserve the current transform scale from perspective positioning
                    const shape = element.querySelector('.shape');
                    if (shape) {
                        // Get the current transform values (scaleX and scaleY from perspective)
                        const currentTransform = shape.style.transform;
                        if (currentTransform) {
                            // Extract scale values
                            const scaleXMatch = currentTransform.match(/scaleX\(([^)]+)\)/);
                            const scaleYMatch = currentTransform.match(/scaleY\(([^)]+)\)/);
                            
                            if (scaleXMatch && scaleYMatch) {
                                const scaleX = scaleXMatch[1];
                                const scaleY = scaleYMatch[1];
                                // Store scale values as CSS variables for the animation to use
                                element.style.setProperty('--exit-scaleX', scaleX);
                                element.style.setProperty('--exit-scaleY', scaleY);
                            }
                        }
                    }
                    
                    // Random delay (0-250ms) to stagger animations when multiple users leave at once
                    // This creates a more natural, less synchronized effect
                    const randomDelay = Math.random() * 250;
                    
                    // Add leaving animation after random delay - gentle lift up and fade out
                    // This works consistently for all sprite types (RPG, morphs, circles)
                    setTimeout(() => {
                        if (element && element.parentNode) {
                            element.classList.add('leaving');
                        }
                    }, randomDelay);
                    
                    // Remove element after animation completes (600ms animation + random delay)
                    setTimeout(() => {
                        if (element && element.parentNode) {
                            element.remove();
                        }
                    }, 600 + randomDelay);
                }
            }

            removeUser(username) {
                const index = this.users.findIndex(u => u.username === username || (u.userId && u.userId === username));
                if (index !== -1) {
                    const user = this.users[index];
                    this.users.splice(index, 1);
                    this.removeUserElement(user.id);
                    // Reposition remaining users
                    this.repositionUsers();
                    // Save to localStorage for persistence
                    this.savePersistedUsers();
                }
            }
            
            removeUserById(userId) {
                const index = this.users.findIndex(u => u.userId === userId);
                if (index !== -1) {
                    const user = this.users[index];
                    this.users.splice(index, 1);
                    this.removeUserElement(user.id);
                    // Reposition remaining users
                    this.repositionUsers();
                    // Save to localStorage for persistence
                    this.savePersistedUsers();
                }
            }

            updateSettings(newSettings) {
                // Prevent infinite loop - if we're already updating, skip
                if (this._updatingSettings) {
                    return;
                }
                this._updatingSettings = true;
                
                try {
                    // Store old settings for comparison
                    const oldSettings = { ...this.settings };
                    
                    this.settings = { ...this.settings, ...newSettings };
                    
                    // Always reload sprite data from localStorage (in case it was updated)
                    const defaultSprite = localStorage.getItem('defaultSpriteData');
                    const customSprite = localStorage.getItem('customSpriteData');
                    if (defaultSprite) this.settings.defaultSpriteData = defaultSprite;
                    if (customSprite) this.settings.customSpriteData = customSprite;
                    
                    // Only save to localStorage if settings actually changed (prevent loop)
                    const settingsChanged = JSON.stringify(oldSettings) !== JSON.stringify(this.settings);
                    if (settingsChanged) {
                        localStorage.setItem('campfireWidgetSettings', JSON.stringify(this.settings));
                    }
                    
                    // Update widget based on new settings
                    if (newSettings.circleAngle !== undefined && newSettings.circleAngle !== oldSettings.circleAngle) {
                        this.circleAngle = newSettings.circleAngle;
                        this.updateCircleTransform();
                    }

                    if (newSettings.campfireYOffset !== undefined && newSettings.campfireYOffset !== oldSettings.campfireYOffset) {
                        this.applyCampfireYOffset();
                    }

                    if (newSettings.widgetBackground !== undefined && newSettings.widgetBackground !== oldSettings.widgetBackground) {
                        this.applyWidgetBackground();
                    }

                    if (newSettings.useNativeFrame !== undefined && newSettings.useNativeFrame !== oldSettings.useNativeFrame) {
                        this.applyNativeFrameMode();
                    }
                    
                    if (newSettings.fireSize !== undefined && newSettings.fireSize !== oldSettings.fireSize) {
                        // Update fire size without recreating the entire graphic (prevents flickering)
                        const fireSize = this.settings.fireSize || 48;
                        
                        // Update default emoji fire if it exists
                        const fireEmoji = document.getElementById('campfireEmoji');
                        if (fireEmoji) {
                            // Use requestAnimationFrame to ensure smooth update without flicker
                            requestAnimationFrame(() => {
                                fireEmoji.style.fontSize = `${fireSize}px`;
                            });
                        }
                        
                        // Update custom fire graphics (img or video) if they exist
                        const container = document.getElementById('campfireGraphic');
                        if (container) {
                            const customImg = container.querySelector('img');
                            const customVideo = container.querySelector('video');
                            
                            if (customImg) {
                                requestAnimationFrame(() => {
                                    customImg.style.width = `${fireSize}px`;
                                    customImg.style.height = `${fireSize}px`;
                                });
                            }
                            if (customVideo) {
                                requestAnimationFrame(() => {
                                    customVideo.style.width = `${fireSize}px`;
                                    customVideo.style.height = `${fireSize}px`;
                                });
                            }
                        }
                    }
                    
                    // Sprite size update is handled separately below (line ~3027) to avoid duplicate code
                    
                    // Handle animated glow setting change
                    if (newSettings.animatedGlow !== undefined && newSettings.animatedGlow !== oldSettings.animatedGlow) {
                        if (this.settings.animatedGlow && !this.animationFrame) {
                            // Start animation if it was just enabled
                            this.startGlowAnimation();
                        } else if (!this.settings.animatedGlow && this.animationFrame) {
                            // Stop animation if it was just disabled
                            cancelAnimationFrame(this.animationFrame);
                            this.animationFrame = null;
                        }
                    }
                    
                    // Only recreate campfire graphic if relevant settings ACTUALLY changed (compare old vs new)
                    const campfireGraphicChanged = (newSettings.campfireGraphicUrl !== undefined && newSettings.campfireGraphicUrl !== oldSettings.campfireGraphicUrl) ||
                        (newSettings.campfireGraphicData !== undefined && newSettings.campfireGraphicData !== oldSettings.campfireGraphicData);
                    const glowSettingsChanged = (newSettings.glowSize !== undefined && newSettings.glowSize !== oldSettings.glowSize) ||
                        (newSettings.glowIntensity !== undefined && newSettings.glowIntensity !== oldSettings.glowIntensity) ||
                        (newSettings.shadowIntensity !== undefined && newSettings.shadowIntensity !== oldSettings.shadowIntensity) ||
                        (newSettings.glowSpread !== undefined && newSettings.glowSpread !== oldSettings.glowSpread);
                    
                    if (campfireGraphicChanged || glowSettingsChanged) {
                        // Stop existing animation if glow settings changed
                        if (this.animationFrame) {
                            cancelAnimationFrame(this.animationFrame);
                            this.animationFrame = null;
                        }
                        this.setupCampfireGraphic();
                        // Restart animation if it was enabled
                        if (this.settings.animatedGlow !== false) {
                            this.startGlowAnimation();
                        }
                    }
                    
                    // Update sprites ONLY if sprite-related settings are explicitly in newSettings
                    // Don't enter this block if only non-sprite settings (like maxUsers, spriteSize) changed
                    const hasSpriteSettings = newSettings.defaultSpriteData !== undefined ||
                        newSettings.customSpriteData !== undefined ||
                        newSettings.spriteMode !== undefined ||
                        newSettings.shadowSprites !== undefined ||
                        newSettings.rpgSprites !== undefined ||
                        newSettings.morphSprites !== undefined;
                    
                    if (hasSpriteSettings) {
                            
                            // Track if sprite collections were updated (to know if we need to refresh user sprites)
                            let spriteCollectionsUpdated = false;
                            
                            // Use sprite collections from newSettings if provided, otherwise reload from localStorage
                            if (newSettings.shadowSprites !== undefined) {
                            // Check if collection actually changed (not just empty array)
                            const oldCount = (this.settings.shadowSprites || []).length;
                            const newCount = (newSettings.shadowSprites || []).length;
                            if (newCount > oldCount || (oldCount === 0 && newCount > 0)) {
                                spriteCollectionsUpdated = true;
                            }
                            // Use provided sprite collection and save to localStorage
                            this.settings.shadowSprites = Array.isArray(newSettings.shadowSprites) ? newSettings.shadowSprites : [];
                            try {
                                localStorage.setItem('shadowSprites', JSON.stringify(this.settings.shadowSprites));
                            } catch (e) {
                                console.warn('Could not save shadowSprites to localStorage:', e);
                            }
                        } else {
                            // Reload from localStorage
                            const shadowSprites = localStorage.getItem('shadowSprites');
                            if (shadowSprites) {
                                try {
                                    this.settings.shadowSprites = JSON.parse(shadowSprites);
                                    if (!Array.isArray(this.settings.shadowSprites)) {
                                        this.settings.shadowSprites = [];
                                    }
                                } catch (e) {
                                    console.error('Error parsing shadowSprites:', e);
                                    this.settings.shadowSprites = [];
                                }
                            } else {
                                this.settings.shadowSprites = [];
                            }
                        }
                        
                        if (newSettings.rpgSprites !== undefined) {
                            // Check if collection actually changed (not just empty array)
                            const oldCount = (this.settings.rpgSprites || []).length;
                            const newCount = (newSettings.rpgSprites || []).length;
                            if (newCount > oldCount || (oldCount === 0 && newCount > 0)) {
                                spriteCollectionsUpdated = true;
                            }
                            // Use provided sprite collection and save to localStorage
                            this.settings.rpgSprites = Array.isArray(newSettings.rpgSprites) ? newSettings.rpgSprites : [];
                            try {
                                localStorage.setItem('rpgSprites', JSON.stringify(this.settings.rpgSprites));
                            } catch (e) {
                                console.warn('Could not save rpgSprites to localStorage:', e);
                            }
                        } else {
                            // Reload from localStorage
                            const rpgSprites = localStorage.getItem('rpgSprites');
                            if (rpgSprites) {
                                try {
                                    this.settings.rpgSprites = JSON.parse(rpgSprites);
                                    if (!Array.isArray(this.settings.rpgSprites)) {
                                        this.settings.rpgSprites = [];
                                    }
                                } catch (e) {
                                    console.error('Error parsing rpgSprites:', e);
                                    this.settings.rpgSprites = [];
                                }
                            } else {
                                this.settings.rpgSprites = [];
                            }
                        }
                        
                        if (newSettings.morphSprites !== undefined) {
                            // Check if collection actually changed (not just empty array)
                            const oldCount = (this.settings.morphSprites || []).length;
                            const newCount = (newSettings.morphSprites || []).length;
                            if (newCount > oldCount || (oldCount === 0 && newCount > 0)) {
                                spriteCollectionsUpdated = true;
                            }
                            // Use provided sprite collection and save to localStorage
                            this.settings.morphSprites = Array.isArray(newSettings.morphSprites) ? newSettings.morphSprites : [];
                            try {
                                localStorage.setItem('morphSprites', JSON.stringify(this.settings.morphSprites));
                            } catch (e) {
                                console.warn('Could not save morphSprites to localStorage:', e);
                            }
                        } else {
                            // Reload from localStorage
                            const morphSprites = localStorage.getItem('morphSprites');
                            if (morphSprites) {
                                try {
                                    this.settings.morphSprites = JSON.parse(morphSprites);
                                    if (!Array.isArray(this.settings.morphSprites)) {
                                        this.settings.morphSprites = [];
                                    }
                                } catch (e) {
                                    console.error('Error parsing morphSprites:', e);
                                    this.settings.morphSprites = [];
                                }
                            } else {
                                this.settings.morphSprites = [];
                            }
                        }
                        
                        // Debug: Log sprite collection status (only when collections actually change)
                        // Removed constant logging to prevent console spam
                        
                        // Only update sprites if sprite mode ACTUALLY changed (not just reloaded)
                        // OR if sprite collections were newly loaded (were empty, now have sprites)
                        // Don't update sprites if only size settings changed
                        const spriteModeChanged = newSettings.spriteMode !== undefined && 
                                                 newSettings.spriteMode !== oldSettings.spriteMode;
                        const defaultSpriteChanged = newSettings.defaultSpriteData !== undefined && 
                                                     newSettings.defaultSpriteData !== oldSettings.defaultSpriteData;
                        const customSpriteChanged = newSettings.customSpriteData !== undefined && 
                                                   newSettings.customSpriteData !== oldSettings.customSpriteData;
                        
                        // Only update user elements if sprite mode or collections ACTUALLY changed
                        // Don't update if we're just reloading from localStorage with the same data
                        if (spriteModeChanged || defaultSpriteChanged || customSpriteChanged || spriteCollectionsUpdated) {
                            // Update all user elements to apply new sprites (without re-adding entering animation)
                            this.users.forEach(user => {
                                const element = document.getElementById(user.id);
                                if (element) {
                                    // Only clear and reload sprites if collections actually changed
                                    if (spriteCollectionsUpdated && user.spritesByMode) {
                                        const currentMode = this.settings.spriteMode || 'circle';
                                        delete user.spritesByMode[currentMode];
                                        // Clear existing sprite img element to force reload
                                        const shape = element.querySelector('.shape');
                                        if (shape) {
                                            const existingImg = shape.querySelector('img');
                                            if (existingImg) {
                                                existingImg.remove();
                                                shape._spriteImg = null;
                                            }
                                            // Clear any background that might be showing
                                            shape.style.background = 'transparent';
                                            shape.style.backgroundImage = 'none';
                                        }
                                    }
                                    
                                    // For sprite mode changes only (no collection changes): swap sprite smoothly without hiding
                                    // For collection/default/custom changes: use updateUserElement (full reload needed)
                                    if (spriteModeChanged && !spriteCollectionsUpdated && !defaultSpriteChanged && !customSpriteChanged) {
                                        // Only mode changed - swap sprite smoothly
                                        const shape = element.querySelector('.shape');
                                        if (shape) {
                                            // Get sprite for new mode (getUserSprite handles spritesByMode lookup)
                                            const spriteInfo = this.getUserSprite(user);
                                            if (spriteInfo && spriteInfo.data) {
                                                // Remove old sprite img
                                                const existingImg = shape.querySelector('img');
                                                if (existingImg) {
                                                    // Clean up blob URL if it exists
                                                    if (existingImg._blobUrl) {
                                                        URL.revokeObjectURL(existingImg._blobUrl);
                                                    }
                                                    existingImg.remove();
                                                    shape._spriteImg = null;
                                                }
                                                
                                                // Clear background
                                                shape.style.background = 'transparent';
                                                shape.style.backgroundColor = 'transparent';
                                                shape.style.backgroundImage = 'none';
                                                shape.style.border = 'none';
                                                shape.style.borderRadius = '0';
                                                
                                                // Create new sprite img
                                                const spriteImg = document.createElement('img');
                                                spriteImg.style.width = '100%';
                                                spriteImg.style.height = '100%';
                                                spriteImg.style.objectFit = 'contain';
                                                spriteImg.style.objectPosition = 'center';
                                                spriteImg.style.display = 'block';
                                                
                                                // Apply colorization if needed
                                                if (spriteInfo.colorize && spriteInfo.color) {
                                                    spriteImg.style.filter = `brightness(0) saturate(100%) ${this.colorToFilter(spriteInfo.color)}`;
                                                } else {
                                                    spriteImg.style.filter = 'none';
                                                }
                                                
                                                // Store references for error handling
                                                spriteImg._element = element;
                                                spriteImg._shape = shape;
                                                spriteImg._user = user;
                                                
                                                // Handle successful load - sprite should show immediately
                                                spriteImg.onload = () => {
                                                    spriteImg.style.opacity = '1';
                                                    shape.style.background = 'transparent';
                                                    shape.style.border = 'none';
                                                };
                                                
                                                // Handle errors - show fallback
                                                spriteImg.onerror = () => {
                                                    console.error(`[swapSprite] Failed to load sprite for ${user.username}`);
                                                    spriteImg.remove();
                                                    shape._spriteImg = null;
                                                    // Show fallback circle
                                                    const viewerColor = user.color || this.getViewerColor(user.username, user.userId);
                                                    shape.style.background = `linear-gradient(135deg, ${viewerColor || '#667eea'} 0%, ${this.adjustColor(viewerColor || '#667eea', -20)} 100%)`;
                                                    shape.style.border = '2px solid rgba(255, 255, 255, 0.8)';
                                                    shape.style.borderRadius = '50%';
                                                    shape.style.filter = 'none';
                                                };
                                                
                                                // Set src and append
                                                spriteImg.src = spriteInfo.data;
                                                shape._spriteImg = spriteImg;
                                                shape.appendChild(spriteImg);
                                                
                                                // Add spin animation when sprite mode changes
                                                element.classList.remove('entering');
                                                element.classList.add('entering');
                                                setTimeout(() => {
                                                    if (element && element.classList.contains('entering')) {
                                                        element.classList.remove('entering');
                                                    }
                                                }, 500);
                                                
                                                // Update username position based on new mode
                                                const usernameLabel = element.querySelector('.username');
                                                if (usernameLabel) {
                                                    const newMode = this.settings.spriteMode || 'circle';
                                                    if (newMode === 'rpg-characters') {
                                                        usernameLabel.style.top = '35px';
                                                        const twitchColor = this.getTwitchColor(user.username, user.userId);
                                                        usernameLabel.style.color = twitchColor;
                                                    } else if (newMode === 'pixel-morphs') {
                                                        usernameLabel.style.top = '-25px';
                                                        const twitchColor = this.getTwitchColor(user.username, user.userId);
                                                        usernameLabel.style.color = twitchColor;
                                                    } else {
                                                        usernameLabel.style.top = '-25px';
                                                        const twitchColor = this.getTwitchColor(user.username, user.userId);
                                                        usernameLabel.style.color = twitchColor;
                                                    }
                                                    this.checkUsernameOverlap(usernameLabel, user);
                                                }
                                            } else {
                                                // No sprite found - fallback to circle
                                                console.warn(`[swapSprite] No sprite found for ${user.username} in mode ${this.settings.spriteMode}, using fallback`);
                                                const existingImg = shape.querySelector('img');
                                                if (existingImg) {
                                                    if (existingImg._blobUrl) {
                                                        URL.revokeObjectURL(existingImg._blobUrl);
                                                    }
                                                    existingImg.remove();
                                                    shape._spriteImg = null;
                                                }
                                                const viewerColor = user.color || this.getViewerColor(user.username, user.userId);
                                                shape.style.background = `linear-gradient(135deg, ${viewerColor || '#667eea'} 0%, ${this.adjustColor(viewerColor || '#667eea', -20)} 100%)`;
                                                shape.style.border = '2px solid rgba(255, 255, 255, 0.8)';
                                                shape.style.borderRadius = '50%';
                                                shape.style.filter = 'none';
                                            }
                                        }
                                    } else {
                                        // Collections/default/custom changed - need full reload via updateUserElement
                                        this.updateUserElement(user);
                                    }
                                }
                            });
                        }
                    }
                    
                    // Update sprite sizes and positions if spriteSize or fireSize changed
                    if (newSettings.spriteSize !== undefined || newSettings.fireSize !== undefined) {
                        this.users.forEach(user => {
                            const element = document.getElementById(user.id);
                            if (element) {
                                // Update size and position without changing sprite
                                const shape = element.querySelector('.shape');
                                if (newSettings.spriteSize !== undefined) {
                                    const spriteSize = newSettings.spriteSize;
                                    element.style.width = `${spriteSize}px`;
                                    element.style.height = `${spriteSize}px`;
                                    if (shape) {
                                        shape.style.width = `${spriteSize}px`;
                                        shape.style.height = `${spriteSize}px`;
                                    }
                                }
                                // Reposition to account for new sprite size
                                this.positionUserElement(user);
                                // Ensure username stays centered after size change
                                const usernameLabel = element.querySelector('.username');
                                if (usernameLabel) {
                                    // Force center alignment - ensure left and transform are set correctly
                                    usernameLabel.style.left = '50%';
                                    usernameLabel.style.transform = 'translateX(-50%)';
                                    this.checkUsernameOverlap(usernameLabel, user);
                                }
                            }
                        });
                    }
                    
                    if (newSettings.maxUsers !== undefined) {
                        this.maxUsers = newSettings.maxUsers;
                    }
                    
                    if (newSettings.spriteDefaultDirections !== undefined) {
                        this.settings.spriteDefaultDirections = newSettings.spriteDefaultDirections;
                    }
                    if (newSettings.spriteDefaultDirection !== undefined) {
                        this.settings.spriteDefaultDirection = newSettings.spriteDefaultDirection;
                        // Update all existing sprites to reflect new default direction
                        // Sprites will flip correctly on next movement, but we could also update them immediately
                        // For now, just update the setting - sprites will use new direction on next flip
                    }
                    
                    // Handle test users toggle
                    if (newSettings.showTestUsers !== undefined) {
                        if (newSettings.showTestUsers === false) {
                            // Remove all test users if toggle is turned off
                            const testUsers = this.users.filter(u => u.username.startsWith('TestUser'));
                            testUsers.forEach(user => {
                                this.removeUser(user.username);
                            });
                            // Don't stop random movement when test users are removed
                            // Random movement should continue for all users (including real users)
                            // Only stop if explicitly disabled via settings
                        } else if (newSettings.showTestUsers === true) {
                            // Add test users if toggle is turned on and they don't exist
                            const hasTestUsers = this.users.some(u => u.username.startsWith('TestUser'));
                            if (!hasTestUsers && !this._settingUpMockUsers) {
                                this.setupMockUsers();
                            }
                        }
                    }
                } finally {
                    // Always clear the updating flag, even if an error occurred
                    this._updatingSettings = false;
                }
            }

            // Mock users for testing (remove in production)
            setupMockUsers() {
                // Prevent multiple simultaneous calls
                if (this._settingUpMockUsers) {
                    return;
                }
                this._settingUpMockUsers = true;
                
                // Check if test users already exist - if so, don't add them again
                const hasTestUsers = this.users.some(u => u.username.startsWith('TestUser'));
                if (hasTestUsers) {
                    this._settingUpMockUsers = false;
                    return;
                }
                
                console.log('setupMockUsers() called');
                // Add a few test users with consistent userIds
                console.log('Scheduling test users to be added...');
                setTimeout(() => {
                    console.log('Adding TestUser1...');
                    this.addUser('TestUser1', { userId: 'TestUser1' });
                }, 500);
                setTimeout(() => {
                    console.log('Adding TestUser2...');
                    this.addUser('TestUser2', { userId: 'TestUser2' });
                }, 1000);
                setTimeout(() => {
                    console.log('Adding TestUser3...');
                    this.addUser('TestUser3', { userId: 'TestUser3' });
                    // Clear the flag after all users are scheduled
                    this._settingUpMockUsers = false;
                }, 1500);
                
                // Random movement is now started in init() for all users
                // No need to start it here - it's already running
                
                // Start glow animation if enabled (only if not already started)
                if (this.settings.animatedGlow !== false && !this.animationFrame) {
                    console.log('Starting glow animation...');
                    this.startGlowAnimation();
                } else if (this.settings.animatedGlow === false) {
                    console.log('Glow animation disabled');
                }
            }

            startRandomMovement() {
                // Prevent multiple intervals from being created
                if (this.randomMovementInterval) {
                    return; // Already running
                }
                
                // Randomly move non-active users around the campfire (NPC movement)
                // Active users = users with their viewer dashboard open (activeViewer in localStorage)
                // When dashboard is open, user controls their sprite with arrow keys (no NPC movement)
                // When dashboard closes, activeViewer is cleared and NPC movement automatically resumes
                this.randomMovementInterval = setInterval(() => {
                    this.users.forEach(user => {
                        // Only move users who don't have their dashboard open (NPC movement)
                        // Users with dashboard open control their sprite manually with arrow keys
                        const isActiveUser = this.isActiveUser(user);
                        if (!isActiveUser) {
                            // Increased chance to move (25% chance every interval) for more movement
                            if (Math.random() < 0.25) {
                                const direction = Math.random() < 0.5 ? -1 : 1;
                                // Smaller movement step for gentler motion
                                const angleStep = 5; // Smaller step (was 15)
                                const newAngle = (user.angle + direction * angleStep + 360) % 360;
                                
                                // Check for collisions with other non-active users
                                const minDistance = 20; // Minimum angle distance between users (in degrees)
                                let canMove = true;
                                
                                this.users.forEach(otherUser => {
                                    if (otherUser.id !== user.id && !this.isActiveUser(otherUser)) {
                                        // Calculate shortest angular distance
                                        const angleDiff = Math.abs(newAngle - otherUser.angle);
                                        const minAngleDiff = Math.min(angleDiff, 360 - angleDiff);
                                        
                                        if (minAngleDiff < minDistance) {
                                            canMove = false;
                                        }
                                    }
                                });
                                
                                if (canMove) {
                                    user.angle = newAngle;
                                    
                                    // Flip sprite based on movement direction
                                    this.flipSprite(user.id, direction);
                                    
                                    // Set moving animation
                                    this.setUserMoving(user.id, true);
                                    
                                    // Reposition user
                                    this.positionUserElement(user);
                                    
                                    // Stop moving animation after movement completes
                                    setTimeout(() => {
                                        this.setUserMoving(user.id, false);
                                    }, 600);
                                }
                            }
                        }
                    });
                }, 3000); // Check every 3 seconds (more frequent movement)
            }

            isActiveUser(user) {
                // Check if user is the logged-in active viewer
                try {
                    const activeViewer = localStorage.getItem('activeViewer');
                    if (activeViewer) {
                        const active = JSON.parse(activeViewer);
                        return user.userId === active.userId || 
                               user.username === active.displayName || 
                               user.username === active.username;
                    }
                } catch (e) {}
                return false;
            }

            setUserMoving(userId, isMoving) {
                const element = document.getElementById(userId);
                if (!element) return;
                
                const spriteMode = this.settings.spriteMode || 'circle';
                const isRpgMode = spriteMode === 'rpg-characters';
                
                if (isMoving) {
                    element.classList.remove('idle');
                    element.classList.add('moving');
                } else {
                    element.classList.remove('moving');
                    // Skip idle animation for RPG characters
                    if (!isRpgMode) {
                        element.classList.add('idle');
                        // Add random animation delay so sprites don't float in sync
                        const randomDelay = Math.random() * 3; // 0-3 seconds random delay
                        element.style.animationDelay = `${randomDelay}s`;
                    }
                }
            }
            
            shutdown() {
                console.log('üõë Shutting down widget...');
                
                // Stop all animations
                if (this.animationFrame) {
                    cancelAnimationFrame(this.animationFrame);
                    this.animationFrame = null;
                }
                
                // Stop random movement
                if (this.randomMovementInterval) {
                    clearInterval(this.randomMovementInterval);
                    this.randomMovementInterval = null;
                }
                
                // Clean up all blob URLs
                this.users.forEach(user => {
                    const element = document.getElementById(user.id);
                    if (element) {
                        const spriteImg = element.querySelector('img');
                        if (spriteImg && spriteImg._blobUrl) {
                            URL.revokeObjectURL(spriteImg._blobUrl);
                        }
                    }
                });
                
                // Clear all users with animations
                this.users.forEach(user => {
                    this.removeUserElement(user.id);
                });
                this.users = [];
                
                // Clear DOM after animations complete (600ms animation + up to 250ms random delay)
                setTimeout(() => {
                    const circleContainer = document.getElementById('circleContainer');
                    if (circleContainer) {
                        circleContainer.innerHTML = '';
                    }
                }, 900); // 600ms animation + 250ms max delay + 50ms buffer
                
                console.log('‚úÖ Widget shutdown complete');
            }

            // Glow animation
            startGlowAnimation() {
                // Cancel existing animation if any
                if (this.animationFrame) {
                    cancelAnimationFrame(this.animationFrame);
                    this.animationFrame = null;
                }
                
                // Check if animation should be enabled (default to true if not explicitly false)
                if (this.settings.animatedGlow === false) {
                    return; // Animation disabled
                }
                
                let animationTime = 0;
                const baseIntensity = this.settings.glowIntensity || 50;
                const baseSpread = this.settings.glowSpread || 85;
                const flickerBaseOpacitySetting = this.settings.flickerOpacity || 25;
                const flickerBaseSpread = this.settings.flickerSpread || 55;
                
                const animate = () => {
                    const glow = document.getElementById('campfireGlow');
                    const flicker = document.getElementById('campfireFlicker');
                    // Check if animation should continue (default to true if not explicitly false)
                    if (!glow || this.settings.animatedGlow === false) {
                        this.animationFrame = null;
                        return;
                    }
                    
                    animationTime += 0.05;
                    
                    // Intensity: vary by ¬±1-20 from base
                    const intensityVariation = Math.sin(animationTime * 0.8) * 10 + Math.sin(animationTime * 1.3) * 5;
                    const animatedIntensity = Math.max(0, Math.min(100, baseIntensity + intensityVariation));
                    
                    // Spread: vary by ¬±3-8% from base
                    const spreadVariation = Math.sin(animationTime * 0.5) * 4 + Math.sin(animationTime * 0.9) * 2;
                    const animatedSpread = Math.max(20, Math.min(100, baseSpread + spreadVariation));
                    
                    // Recalculate gradient
                    const baseOpacity = (animatedIntensity / 100) * 0.5;
                    const stop1 = Math.max(0, animatedSpread * 0.25);
                    const stop2 = Math.max(5, animatedSpread * 0.4);
                    const stop3 = Math.max(10, animatedSpread * 0.55);
                    const stop4 = Math.max(15, animatedSpread * 0.7);
                    const stop5 = Math.max(20, animatedSpread * 0.85);
                    
                    const glowGradient = `radial-gradient(ellipse at center, 
                        rgba(255, 107, 53, ${baseOpacity}) 0%, 
                        rgba(247, 147, 30, ${baseOpacity * 0.7}) ${stop1}%, 
                        rgba(255, 204, 2, ${baseOpacity * 0.5}) ${stop2}%, 
                        rgba(255, 204, 2, ${baseOpacity * 0.3}) ${stop3}%, 
                        rgba(255, 204, 2, ${baseOpacity * 0.15}) ${stop4}%, 
                        transparent ${animatedSpread}%)`;
                    
                    glow.style.background = glowGradient;
                    
                    // Flicker layer: faster/lower-amplitude variation, in front of campfire
                    if (flicker) {
                        const flickerOpacityVar = (Math.sin(animationTime * 2.2) * 6 + Math.sin(animationTime * 3.7) * 4);
                        const animatedFlickerOpacity = Math.max(0, Math.min(100, flickerBaseOpacitySetting + flickerOpacityVar));
                        const flickerSpreadVar = (Math.sin(animationTime * 1.6) * 3 + Math.sin(animationTime * 2.4) * 2);
                        const animatedFlickerSpread = Math.max(20, Math.min(100, flickerBaseSpread + flickerSpreadVar));

                        const op = Math.max(0, Math.min(1, (animatedFlickerOpacity / 100) * 0.6));
                        const f1 = Math.max(0, animatedFlickerSpread * 0.25);
                        const f2 = Math.max(5, animatedFlickerSpread * 0.45);
                        const flickerGradient = `radial-gradient(ellipse at center,
                            rgba(255, 255, 255, ${op * 0.15}) 0%,
                            rgba(255, 204, 2, ${op * 0.7}) ${f1}%,
                            rgba(255, 107, 53, ${op * 0.35}) ${f2}%,
                            transparent ${animatedFlickerSpread}%)`;
                        flicker.style.background = flickerGradient;
                    }
                    
                    this.animationFrame = requestAnimationFrame(animate);
                };
                
                this.animationFrame = requestAnimationFrame(animate);
            }
        }

        // Initialize widget when DOM is ready
        let widget;
        const pendingWidgetEvents = [];
        
        let reconcileTimeout = null;
        function scheduleReconcile() {
            if (reconcileTimeout) clearTimeout(reconcileTimeout);
            reconcileTimeout = setTimeout(() => {
                if (!widget || !Array.isArray(widget.users)) return;
                widget.users.forEach(user => {
                    const elem = document.getElementById(user.id);
                    // Skip users mid-enter
                    if (elem && elem.classList.contains('entering')) return;
                    
                    // Ensure sprite is assigned (getUserSprite will handle spritesByMode automatically)
                    if (widget.getUserSprite) {
                        widget.getUserSprite(user);
                    }
                    // Do NOT call updateUserElement here: it does a full sprite swap (hide/reload/show) on
                    // every user, which makes all existing sprites re-animate or blink when only one was added.
                    // updateUserElement is still used by syncUsersToState (color/sprite change) and updateSettings.
                    // Safety: ensure element isn't stuck hidden from a prior failed load
                    if (elem && elem.style.display === 'none') {
                        elem.style.display = '';
                        elem.style.visibility = 'visible';
                        elem.style.opacity = '1';
                    }
                });
            }, 200);
        }

        function applyWidgetEvent(evt) {
            if (!widget || !evt) return false;
            
            if (evt.type === 'userJoin' && evt.user) {
                const user = evt.user;
                if (user.username) {
                    widget.addUser(user.username, {
                        userId: user.userId || null,
                        color: user.color || '#ffffff',
                        selectedSprite: user.selectedSprite || null,
                        twitchColor: user.twitchColor || null,
                        angle: user.angle !== undefined ? user.angle : Math.random() * 360
                    });
                    scheduleReconcile();
                    // Refresh members list if members tab is open
                    if (document.getElementById('membersSection')?.classList.contains('active')) {
                        setTimeout(() => loadWidgetMembers(), 100);
                    }
                }
                return true;
            }
            
            if (evt.type === 'userLeave') {
                if (evt.userId && widget.removeUserById) {
                    widget.removeUserById(evt.userId);
                    // Refresh members list if members tab is open
                    if (document.getElementById('membersSection')?.classList.contains('active')) {
                        setTimeout(() => loadWidgetMembers(), 100);
                    }
                    return true;
                }
                if (evt.username && widget.removeUser) {
                    widget.removeUser(evt.username);
                    // Refresh members list if members tab is open
                    if (document.getElementById('membersSection')?.classList.contains('active')) {
                        setTimeout(() => loadWidgetMembers(), 100);
                    }
                    return true;
                }
            }
            
            if (evt.type === 'syncFullState' && Array.isArray(evt.users)) {
                syncUsersToState(evt.users);
                scheduleReconcile();
                return true;
            }
            
            return false;
        }
        
        // Electron IPC listeners for widget events (desktop app only)
        if (window.electronAPI) {
            window.electronAPI.onUserJoin((user) => {
                const evt = { type: 'userJoin', user };
                if (!applyWidgetEvent(evt)) {
                    pendingWidgetEvents.push(evt);
                }
            });
            
            window.electronAPI.onUserLeave((data) => {
                const evt = { type: 'userLeave', userId: data?.userId, username: data?.username };
                if (!applyWidgetEvent(evt)) {
                    pendingWidgetEvents.push(evt);
                }
            });
            
            window.electronAPI.onSyncFullState((users) => {
                if (!widget) {
                    pendingWidgetEvents.push({ type: 'syncFullState', users });
                    return;
                }
                if (Array.isArray(users)) {
                    syncUsersToState(users);
                }
            });

            window.electronAPI.onViewerColorChange((data) => {
                if (!widget || !data?.userId) return;
                const u = widget.users.find(uu => String(uu.userId || '') === String(data.userId));
                if (u) { u.color = data.color; widget.updateUserColor(u); }
            });

            window.electronAPI.onViewerSpriteChange((data) => {
                if (!widget || !data?.userId) return;
                const u = widget.users.find(uu => String(uu.userId || '') === String(data.userId));
                if (u) { u.assignedSprite = data.sprite; u.selectedSprite = data.sprite; widget.updateUserSprite(u); }
            });

            window.electronAPI.onViewerTwitchColorUpdate((data) => {
                if (!widget || !data?.userId) return;
                const u = widget.users.find(uu => String(uu.userId || '') === String(data.userId));
                if (u) { u.twitchColor = data.color; widget.updateUsernameTwitchColor(u); }
            });

            // Movement from Twitch chat commands (!cw / !ccw) and viewer dashboards
            window.electronAPI.onViewerMovement((data) => {
                if (!widget || !data) return;
                const username = data.username || data.displayName;
                const direction = typeof data.direction === 'number' ? data.direction : null;
                const speed = typeof data.speed === 'number' ? data.speed : (typeof data.degrees === 'number' ? data.degrees : 15);
                if (username && direction !== null) {
                    widget.moveUser(username, direction, speed || 15);
                }
            });
        }
        console.log('Widget script loading, readyState:', document.readyState);
        
        function initWidget() {
            try {
                console.log('Initializing widget...');
                console.log('Campfire graphic element exists:', !!document.getElementById('campfireGraphic'));
                console.log('Circle container element exists:', !!document.getElementById('circleContainer'));
                
                widget = new CampfireWidget();
                window.campfireWidget = widget;
                window.widget = widget; // Also expose as window.widget for compatibility
                
                // Apply any pending IPC events that arrived before widget init
                if (pendingWidgetEvents.length > 0) {
                    const queued = pendingWidgetEvents.splice(0, pendingWidgetEvents.length);
                    queued.forEach(evt => applyWidgetEvent(evt));
                }
                console.log('Widget initialized successfully!', widget);
            } catch (error) {
                console.error('Error initializing widget:', error);
                console.error('Error stack:', error.stack);
            }
        }
        
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initWidget);
        } else {
            // DOM already loaded, initialize immediately
            initWidget();
        }

        // Flag to prevent storage events from triggering updates during Dashboard initialization
        let _ignoringStorageEvents = false;
        
        // Listen for settings updates from dashboard (via localStorage events)
        window.addEventListener('storage', (e) => {
            if (!widget || _ignoringStorageEvents) return;
            if (e.key === 'campfireWidgetSettings') {
                try {
                    const newSettings = JSON.parse(e.newValue);
                    const oldSettings = widget.settings || {};
                    // Only pass settings that actually changed to prevent unnecessary sprite updates
                    const changedSettings = {};
                    Object.keys(newSettings).forEach(key => {
                        // Skip sprite collections and data - they're handled separately
                        if (key === 'shadowSprites' || key === 'rpgSprites' || key === 'morphSprites' || 
                            key === 'defaultSpriteData' || key === 'customSpriteData') {
                            // Only include if they actually changed
                            const oldVal = oldSettings[key];
                            const newVal = newSettings[key];
                            if (JSON.stringify(oldVal) !== JSON.stringify(newVal)) {
                                changedSettings[key] = newVal;
                            }
                        } else if (oldSettings[key] !== newSettings[key]) {
                            changedSettings[key] = newSettings[key];
                        }
                    });
                    // Only call updateSettings if something actually changed
                    if (Object.keys(changedSettings).length > 0) {
                        widget.updateSettings(changedSettings);
                    }
                    // Sync sprite mode dropdown in Quick Settings overlay when Dashboard changes it (cross-window)
                    // Only update if value actually changed to prevent infinite loops
                    if (newSettings.spriteMode !== undefined) {
                        const quickSpriteModeSelect = document.getElementById('spriteMode');
                        if (quickSpriteModeSelect && quickSpriteModeSelect.value !== newSettings.spriteMode) {
                            // Prevent triggering onchange event by temporarily removing listener
                            const oldOnchange = quickSpriteModeSelect.onchange;
                            quickSpriteModeSelect.onchange = null;
                            quickSpriteModeSelect.value = newSettings.spriteMode;
                            quickSpriteModeSelect.onchange = oldOnchange;
                        }
                    }
                } catch (err) {
                    console.error('Error parsing settings:', err);
                }
            }
        });
        
        // Also listen for custom events (for same-window updates from dashboard)
        window.addEventListener('campfireSettingsUpdate', (e) => {
            if (widget) widget.updateSettings(e.detail);
            // Sync sprite mode dropdown in Quick Settings overlay when Dashboard changes it (same-window)
            // Only update if value actually changed to prevent infinite loops
            if (e.detail && e.detail.spriteMode !== undefined) {
                const quickSpriteModeSelect = document.getElementById('spriteMode');
                if (quickSpriteModeSelect && quickSpriteModeSelect.value !== e.detail.spriteMode) {
                    // Prevent triggering onchange event by temporarily removing listener
                    const oldOnchange = quickSpriteModeSelect.onchange;
                    quickSpriteModeSelect.onchange = null;
                    quickSpriteModeSelect.value = e.detail.spriteMode;
                    quickSpriteModeSelect.onchange = oldOnchange;
                }
            }
        });
        
        // Sync current widget users to a target state (source of truth)
        function syncUsersToState(targetUsers) {
            if (!widget || !widget.users || !Array.isArray(targetUsers)) return;
            // When main has no users yet (e.g. after restart, before any !join), do not wipe
            // widget users that were restored from localStorage.
            if (targetUsers.length === 0 && widget.users.length > 0) return;

            const currentUsers = widget.users.slice();
            
            // Create maps for quick lookup (use both userId and username as keys)
            const currentUserMap = new Map();
            currentUsers.forEach(u => {
                const userIdKey = (u.userId || '').toLowerCase();
                const usernameKey = (u.username || '').toLowerCase();
                if (userIdKey) currentUserMap.set(userIdKey, u);
                if (usernameKey && usernameKey !== userIdKey) currentUserMap.set(usernameKey, u);
            });
            
            const targetUserMap = new Map();
            targetUsers.forEach(u => {
                const userIdKey = (u.userId || '').toLowerCase();
                const usernameKey = (u.username || '').toLowerCase();
                if (userIdKey) targetUserMap.set(userIdKey, u);
                if (usernameKey && usernameKey !== userIdKey) targetUserMap.set(usernameKey, u);
            });
            
            // Remove users that are no longer in the target state
            currentUsers.forEach(user => {
                const userIdKey = (user.userId || '').toLowerCase();
                const usernameKey = (user.username || '').toLowerCase();
                const shouldRemove = (userIdKey && !targetUserMap.has(userIdKey)) || 
                                   (usernameKey && !targetUserMap.has(usernameKey));
                if (shouldRemove) {
                    if (user.userId && widget.removeUserById) {
                        widget.removeUserById(user.userId);
                    } else if (user.username && widget.removeUser) {
                        widget.removeUser(user.username);
                    }
                }
            });
            
            // Add/update users to match target state
            targetUsers.forEach(user => {
                const userIdKey = (user.userId || '').toLowerCase();
                const usernameKey = (user.username || '').toLowerCase();
                if (!userIdKey && !usernameKey) return;
                
                const existingUser = currentUserMap.get(userIdKey) || currentUserMap.get(usernameKey);
                if (existingUser) {
                    let needsUpdate = false;
                    if (user.angle !== undefined && Math.abs(existingUser.angle - user.angle) > 0.1) {
                        existingUser.angle = user.angle;
                        widget.positionUserElement(existingUser);
                    }
                    if (user.color && existingUser.color !== user.color) {
                        existingUser.color = user.color;
                        needsUpdate = true;
                    }
                    if (user.selectedSprite !== undefined && existingUser.selectedSprite !== user.selectedSprite) {
                        existingUser.selectedSprite = user.selectedSprite;
                        needsUpdate = true;
                    }
                    if (user.twitchColor !== undefined && existingUser.twitchColor !== user.twitchColor) {
                        existingUser.twitchColor = user.twitchColor;
                        widget.updateUsernameTwitchColor(existingUser);
                    }
                    if (needsUpdate) {
                        widget.updateUserElement(existingUser);
                    }
                } else if (widget.addUser) {
                    widget.addUser(user.username, {
                        userId: user.userId,
                        color: user.color || '#ffffff',
                        selectedSprite: user.selectedSprite || null,
                        twitchColor: user.twitchColor || null,
                        angle: user.angle !== undefined ? user.angle : Math.random() * 360
                    });
                }
            });
        }
        
        // Listen for postMessage from dashboard (for real-time preview updates)
        // Debounce to prevent excessive updates while dragging sliders
        let updateTimeout = null;
        window.addEventListener('message', (e) => {
            if (!e.data || !widget) return;
            
            // Handle full state sync for live preview (matches actual widget exactly)
            if (e.data.type === 'syncFullState' && Array.isArray(e.data.users)) {
                syncUsersToState(e.data.users);
                return;
            }
            
            // Handle individual user sync for live preview (legacy support)
            if (e.data.type === 'syncUser' && e.data.user) {
                const user = e.data.user;
                // Check if user already exists
                const existingUser = widget.users.find(u => 
                    (u.userId && user.userId && u.userId === user.userId) ||
                    (u.username && user.username && u.username.toLowerCase() === user.username.toLowerCase())
                );
                
                if (!existingUser && widget.addUser) {
                    // Add user if not present
                    widget.addUser(user.username, {
                        userId: user.userId,
                        color: user.color || '#ffffff',
                        selectedSprite: user.selectedSprite || null,
                        angle: user.angle || Math.random() * 360
                    });
                }
                return;
            }
            
            if (e.data.type === 'updateSettings') {
                // Clear existing timeout
                if (updateTimeout) {
                    clearTimeout(updateTimeout);
                }
                // Debounce updates by 50ms (only update after user stops dragging)
                updateTimeout = setTimeout(() => {
                    widget.updateSettings(e.data.settings);
                }, 50);
            } else if (e.data.type === 'kickMember') {
                // Kick member from campfire
                if (e.data.userId) {
                    widget.removeUserById(e.data.userId);
                } else {
                    widget.removeUser(e.data.username);
                }
            } else if (e.data.type === 'memberMute') {
                // Mute/unmute member (store state for chat message filtering)
                const user = widget.users.find(u => 
                    (e.data.userId && u.userId === e.data.userId) || 
                    u.username === e.data.username
                );
                if (user) {
                    user.muted = e.data.muted;
                }
            } else if (e.data.type === 'memberStill') {
                // Prevent/allow member movement
                const user = widget.users.find(u => 
                    (e.data.userId && u.userId === e.data.userId) || 
                    u.username === e.data.username
                );
                if (user) {
                    user.still = e.data.still;
                }
            } else if (e.data.type === 'shutdown') {
                // Shutdown widget and all resources
                stopEventPolling();
                if (widget) {
                    widget.shutdown();
                }
            }
        });

        window.addEventListener('viewerMovement', (e) => {
            if (widget) widget.moveUser(e.detail.username, e.detail.direction, e.detail.speed || 15);
        });

        window.addEventListener('viewerStopMovement', (e) => {
            if (!widget) return;
            const user = widget.users.find(u => 
                u.userId === e.detail.userId || 
                u.username === e.detail.username
            );
            if (user) {
                widget.stopUserMovement(user.id);
            }
        });

        window.addEventListener('viewerColorUpdate', (e) => {
            if (!widget) return;
            // Update color for existing user
            const user = widget.users.find(u => 
                u.userId === e.detail.userId || 
                u.username === e.detail.username
            );
            if (user) {
                user.color = e.detail.color;
                widget.updateUserElement(user);
                widget.savePersistedUsers(); // Save state after color update
            }
        });

        window.addEventListener('viewerJoin', (e) => {
            if (widget) widget.addUser(e.detail.username, {
                userId: e.detail.userId,
                color: e.detail.color,
                selectedSprite: e.detail.selectedSprite || null
            });
        });

        window.addEventListener('viewerLeave', (e) => {
            if (widget) {
                if (e.detail.userId) {
                    widget.removeUserById(e.detail.userId);
                } else {
                    widget.removeUser(e.detail.username);
                }
            }
        });

        window.addEventListener('chatMessage', (e) => {
            if (widget && e.detail.message && e.detail.message.length <= 50) {
                widget.showChatMessage(e.detail.username, e.detail.message);
            }
        });

        // Listen for viewer events via storage (for cross-window communication)
        window.addEventListener('storage', (e) => {
            if (!widget) return;
            
            if (e.key === 'viewerJoin') {
                try {
                    const joinData = JSON.parse(e.newValue);
                    if (joinData.action === 'join') {
                        widget.addUser(joinData.username, {
                            userId: joinData.userId,
                            color: joinData.color,
                            selectedSprite: joinData.selectedSprite || null
                        });
                    }
                } catch (err) {
                    console.error('Error parsing join data:', err);
                }
            } else if (e.key === 'viewerLeave') {
                try {
                    const leaveData = JSON.parse(e.newValue);
                    if (leaveData.action === 'leave') {
                        if (leaveData.userId) {
                            widget.removeUserById(leaveData.userId);
                        } else {
                            widget.removeUser(leaveData.username);
                        }
                    }
                } catch (err) {
                    console.error('Error parsing leave data:', err);
                }
            } else if (e.key === 'viewerMovement') {
                // Handle viewer movement
                try {
                    const movement = JSON.parse(e.newValue);
                    widget.moveUser(movement.username || movement.displayName, movement.direction, movement.speed || 15);
                } catch (err) {
                    console.error('Error parsing movement:', err);
                }
            } else if (e.key === 'viewerColorUpdate') {
                // Handle color update
                try {
                    const colorData = JSON.parse(e.newValue);
                    const user = widget.users.find(u => 
                        u.userId === colorData.userId || 
                        u.username === colorData.username
                    );
                    if (user) {
                        user.color = colorData.color;
                        widget.updateUserElement(user);
                        widget.savePersistedUsers(); // Save state after color update
                    }
                } catch (err) {
                    console.error('Error parsing color update:', err);
                }
            } else if (e.key === 'chatMessage') {
                // Handle chat message
                try {
                    const chatData = JSON.parse(e.newValue);
                    if (chatData.message && chatData.message.length <= 50) {
                        widget.showChatMessage(chatData.username, chatData.message);
                    }
                } catch (err) {
                    console.error('Error parsing chat message:', err);
                }
            } else if (e.key === 'viewerStopMovement') {
                // Handle stop movement
                try {
                    const stopData = JSON.parse(e.newValue);
                    const user = widget.users.find(u => 
                        u.userId === stopData.userId || 
                        u.username === stopData.username
                    );
                    if (user) {
                        widget.stopUserMovement(user.id);
                    }
                } catch (err) {
                    console.error('Error parsing stop movement:', err);
                }
            }
        });

        // Listen for chat messages (this would be integrated with chat API)
        // For now, we'll create a function that can be called by chat integration
        window.handleChatMessage = function(username, message, userId = null) {
            if (!widget) return;
            if (message && message.length <= 50) {
                // Add user if they don't exist
                if (!widget.users.find(u => u.username === username)) {
                    widget.addUser(username, { userId: userId });
                }
                
                // Show chat message
                widget.showChatMessage(username, message);
            }
        };

        // Expose widget globally for external control (chat integration, etc.)
        // (Already set above during initialization)

        // Poll server for chat events (if server is running)
        let lastEventId = 0;
        let eventPollInterval = null;

        function stopEventPolling() {
            if (eventPollInterval) {
                clearInterval(eventPollInterval);
                eventPollInterval = null;
                console.log('‚úÖ Event polling stopped');
            }
        }

        function startEventPolling() {
            // Only poll if we're on localhost (server is running)
            if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
                eventPollInterval = setInterval(async () => {
                    try {
                        const response = await fetch(`http://localhost:3000/api/events?since=${lastEventId}`);
                        const data = await response.json();
                        
                        if (data.events && data.events.length > 0) {
                            data.events.forEach(event => {
                                if (event.id > lastEventId) {
                                    lastEventId = event.id;
                                }
                                
                                if (event.type === 'userJoin' && widget) {
                                    widget.addUser(event.data.username, {
                                        userId: event.data.userId,
                                        color: event.data.color,
                                        selectedSprite: event.data.selectedSprite,
                                        isSubscriber: event.data.isSubscriber,
                                        isMod: event.data.isMod,
                                        isVip: event.data.isVip,
                                        isBroadcaster: event.data.isBroadcaster
                                    });
                                } else if (event.type === 'userLeave' && widget) {
                                    if (event.data.userId) {
                                        widget.removeUserById(event.data.userId);
                                    } else {
                                        widget.removeUser(event.data.username);
                                    }
                                } else if (event.type === 'chatMessage' && widget) {
                                    widget.showChatMessage(event.data.username, event.data.message);
                                }
                            });
                        }
                    } catch (e) {
                        // Server not running or not available - that's okay
                        // Only log if we've successfully connected before
                        if (lastEventId > 0) {
                            console.log('Server not available (this is normal if server.js is not running)');
                        }
                    }
                }, 500); // Poll every 500ms
            }
        }

        // Start polling when widget is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                setTimeout(startEventPolling, 2000); // Wait 2 seconds for widget to initialize
            });
        } else {
            setTimeout(startEventPolling, 2000);
        }

        // ============================================
        // DESKTOP APP MENU BAR
        // ============================================
        
        function initDesktopMenuBar() {
            console.log('[Menu Bar] initDesktopMenuBar() called');
            
            // Check if we're in Electron (desktop app)
            const hasElectronAPI = typeof window.electronAPI !== 'undefined';
            const hasProcess = typeof window.process !== 'undefined';
            const userAgentHasElectron = navigator.userAgent.includes('Electron');
            const isDesktopApp = hasElectronAPI || hasProcess || userAgentHasElectron;
            
            console.log('[Menu Bar] Checking desktop app mode:', isDesktopApp);
            console.log('[Menu Bar] electronAPI available:', hasElectronAPI);
            console.log('[Menu Bar] User agent has Electron:', userAgentHasElectron);
            
            const menuBar = document.getElementById('desktopMenuBar');
            console.log('[Menu Bar] Menu bar element found:', !!menuBar);
            
            if (!menuBar) {
                console.error('[Menu Bar] Menu bar element not found!');
                return;
            }
            
            // Show menu bar if in Electron
            if (isDesktopApp) {
                menuBar.classList.add('desktop-app');
                console.log('[Menu Bar] Added desktop-app class');
                
                // Auto-hide menu bar after inactivity (5 seconds)
                let hideTimeout;
                const hideDelay = 5000; // 5 seconds
                
                function resetHideTimer() {
                    clearTimeout(hideTimeout);
                    menuBar.classList.remove('hidden');
                    
                    hideTimeout = setTimeout(() => {
                        menuBar.classList.add('hidden');
                        console.log('[Menu Bar] Auto-hiding after inactivity');
                    }, hideDelay);
                }
                
                // Reset timer on mouse movement or menu bar interaction
                document.addEventListener('mousemove', resetHideTimer);
                menuBar.addEventListener('mouseenter', () => {
                    clearTimeout(hideTimeout);
                    menuBar.classList.remove('hidden');
                });
                
                menuBar.addEventListener('mouseleave', () => {
                    resetHideTimer();
                });
                
                // Start the timer
                resetHideTimer();
            } else {
                console.log('[Menu Bar] Not in Electron - forcing show for debug');
                menuBar.classList.add('desktop-app');
            }
            
            if (isDesktopApp && typeof window.electronAPI !== 'undefined') {
                const btnDashboard = document.getElementById('btnDashboard');
                const btnSettings = document.getElementById('btnSettings');
                const btnMembers = document.getElementById('btnMembers');
                const btnEnd = document.getElementById('btnEnd');
                const btnKickAllUsers = document.getElementById('btnKickAllUsers');
                const btnJoinAllUsers = document.getElementById('btnJoinAllUsers');
                const statusIndicator = document.getElementById('statusIndicator');
                const statusText = document.getElementById('statusText');
                
                if (btnDashboard) {
                    btnDashboard.addEventListener('click', async () => {
                        console.log('[Widget] Dashboard button clicked');
                        // Temporarily ignore storage events to prevent glitches when Dashboard opens
                        _ignoringStorageEvents = true;
                        setTimeout(() => {
                            _ignoringStorageEvents = false;
                        }, 1000); // Ignore for 1 second after Dashboard opens
                        
                        // Open Full Settings window (dashboard.html)
                        if (window.electronAPI && window.electronAPI.openDashboard) {
                            console.log('[Widget] Calling electronAPI.openDashboard');
                            try {
                                const result = await window.electronAPI.openDashboard();
                                console.log('[Widget] openDashboard result:', result);
                            } catch (err) {
                                console.error('[Widget] Error opening dashboard:', err);
                            }
                        } else {
                            console.error('[Widget] electronAPI or openDashboard not available');
                        }
                    });
                }
                
                if (btnSettings) {
                    btnSettings.addEventListener('click', () => {
                        console.log('[Widget] Settings button (gear) clicked');
                        // Open Quick Settings overlay
                        openDashboard('quick');
                    });
                }
                
                if (btnMembers) {
                    btnMembers.addEventListener('click', () => {
                        openDashboard('members'); // Opens overlay to members tab
                    });
                }
                
                // Show All and Hide All test users buttons
                const btnShowAll = document.getElementById('btnShowAll');
                const btnHideAll = document.getElementById('btnHideAll');
                
                if (btnShowAll) {
                    btnShowAll.addEventListener('click', async () => {
                        await showAllTestUsers();
                    });
                }
                
                if (btnHideAll) {
                    btnHideAll.addEventListener('click', async () => {
                        await hideAllTestUsers();
                    });
                }

                if (btnKickAllUsers) {
                    btnKickAllUsers.addEventListener('click', async () => {
                        if (!window.electronAPI || !window.electronAPI.kickAllUsers) return;
                        if (!confirm('‚òÅÔ∏è Kick ALL (non-test) users from the campfire?')) return;
                        try {
                            await window.electronAPI.kickAllUsers();
                            if (typeof loadWidgetMembers === 'function') setTimeout(() => loadWidgetMembers(), 250);
                        } catch (e) {
                            console.error('Error kicking all users:', e);
                            alert('Failed to kick all users.');
                        }
                    });
                }

                if (btnJoinAllUsers) {
                    btnJoinAllUsers.addEventListener('click', async () => {
                        if (!window.electronAPI || !window.electronAPI.joinAllUsers) return;
                        const controlled = confirm('üî• Join ALL users from chat?\n\nOK = Controlled (follow join rules)\nCancel = Chaos (override rules)');
                        try {
                            await window.electronAPI.joinAllUsers({ mode: controlled ? 'controlled' : 'chaos' });
                            if (typeof loadWidgetMembers === 'function') setTimeout(() => loadWidgetMembers(), 250);
                        } catch (e) {
                            console.error('Error joining all users:', e);
                            alert('Failed to join all users.');
                        }
                    });
                }
                
                if (btnEnd) {
                    btnEnd.addEventListener('click', async () => {
                        if (confirm('Are you sure you want to shut down the widget and all servers?')) {
                            await window.electronAPI.shutdownApp();
                        }
                    });
                }
                
                if (window.electronAPI) {
                    window.electronAPI.onTwitchConnected(() => {
                        if (statusIndicator) statusIndicator.classList.add('connected');
                        if (statusText) statusText.textContent = 'Connected';
                    });
                    
                    window.electronAPI.onTwitchDisconnected(() => {
                        if (statusIndicator) statusIndicator.classList.remove('connected');
                        if (statusText) statusText.textContent = 'Disconnected';
                    });
                    
                    // Listen for chat messages from Twitch (bubbles above joined users)
                    window.electronAPI.onChatMessage((data) => {
                        const msg = String(data && data.message ? data.message : '').trim();
                        if (msg.startsWith('!')) return; // Never show command-like messages as bubbles
                        if (widget && data.username && msg) {
                            widget.showChatMessage(data.username, data.message, data.userId, data.emotes);
                        }
                    });

                    // Third-party emotes (BTTV/FFZ/7TV) are pushed from main once connected.
                    // Used to render emote codes like "heafthCamp" when Twitch IRC tags.emotes is empty.
                    window.__thirdPartyEmotes = window.__thirdPartyEmotes || {};
                    if (window.electronAPI.getThirdPartyEmotes) {
                        window.electronAPI.getThirdPartyEmotes()
                            .then((data) => {
                                window.__thirdPartyEmotes = (data && data.emotes && typeof data.emotes === 'object') ? data.emotes : {};
                            })
                            .catch(() => {});
                    }
                    if (window.electronAPI.onThirdPartyEmotesUpdate) {
                        window.electronAPI.onThirdPartyEmotesUpdate((data) => {
                            window.__thirdPartyEmotes = (data && data.emotes && typeof data.emotes === 'object') ? data.emotes : {};
                        });
                    }
                    
                    // Refresh widget Members list when chatters/potential members update (so it stays in sync with dashboard)
                    if (window.electronAPI.onPotentialMembersUpdate) {
                        window.electronAPI.onPotentialMembersUpdate(() => {
                            if (typeof loadWidgetMembers === 'function') loadWidgetMembers();
                        });
                    }

                    // Keep "Active in chat" (last N minutes) display fresh while Members tab is open
                    if (!_widgetMembersStatusInterval) {
                        _widgetMembersStatusInterval = setInterval(() => {
                            try {
                                const sec = document.getElementById('membersSection');
                                if (!sec || !sec.classList.contains('active')) return;
                                const cached = window.__widgetMembersCache;
                                if (Array.isArray(cached) && typeof renderWidgetMembers === 'function') {
                                    renderWidgetMembers(cached);
                                }
                            } catch (e) { /* ignore */ }
                        }, 30 * 1000);
                    }
                    
                    window.electronAPI.getTwitchStatus().then(status => {
                        if (status.connected) {
                            if (statusIndicator) statusIndicator.classList.add('connected');
                            if (statusText) statusText.textContent = 'Connected';
                        }
                    }).catch(err => {
                        console.error('[Menu Bar] Error getting Twitch status:', err);
                    });
                }
            } else if (isDesktopApp) {
                setTimeout(() => {
                    if (typeof window.electronAPI !== 'undefined') {
                        initDesktopMenuBar();
                    }
                }, 500);
            }
        }
        
        // Initialize menu bar
        console.log('[Menu Bar] Script loaded, readyState:', document.readyState);
        
        if (document.readyState === 'complete' || document.readyState === 'interactive') {
            setTimeout(initDesktopMenuBar, 100);
        } else {
            document.addEventListener('DOMContentLoaded', () => {
                setTimeout(initDesktopMenuBar, 100);
            });
        }
        
        window.addEventListener('load', () => {
            setTimeout(initDesktopMenuBar, 200);
        });
        
        setTimeout(() => {
            const menuBar = document.getElementById('desktopMenuBar');
            if (menuBar && !menuBar.classList.contains('desktop-app')) {
                initDesktopMenuBar();
            }
        }, 1000);
        
        // ============================================
        // XSS HELPERS (escape before innerHTML/onclick)
        // ============================================
        function escapeHtml(str) { if (str == null) return ''; var s = String(str); return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#39;'); }
        function escapeJsQuoted(str) { if (str == null) return ''; return String(str).replace(/\\/g,'\\\\').replace(/'/g,"\\'").replace(/\r/g,'\\r').replace(/\n/g,'\\n'); }

        // ============================================
        // INTEGRATED DASHBOARD FUNCTIONS
        // ============================================
        function openDashboard(tab = 'quick') {
            const overlay = document.getElementById('dashboardOverlay');
            if (overlay) {
                overlay.classList.add('active');
                switchDashboardTab(tab);
                loadDashboardData();
            }
        }
        
        function closeDashboard() {
            const overlay = document.getElementById('dashboardOverlay');
            if (overlay) {
                overlay.classList.remove('active');
            }
        }
        
        function switchDashboardTab(tabName) {
            console.log('[Dashboard] Switching to tab:', tabName);
            
            // Update tab buttons
            document.querySelectorAll('.dashboard-tab').forEach(tab => {
                tab.classList.remove('active');
                if (tab.onclick && tab.onclick.toString().includes(tabName)) {
                    tab.classList.add('active');
                }
            });
            
            // Update sections
            document.querySelectorAll('.dashboard-section').forEach(section => {
                section.classList.remove('active');
            });
            
            const sectionMap = {
                'quick': 'quickSection',
                'members': 'membersSection'
            };
            
            const targetSection = document.getElementById(sectionMap[tabName]);
            if (targetSection) {
                targetSection.classList.add('active');
                console.log('[Dashboard] Activated section:', sectionMap[tabName]);
                
                // Load members when switching to members tab
                if (tabName === 'members') {
                    loadWidgetMembers();
                }
            } else {
                console.error('[Dashboard] Section not found:', sectionMap[tabName]);
            }
        }
        
        async function loadWidgetMembers() {
            const membersList = document.getElementById('membersList');
            if (!membersList) return;
            
            try {
                // Get active users from widget
                const users = window.widget?.users || [];
                
                // Also check electronAPI for more complete data
                let allMembers = [];
                if (window.electronAPI && window.electronAPI.getActiveUsers) {
                    const activeUsers = await window.electronAPI.getActiveUsers();
                    const potentialUsers = await window.electronAPI.getPotentialMembers?.() || [];
                    const userMap = new Map();
                    const usernameToKey = new Map(); // usernameLower -> canonical key
                    const normName = (v) => (v ? String(v).toLowerCase() : '');
                    const normId = (v) => (v == null ? '' : String(v));
                    const keyFor = (userId, username) => {
                        const id = normId(userId);
                        const name = normName(username);
                        if (id) {
                            if (name) usernameToKey.set(name, id);
                            return id;
                        }
                        if (name) return usernameToKey.get(name) || name;
                        return '';
                    };
                    const upsert = (rec) => {
                        const key = keyFor(rec.userId, rec.username);
                        if (!key) return;
                        const existing = userMap.get(key);
                        if (existing) {
                            existing.joined = !!existing.joined || !!rec.joined;
                            if (rec.username) existing.username = existing.username || rec.username;
                            existing.userId = key;
                            if (rec.color) existing.color = rec.color;
                            if (rec.twitchColor) existing.twitchColor = rec.twitchColor;
                            if (rec.lastMessage) existing.lastMessage = Math.max(existing.lastMessage || 0, rec.lastMessage);
                        } else {
                            userMap.set(key, { ...rec, userId: key });
                        }
                    };

                    const activeSet = new Set();
                    const potentialSet = new Set();
                    const widgetSet = new Set();
                    const addPresence = (set, userId, username) => {
                        const id = normId(userId);
                        const name = normName(username);
                        if (id) set.add(id);
                        if (name) set.add(name);
                    };
                    activeUsers.forEach(u => addPresence(activeSet, u.userId, u.username));
                    potentialUsers.forEach(p => addPresence(potentialSet, p.userId, p.username));
                    users.forEach(w => addPresence(widgetSet, w.userId, w.username));

                    // Order matters: add sources with userId first so later username-only rows merge correctly
                    activeUsers.forEach(u => upsert({ username: u.username, userId: u.userId, joined: true, restored: false, twitchColor: u.twitchColor || null, color: u.color || null }));
                    users.forEach(u => upsert({ username: u.username, userId: u.userId, joined: true, restored: true, twitchColor: u.twitchColor || null, color: u.color || null }));
                    potentialUsers.forEach(p => upsert({ username: p.username, userId: p.userId, joined: false, restored: false, twitchColor: p.color || null, lastMessage: p.lastMessage || null }));
                    
                    // Ensure test users are always present
                    ['TestUser1', 'TestUser2', 'TestUser3'].forEach(testUser => {
                        upsert({ username: testUser, userId: testUser.toLowerCase(), joined: false, restored: false });
                    });
                    
                    allMembers = Array.from(userMap.values()).map(m => {
                        const id = normId(m.userId);
                        const name = normName(m.username);
                        const inWidget = widgetSet.has(id) || (name && widgetSet.has(name));
                        const inActive = activeSet.has(id) || (name && activeSet.has(name));
                        const inPotential = potentialSet.has(id) || (name && potentialSet.has(name));
                        return {
                            ...m,
                            inCampfire: !!(inWidget || inActive),
                            inChat: !!inPotential,
                            restored: !!(inWidget && !inActive && !inPotential)
                        };
                    });
                } else {
                    // Fallback: just use widget users
                    allMembers = users.map(u => ({
                        username: u.username,
                        userId: u.userId || u.username.toLowerCase(),
                        joined: true,
                        color: u.color
                    }));
                }
                
                if (allMembers.length === 0) {
                    membersList.innerHTML = '<p style="color: #888; text-align: center; padding: 20px;">No members yet. Users will appear here when they join.</p>';
                    return;
                }
                
                window.__widgetMembersCache = allMembers;
                renderWidgetMembers(allMembers);
            } catch (error) {
                console.error('[Widget] Error loading members:', error);
                membersList.innerHTML = '<p style="color: #f44; text-align: center; padding: 20px;">Error loading members</p>';
            }
        }

        const WIDGET_ACTIVE_WINDOW_MS = 10 * 60 * 1000; // "recently active in chat" window
        let _widgetMembersStatusInterval = null;

        function renderWidgetMembers(allMembers) {
            const membersList = document.getElementById('membersList');
            if (!membersList) return;
            const now = Date.now();
            if (!Array.isArray(allMembers) || allMembers.length === 0) {
                membersList.innerHTML = '<p style="color: #888; text-align: center; padding: 20px;">No members yet. Users will appear here when they join.</p>';
                return;
            }

            // Render member list with identical styling to dashboard
            const uid = m => escapeJsQuoted(m.userId || '');
            const uname = m => escapeJsQuoted(m.username || '');
            const unameH = m => escapeHtml(m.username || '');

            membersList.innerHTML = allMembers.map(member => {
                    const isTestUser = member.username && member.username.startsWith('TestUser');
                    const inChat = !!member.inChat;
                    const lastMessage = member.lastMessage || 0;
                    const recentlyActive = !!(lastMessage && (now - lastMessage) <= WIDGET_ACTIVE_WINDOW_MS);
                    const inCampfire = !!(member.inCampfire || member.joined);
                    const status = inCampfire ? (inChat ? 'joined' : 'sleepy') : (recentlyActive ? 'active' : 'not-joined');
                    const twitchColor = member.twitchColor || member.color || null;
                    const nameColor = (status === 'joined' || status === 'sleepy') ? (twitchColor || '#fff') : (status === 'active' ? '#fff' : '#777');
                    const zzz = (status === 'sleepy') ? '<span class="member-zzz" title="In campfire, but not in chat (sleepy/disconnected?)">zzz</span>' : '';
                    const statusText =
                        (status === 'joined') ? 'Joined' :
                        (status === 'sleepy') ? 'Sleeping' :
                        (status === 'active') ? 'Active in chat' :
                        'Not joined';
                    const u = uid(member);
                    const n = uname(member);
                    const nh = unameH(member);
                    if (isTestUser) {
                        return `
                            <div class="member-item" style="background: #1f1f1f; border: 1px solid #3a3a3a; border-radius: 6px; padding: 8px 12px; margin-bottom: 8px; display: flex; justify-content: space-between; align-items: center; min-height: 40px;">
                                <div class="member-info" style="flex: 1; display: flex; align-items: center; gap: 10px;">
                                    <span class="member-name" style="font-family: 'UsernameFont', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; font-weight: bold; font-size: 14px; color: #fff;">${nh}</span>
                                    <span class="member-status" style="font-size: 11px; color: #888;">${member.joined ? 'Joined' : 'Not joined'}</span>
                                </div>
                                <div class="member-actions" style="display: flex; gap: 8px; align-items: center;">
                                    <button onclick="widgetOpenMemberEdit('${u}', '${n}')" style="padding: 6px 12px; background: #444; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: 600;">Edit</button>
                                    <div class="toggle-switch ${member.joined ? 'active' : ''}" onclick="widgetToggleTestUser('${u}', '${n}')" style="cursor: pointer; width: 50px; height: 24px; background: ${member.joined ? '#4caf50' : '#444'}; border-radius: 12px; position: relative; transition: background 0.3s; box-shadow: inset 0 1px 3px rgba(0,0,0,0.3);">
                                        <div style="position: absolute; top: 2px; left: ${member.joined ? '28px' : '2px'}; width: 20px; height: 20px; background: white; border-radius: 50%; transition: left 0.3s ease; box-shadow: 0 2px 4px rgba(0,0,0,0.2);"></div>
                                    </div>
                                </div>
                            </div>
                        `;
                    } else {
                        const restoredIcon = member.restored ? '<span title="Restored from previous session; may have disconnected" style="margin-left:4px;opacity:0.85;" aria-label="Restored">üìå</span>' : '';
                        return `
                            <div class="member-item" style="background: #1f1f1f; border: 1px solid #3a3a3a; border-radius: 6px; padding: 8px 12px; margin-bottom: 8px; display: flex; justify-content: space-between; align-items: center; min-height: 40px;">
                                <div class="member-info" style="flex: 1; display: flex; align-items: center; gap: 10px;">
                                    <span class="member-name status-${status}" style="font-family: 'UsernameFont', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; font-weight: bold; font-size: 14px; color: ${nameColor};">${nh}</span>${zzz}${restoredIcon}
                                    <span class="member-status" style="font-size: 11px; color: #888;">${statusText}</span>
                                </div>
                                <div class="member-actions" style="display: flex; gap: 8px; align-items: center;">
                                    ${member.joined 
                                        ? `<button onclick="widgetLeaveMember('${u}', '${n}')" style="padding: 6px 12px; background: #ff4444; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: 600;">Leave</button>`
                                        : `<button onclick="widgetJoinMember('${u}', '${n}')" style="padding: 6px 12px; background: #4caf50; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: 600;">Join</button>`
                                    }
                                    <button onclick="widgetOpenMemberEdit('${u}', '${n}')" style="padding: 6px 12px; background: #444; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: 600;">Edit</button>
                                </div>
                            </div>
                        `;
                    }
                }).join('');
        }
        
        async function widgetToggleTestUser(userId, username) {
            if (!window.electronAPI) return;
            
            try {
                const widgetUsers = await window.electronAPI.getWidgetUsers?.() || window.widget?.users || [];
                const isInWidget = widgetUsers.find(w => {
                    const wUserId = (w.userId || '').toLowerCase();
                    const wUsername = (w.username || '').toLowerCase();
                    const checkUserId = (userId || '').toLowerCase();
                    const checkUsername = (username || '').toLowerCase();
                    return wUserId === checkUserId || wUsername === checkUsername;
                });
                
                if (isInWidget) {
                    // Remove user
                    const result = await window.electronAPI.removeTestUserFromWidget(userId, username);
                    if (!result || !result.success) {
                        console.error('Failed to remove test user:', result);
                        return;
                    }
                } else {
                    // Add user
                    const result = await window.electronAPI.addTestUserToWidget(userId, username);
                    if (!result || !result.success) {
                        console.error('Failed to add test user:', result);
                        return;
                    }
                }
                
                // Refresh the members list
                setTimeout(() => loadWidgetMembers(), 200);
                
            } catch (error) {
                console.error('Error toggling test user:', error);
            }
        }
        
        async function widgetJoinMember(userId, username) {
            if (!window.electronAPI || !window.electronAPI.joinMember) {
                alert('Join functionality not available');
                return;
            }
            
            try {
                const result = await window.electronAPI.joinMember(userId, username);
                if (result && result.success) {
                    setTimeout(() => loadWidgetMembers(), 200);
                } else {
                    alert('Failed to join member');
                }
            } catch (error) {
                console.error('Error joining member:', error);
                alert('Error: ' + error.message);
            }
        }
        
        async function widgetLeaveMember(userId, username) {
            if (!window.electronAPI || !window.electronAPI.kickMember) {
                alert('Leave functionality not available');
                return;
            }
            
            try {
                const result = await window.electronAPI.kickMember(userId);
                if (result && result.success) setTimeout(() => loadWidgetMembers(), 200);
            } catch (error) {
                console.error('Error removing member:', error);
                alert('Error: ' + error.message);
            }
        }
        
        function widgetOpenMemberEdit(userId, username) {
            // Open the Viewer Dashboard (sprite settings) for this member
            if (window.electronAPI && window.electronAPI.openMemberDashboard) {
                window.electronAPI.openMemberDashboard(userId, username);
            } else {
                alert(`Edit settings for ${username} - Viewer Dashboard not available`);
            }
        }
        
        async function removeTestUser(userId, username) {
            if (!window.electronAPI || !window.electronAPI.removeTestUserFromWidget) {
                alert('Test user removal not available');
                return;
            }
            
            try {
                const result = await window.electronAPI.removeTestUserFromWidget(userId, username);
                if (result && result.success) {
                    // Refresh the members list
                    setTimeout(() => loadWidgetMembers(), 200);
                } else {
                    alert('Failed to remove test user');
                }
            } catch (error) {
                console.error('Error removing test user:', error);
                alert('Error: ' + error.message);
            }
        }
        
        function openFullSettings() {
            if (window.electronAPI && window.electronAPI.openDashboard) {
                closeDashboard();
                window.electronAPI.openDashboard();
            }
        }
        
        function updateMaxUsers() {
            const maxUsers = document.getElementById('maxUsers')?.value;
            if (maxUsers && window.widget) {
                const maxUsersInt = parseInt(maxUsers);
                window.widget.updateSettings({ maxUsers: maxUsersInt });
            }
        }
        
        async function loadDashboardData() {
            // Load current settings from localStorage (source of truth) to ensure sync with Dashboard
            // This ensures Quick Settings and Dashboard are always in sync
            try {
                const savedSettings = JSON.parse(localStorage.getItem('campfireWidgetSettings') || '{}');
                const settings = window.widget ? { ...window.widget.settings, ...savedSettings } : savedSettings;
                
                // Populate sprite mode
                const spriteModeSelect = document.getElementById('spriteMode');
                if (spriteModeSelect && settings.spriteMode) {
                    spriteModeSelect.value = settings.spriteMode;
                }
                
                // Populate max users
                const maxUsersInput = document.getElementById('maxUsers');
                if (maxUsersInput && settings.maxUsers) {
                    maxUsersInput.value = settings.maxUsers;
                }
                
                // Populate join method
                const joinMethodSelect = document.getElementById('joinMethod');
                if (joinMethodSelect && settings.joinMethod) {
                    joinMethodSelect.value = settings.joinMethod;
                }
                
                // Trigger updateJoinMethod to show/hide cheer settings
                if (typeof updateJoinMethod === 'function') {
                    updateJoinMethod();
                }
            } catch (err) {
                console.error('Error loading dashboard data:', err);
            }
            
            // Load Twitch config from electron
            if (window.electronAPI && window.electronAPI.getTwitchConfig) {
                try {
                    const config = await window.electronAPI.getTwitchConfig();
                    if (config) {
                        const usernameInput = document.getElementById('twitchUsername');
                        const channelInput = document.getElementById('twitchChannel');
                        if (usernameInput) usernameInput.value = config.username || '';
                        if (channelInput) channelInput.value = config.channel || '';
                    }
                } catch (err) {
                    console.error('Failed to load Twitch config:', err);
                }
            }
            
            // Load members list
            if (window.widget && window.widget.users) {
                updateMembersList();
            }
        }
        
        async function showAllTestUsers() {
            if (window.electronAPI && window.electronAPI.joinAllTestUsers) {
                try {
                    await window.electronAPI.joinAllTestUsers();
                    updateMembersList();
                } catch (err) {
                    console.error('Failed to show test users:', err);
                    alert('Failed to show test users: ' + err.message);
                }
            }
        }
        
        async function hideAllTestUsers() {
            if (window.electronAPI && window.electronAPI.kickAllTestUsers) {
                try {
                    await window.electronAPI.kickAllTestUsers();
                    updateMembersList();
                } catch (err) {
                    console.error('Failed to hide test users:', err);
                    alert('Failed to hide test users: ' + err.message);
                }
            }
        }
        
        function updateMembersList() {
            const membersList = document.getElementById('membersList');
            if (!membersList) return;
            
            if (!window.widget || !window.widget.users || window.widget.users.length === 0) {
                membersList.innerHTML = '<p style="color: #888;">No members yet. Users will appear here when they join.</p>';
                return;
            }
            
            membersList.innerHTML = window.widget.users.map(user => {
                const u = escapeJsQuoted(user.userId || user.username || '');
                const nh = escapeHtml(user.username || '');
                return `
                <div class="member-item">
                    <div>
                        <span class="member-name">${nh}</span>
                        <span class="member-status">Active</span>
                    </div>
                    <div class="member-actions">
                        <button class="button button-secondary" style="padding: 6px 12px; font-size: 12px;" onclick="kickUser('${u}')">Remove</button>
                    </div>
                </div>
            `;
            }).join('');
        }
        
        async function kickUser(userId) {
            if (window.electronAPI && window.electronAPI.kickUser) {
                try {
                    await window.electronAPI.kickUser(userId);
                    updateMembersList();
                } catch (err) {
                    console.error('Failed to kick user:', err);
                }
            }
        }
        
        async function saveTwitchConfig() {
            const username = document.getElementById('twitchUsername')?.value;
            const channel = document.getElementById('twitchChannel')?.value;
            
            if (!username || !channel) {
                alert('Please enter both username and channel');
                return;
            }
            
            if (window.electronAPI && window.electronAPI.saveTwitchConfig) {
                try {
                    await window.electronAPI.saveTwitchConfig({ username, channel });
                    alert('Twitch configuration saved! The widget will attempt to connect.');
                } catch (err) {
                    console.error('Failed to save Twitch config:', err);
                    alert('Failed to save configuration: ' + err.message);
                }
            }
        }
        
        // Flag to prevent infinite loops when syncing dropdowns
        let _syncingSpriteMode = false;
        
        function updateSpriteMode() {
            // Prevent infinite loops
            if (_syncingSpriteMode) return;
            
            const spriteMode = document.getElementById('spriteMode')?.value;
            if (spriteMode && window.widget) {
                _syncingSpriteMode = true;
                try {
                    // Use updateSettings instead of reloading - this preserves users
                    window.widget.updateSettings({ spriteMode: spriteMode });
                    // Also update localStorage for persistence and sync with Dashboard
                    const currentSettings = JSON.parse(localStorage.getItem('campfireWidgetSettings') || '{}');
                    // Only save if value actually changed
                    if (currentSettings.spriteMode !== spriteMode) {
                        currentSettings.spriteMode = spriteMode;
                        localStorage.setItem('campfireWidgetSettings', JSON.stringify(currentSettings));
                        // Dispatch event for same-window sync (Dashboard overlay doesn't use storage events)
                        window.dispatchEvent(new CustomEvent('campfireSettingsUpdate', { detail: { spriteMode: spriteMode } }));
                    }
                } catch (e) {
                    console.error('Error saving sprite mode:', e);
                } finally {
                    _syncingSpriteMode = false;
                }
            }
        }
        
        function updateJoinMethod() {
            const joinMethod = document.getElementById('joinMethod')?.value;
            if (joinMethod && window.widget) {
                window.widget.updateSettings({ joinMethod: joinMethod });
            }
            
            // Show/hide cheer settings in Quick Settings tab
            const quickCheerSettings = document.getElementById('quickCheerSettings');
            if (quickCheerSettings) {
                const currentJoinMethod = document.getElementById('joinMethod')?.value;
                if (currentJoinMethod === 'cheer') {
                    quickCheerSettings.style.display = 'block';
                } else {
                    quickCheerSettings.style.display = 'none';
                }
            }
        }
        
        // Close dashboard with Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeDashboard();
            }
        });
        
        // Close dashboard when clicking backdrop
        document.getElementById('dashboardOverlay')?.addEventListener('click', (e) => {
            if (e.target.id === 'dashboardOverlay') {
                closeDashboard();
            }
        });
    </script>
</body>
</html>
