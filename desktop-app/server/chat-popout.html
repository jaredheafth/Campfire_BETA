<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Twitch Chat - Campfire Widget</title>
    <link rel="stylesheet" href="styles/shared-styles.css">
    <style>
        @font-face {
            font-family: 'W95FA';
            src: url('fonts/w95fa.woff2') format('woff2'),
                 url('fonts/w95fa.woff') format('woff'),
                 url('fonts/W95FA.otf') format('opentype');
            font-weight: normal;
            font-style: normal;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html, body {
            background: transparent !important;
            height: 100vh;
            overflow: hidden;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            color: #efeff1;
            display: flex;
            flex-direction: column;
        }
        
        /* Main container with semi-transparent background */
        .chat-window {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: rgba(30, 30, 30, 0.5);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            margin: 8px;
            overflow: hidden;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
        }
        
        /* Top menu bar - similar to Visual Display */
        .menu-bar {
            display: flex;
            justify-content: flex-start;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: rgba(18, 18, 18, 0.92);
            border-bottom: 1px solid rgba(255, 255, 255, 0.14);
            border-radius: 12px 12px 0 0;
            -webkit-app-region: drag;
            position: relative;
        }
        
        /* Chat title */
        .chat-title {
            font-family: 'W95FA', sans-serif;
            font-size: 12px;
            font-weight: bold;
            color: #efeff1;
            margin-right: auto;
        }
        
        /* Menu buttons - styled like Visual Display widget menu */
        .menu-button {
            padding: 6px 12px;
            min-height: 28px;
            background: rgba(28, 28, 28, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 6px;
            color: #fff;
            cursor: pointer;
            -webkit-app-region: no-drag;
            transition: all 0.2s;
            font-size: 12px;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            white-space: nowrap;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
        }
        
        .menu-button:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.3);
        }
        
        .menu-button:active {
            background: rgba(255, 255, 255, 0.15);
        }
        
        .menu-button.active {
            background: rgba(145, 71, 255, 0.3);
            border-color: rgba(145, 71, 255, 0.5);
        }
        
        /* Icon-only button style */
        .menu-button-icon {
            padding: 6px 8px;
            min-width: 28px;
        }
        
        /* Close button - styled like END button on widget menu */
        .close-button {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            padding: 6px 12px;
            min-height: 28px;
            background: rgba(255, 59, 48, 0.3);
            border: 1px solid rgba(255, 59, 48, 0.5);
            border-radius: 6px;
            color: #fff;
            cursor: pointer;
            -webkit-app-region: no-drag;
            transition: all 0.2s;
            font-size: 12px;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-weight: 600;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        
        .close-button:hover {
            background: rgba(255, 59, 48, 0.5);
            border-color: rgba(255, 59, 48, 0.7);
        }
        
        /* Settings dropdown */
        .settings-dropdown {
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(18, 18, 18, 0.98);
            border: 1px solid rgba(255, 255, 255, 0.14);
            border-radius: 8px;
            padding: 12px;
            display: none;
            z-index: 100;
            min-width: 200px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
        }
        
        .settings-dropdown.show {
            display: block;
        }
        
        .settings-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .settings-row:last-child {
            border-bottom: none;
        }
        
        .settings-row label {
            font-size: 12px;
            color: #adadb8;
        }
        
        .settings-action-btn {
            width: 100%;
            padding: 8px 12px;
            background: rgba(28, 28, 28, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 6px;
            color: #fff;
            font-size: 12px;
            cursor: pointer;
            text-align: left;
            transition: all 0.2s;
            font-family: inherit;
        }
        
        .settings-action-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.3);
        }
        
        .settings-action-btn:active {
            background: rgba(145, 71, 255, 0.3);
        }
        
        .settings-row select {
            background: rgba(28, 28, 28, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 4px;
            color: #fff;
            padding: 4px 8px;
            font-size: 12px;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        
        /* Chat container */
        .chat-container {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        
        /* Chat message */
        .chat-message {
            padding: 6px 10px;
            border-radius: 6px;
            line-height: 1.4;
            word-wrap: break-word;
            background: rgba(255, 255, 255, 0.03);
            font-size: 12px; /* Match buddy list font size */
        }
        
        .chat-message:hover {
            background: rgba(255, 255, 255, 0.08);
        }
        
        .chat-username {
            font-weight: 600;
            cursor: pointer;
        }
        
        .chat-username:hover {
            text-decoration: underline;
        }
        
        .chat-text {
            color: #efeff1;
        }
        
        /* Non-camper messages (greyed out when toggle is on) */
        .chat-message.non-camper {
            opacity: 0.5;
        }
        
        .chat-message.non-camper .chat-username,
        .chat-message.non-camper .chat-text {
            color: #888;
        }
        
        /* Bot response messages (narrative style) */
        .chat-message.bot-response {
            font-style: italic;
            color: #b0b0b0;
        }
        
        /* Emotes */
        .chat-emote {
            height: 28px;
            width: auto;
            vertical-align: middle;
            margin: -4px 2px;
        }
        
        /* Badges */
        .chat-badge {
            height: 18px;
            width: auto;
            vertical-align: middle;
            margin-right: 4px;
        }
        
        /* Empty state */
        .empty-state {
            color: #adadb8;
            text-align: center;
            padding: 40px 20px;
            font-size: 13px;
        }
        
        /* Scrollbar styling */
        .chat-container::-webkit-scrollbar {
            width: 6px;
        }
        
        .chat-container::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 3px;
        }
        
        .chat-container::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
        }
        
        .chat-container::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        
        /* Chat input area */
        .chat-input-area {
            display: flex;
            gap: 8px;
            padding: 10px 12px;
            background: rgba(18, 18, 18, 0.8);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 0 0 12px 12px;
            position: relative;
        }
        
        .chat-input {
            flex: 1;
            background: rgba(28, 28, 28, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 6px;
            color: #fff;
            padding: 8px 12px;
            font-size: 13px;
            outline: none;
            transition: border-color 0.2s;
        }
        
        .chat-input:focus {
            border-color: rgba(145, 71, 255, 0.5);
        }
        
        .chat-input::placeholder {
            color: rgba(255, 255, 255, 0.4);
        }
        
        .send-button {
            padding: 8px 16px;
            background: rgba(145, 71, 255, 0.3);
            border: 1px solid rgba(145, 71, 255, 0.5);
            border-radius: 6px;
            color: #fff;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 12px;
            font-weight: 600;
        }
        
        .send-button:hover {
            background: rgba(145, 71, 255, 0.5);
            border-color: rgba(145, 71, 255, 0.7);
        }
        
        .send-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        /* Speaker select dropdown */
        .speaker-select {
            padding: 8px 10px;
            background: rgba(28, 28, 28, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 6px;
            color: #fff;
            cursor: pointer;
            font-size: 11px;
            min-width: 100px;
        }
        
        .speaker-select:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.25);
        }
        
        .speaker-select option {
            background: #1e1e1e;
            color: #fff;
        }
        
        /* Emote/Emoji picker button */
        .emote-button {
            padding: 8px 12px;
            background: rgba(28, 28, 28, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 6px;
            color: #fff;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 16px;
        }
        
        .emote-button:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.3);
        }
        
        .emote-button.active {
            background: rgba(145, 71, 255, 0.3);
            border-color: rgba(145, 71, 255, 0.5);
        }
        
        /* Emoji/Emote Picker Panel */
        .picker-panel {
            position: absolute;
            bottom: 100%;
            right: 0;
            width: 320px;
            max-height: 350px;
            background: rgba(18, 18, 18, 0.98);
            border: 1px solid rgba(255, 255, 255, 0.14);
            border-radius: 8px;
            margin-bottom: 8px;
            display: none;
            flex-direction: column;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
            z-index: 100;
        }
        
        .picker-panel.show {
            display: flex;
        }
        
        .picker-tabs {
            display: flex;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .picker-tab {
            flex: 1;
            padding: 10px;
            background: transparent;
            border: none;
            color: #adadb8;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }
        
        .picker-tab:hover {
            background: rgba(255, 255, 255, 0.05);
            color: #fff;
        }
        
        .picker-tab.active {
            background: rgba(145, 71, 255, 0.2);
            color: #fff;
            border-bottom: 2px solid rgba(145, 71, 255, 0.7);
        }
        
        .picker-search {
            padding: 8px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .picker-search input {
            width: 100%;
            padding: 6px 10px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            color: #fff;
            font-size: 12px;
        }
        
        .picker-search input::placeholder {
            color: #888;
        }
        
        .picker-search input:focus {
            outline: none;
            border-color: rgba(145, 71, 255, 0.5);
            background: rgba(255, 255, 255, 0.15);
        }
        
        .picker-content {
            flex: 1;
            overflow-y: auto;
            padding: 8px;
        }
        
        .picker-grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 4px;
        }
        
        .picker-item {
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            border-radius: 4px;
            transition: background 0.15s;
            font-size: 20px;
        }
        
        .picker-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
        .picker-item img {
            max-width: 24px;
            max-height: 24px;
        }
        
        .picker-category {
            font-size: 11px;
            color: #888;
            padding: 8px 4px 4px;
            text-transform: uppercase;
        }
        
        .picker-loading {
            text-align: center;
            padding: 20px;
            color: #888;
            font-size: 12px;
        }
        
        .picker-empty {
            text-align: center;
            padding: 20px;
            color: #888;
            font-size: 12px;
        }
        
        /* Font styles */
        body.font-default {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        
        body.font-default .chat-message {
            /* Messages use body font (unstyled) */
        }
        
        body.font-default .chat-input {
            font-family: inherit;
        }
        
        body.font-w95fa {
            font-family: 'W95FA', monospace;
        }
        
        body.font-w95fa .chat-input {
            font-family: 'W95FA', monospace;
        }
        
        body.font-tahoma {
            font-family: Tahoma, Arial, sans-serif;
        }
        
        /* Font size classes */
        body.font-size-small .chat-message {
            font-size: 12px;
        }
        
        body.font-size-medium .chat-message {
            font-size: 14px;
        }
        
        body.font-size-large .chat-message {
            font-size: 16px;
        }
        
        /* Also apply to input */
        body.font-size-small .chat-input {
            font-size: 12px;
        }
        
        body.font-size-medium .chat-input {
            font-size: 14px;
        }
        
        body.font-size-large .chat-input {
            font-size: 16px;
        }
        
        /* @ Mention Autocomplete Dropdown */
        .mention-dropdown {
            position: absolute;
            bottom: 100%;
            left: 110px; /* Align with chat input, accounting for speaker select */
            right: 90px; /* Account for buttons on right */
            background: rgba(18, 18, 18, 0.98);
            border: 1px solid rgba(145, 71, 255, 0.5);
            border-radius: 8px;
            max-height: 200px;
            overflow-y: auto;
            display: none;
            z-index: 200;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
            margin-bottom: 8px;
        }
        
        .mention-dropdown.show {
            display: block;
        }
        
        .mention-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            cursor: pointer;
            transition: background 0.15s;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }
        
        .mention-item:last-child {
            border-bottom: none;
        }
        
        .mention-item:hover,
        .mention-item.selected {
            background: rgba(145, 71, 255, 0.3);
        }
        
        .mention-item.selected {
            border-left: 3px solid rgba(145, 71, 255, 0.8);
        }
        
        .mention-avatar {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: rgba(145, 71, 255, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: 600;
            color: #fff;
            text-transform: uppercase;
        }
        
        .mention-username {
            flex: 1;
            font-size: 13px;
            color: #fff;
        }
        
        .mention-badge {
            font-size: 11px;
            padding: 2px 6px;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.1);
            color: #adadb8;
        }
        
        .mention-badge.broadcaster {
            background: rgba(255, 0, 0, 0.3);
            color: #ff6b6b;
        }
        
        .mention-badge.mod {
            background: rgba(0, 255, 0, 0.2);
            color: #51cf66;
        }
        
        .mention-badge.vip {
            background: rgba(255, 0, 255, 0.2);
            color: #e599f7;
        }
        
        .mention-empty {
            padding: 12px;
            text-align: center;
            color: #888;
            font-size: 12px;
        }
        
        /* : Emote Autocomplete Dropdown */
        .emote-dropdown {
            position: absolute;
            bottom: 100%;
            left: 50px; /* Align with chat input */
            right: 50px;
            background: rgba(18, 18, 18, 0.98);
            border: 1px solid rgba(145, 71, 255, 0.5);
            border-radius: 8px;
            max-height: 200px;
            overflow-y: auto;
            display: none;
            z-index: 200;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
            margin-bottom: 8px;
        }
        
        .emote-dropdown.show {
            display: block;
        }
        
        .emote-dropdown-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 12px;
            cursor: pointer;
            transition: background 0.15s;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }
        
        .emote-dropdown-item:last-child {
            border-bottom: none;
        }
        
        .emote-dropdown-item:hover,
        .emote-dropdown-item.selected {
            background: rgba(145, 71, 255, 0.3);
        }
        
        .emote-dropdown-item.selected {
            border-left: 3px solid rgba(145, 71, 255, 0.8);
        }
        
        .emote-dropdown-preview {
            width: 28px;
            height: 28px;
            object-fit: contain;
        }
        
        .emote-dropdown-name {
            font-size: 13px;
            color: #fff;
            font-family: 'Courier New', monospace;
        }
        
        /* Scrollbar styling for emote dropdown */
        .emote-dropdown::-webkit-scrollbar {
            width: 6px;
        }
        
        .emote-dropdown::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 3px;
        }
        
        .emote-dropdown::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
        }
        
        .emote-dropdown::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        
        .emote-empty {
            padding: 12px;
            text-align: center;
            color: #888;
            font-size: 12px;
        }
        
        /* Connection status indicator */
        .connection-status {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #ff4444;
            animation: pulse 2s infinite;
        }
        
        .status-dot.connected {
            background: #00FF00;
            box-shadow: 0 0 4px #00FF00;
        }
        
        .status-dot.disconnected {
            background: #ff4444;
        }
        
        .status-dot.connecting {
            background: #FFA500;
        }
        
        @keyframes pulse {
            0% {
                transform: scale(1);
                opacity: 1;
            }
            50% {
                transform: scale(1.2);
                opacity: 0.7;
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }
        
        /* Resize handle visual indicator */
        .resize-handle {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 16px;
            height: 16px;
            cursor: se-resize;
            opacity: 0.3;
        }
        
        .resize-handle::before {
            content: '';
            position: absolute;
            bottom: 4px;
            right: 4px;
            width: 8px;
            height: 8px;
            border-right: 2px solid rgba(255, 255, 255, 0.5);
            border-bottom: 2px solid rgba(255, 255, 255, 0.5);
        }
        
        /* ========================================
           NOSTALGIA MODE - ORIGINAL WINDOWS 95 STYLE
           ======================================== */
        
        body.mode-nostalgia {
            background: #ECE9D8 !important;
        }
        
        body.mode-nostalgia .chat-window {
            background: #ECE9D8;
            border: 2px solid;
            border-color: #DFDFDF #808080 #808080 #DFDFDF;
            border-radius: 0;
            box-shadow: none;
        }
        
        body.mode-nostalgia .menu-bar {
            background: linear-gradient(to bottom, #0A246A 0%, #0A246A 8%, #A6CAF0 92%, #A6CAF0 100%);
            color: white;
            padding: 3px 5px;
            font-size: 11px;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
            -webkit-app-region: drag;
            cursor: move;
        }
        
        body.mode-nostalgia .menu-button {
            background: #C0C0C0;
            border: 2px solid;
            border-color: #FFFFFF #808080 #808080 #FFFFFF;
            color: #000;
            font-family: 'W95FA', sans-serif;
            font-size: 11px;
            padding: 4px 8px;
            box-shadow: none;
            border-radius: 0;
            min-height: auto;
        }
        
        body.mode-nostalgia .menu-button:hover {
            background: #E8E8E8;
        }
        
        body.mode-nostalgia .menu-button:active {
            border-color: #808080 #FFFFFF #FFFFFF #808080;
            background: #A0A0A0;
        }
        
        body.mode-nostalgia .menu-button.active {
            background: #A0A0A0;
            border-color: #808080 #FFFFFF #FFFFFF #808080;
        }
        
        body.mode-nostalgia .menu-button-icon {
            padding: 2px 4px;
            min-width: 20px;
        }
        
        body.mode-nostalgia .settings-action-btn {
            background: #ECE9D8;
            border: 2px solid;
            border-color: #FFFFFF #808080 #808080 #FFFFFF;
            color: #000;
            font-family: 'W95FA', sans-serif;
            font-size: 11px;
        }
        
        body.mode-nostalgia .settings-action-btn:hover {
            background: #E8E8E8;
        }
        
        body.mode-nostalgia .settings-action-btn:active {
            border-color: #808080 #FFFFFF #FFFFFF #808080;
            background: #C0C0C0;
        }
        
        body.mode-nostalgia .connection-status {
            background: #0A246A;
            color: white;
            padding: 2px 8px;
            font-size: 11px;
            border: 1px solid;
            border-color: #FFFFFF #808080 #808080 #FFFFFF;
        }
        
        body.mode-nostalgia .chat-container {
            background: #FFFFFF;
            border: 2px solid;
            border-color: #808080 #FFFFFF #FFFFFF #808080;
            margin: 4px;
            margin-top: 0;
            margin-bottom: 4px;
            padding: 8px;
        }
        
        body.mode-nostalgia .chat-message {
            background: transparent;
            color: #000;
            padding: 4px 8px;
            font-size: 11px;
            font-family: 'W95FA', sans-serif;
            border: none;
        }
        
        body.mode-nostalgia .chat-message:hover {
            background: #E8F4FF;
        }
        
        body.mode-nostalgia .chat-username {
            color: #0000CC;
            font-weight: bold;
            text-decoration: none;
        }
        
        body.mode-nostalgia .chat-username:hover {
            text-decoration: underline;
        }
        
        body.mode-nostalgia .chat-text {
            color: #000;
        }
        
        body.mode-nostalgia .chat-message.non-camper .chat-username,
        body.mode-nostalgia .chat-message.non-camper .chat-text {
            color: #888;
        }
        
        body.mode-nostalgia .chat-message.bot-response {
            color: #666;
            font-style: italic;
        }
        
        /* In Default font mode, use system fonts (matches buddy list) */
        body.mode-nostalgia.font-default .chat-message,
        body.mode-nostalgia.font-default .chat-username,
        body.mode-nostalgia.font-default .chat-text,
        body.mode-nostalgia.font-default .chat-input {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 12px;
        }
        
        body.mode-nostalgia .chat-badge {
            height: 14px;
        }
        
        body.mode-nostalgia .chat-emote {
            height: 22px;
        }
        
        body.mode-nostalgia .chat-input-area {
            background: #ECE9D8;
            border: 2px solid;
            border-color: #808080 #FFFFFF #FFFFFF #808080;
            margin: 4px;
            padding: 8px;
            border-radius: 0;
        }
        
        body.mode-nostalgia .chat-input {
            background: #FFFFFF;
            border: 2px solid;
            border-color: #FFFFFF #808080 #808080 #FFFFFF;
            color: #000;
            font-family: 'W95FA', sans-serif;
            font-size: 12px;
            padding: 4px 8px;
            border-radius: 0;
        }
        
        body.mode-nostalgia .chat-input:focus {
            border-color: #000080;
        }
        
        body.mode-nostalgia .chat-input::placeholder {
            color: #888;
        }
        
        body.mode-nostalgia .send-button {
            background: #C0C0C0;
            border: 2px solid;
            border-color: #FFFFFF #808080 #808080 #FFFFFF;
            color: #000;
            font-family: 'W95FA', sans-serif;
            font-size: 11px;
            padding: 4px 12px;
            border-radius: 0;
        }
        
        body.mode-nostalgia .send-button:hover {
            background: #E8E8E8;
        }
        
        body.mode-nostalgia .send-button:active {
            border-color: #808080 #FFFFFF #FFFFFF #808080;
        }
        
        body.mode-nostalgia .settings-dropdown {
            background: #ECE9D8;
            border: 2px solid;
            border-color: #FFFFFF #808080 #808080 #FFFFFF;
            font-family: 'W95FA', sans-serif;
        }
        
        body.mode-nostalgia .settings-row {
            border-bottom: 1px solid #808080;
        }
        
        body.mode-nostalgia .settings-label {
            color: #000;
            font-family: 'W95FA', sans-serif;
        }
        
        body.mode-nostalgia .settings-select {
            background: #ECE9D8;
            border: 2px solid;
            border-color: #FFFFFF #808080 #808080 #FFFFFF;
            color: #000;
            font-family: 'W95FA', sans-serif;
            font-size: 11px;
        }
        
        body.mode-nostalgia .settings-select:focus {
            outline: none;
            border-color: #000080;
        }
        
        body.mode-nostalgia .picker-dropdown {
            background: #ECE9D8;
            border: 2px solid;
            border-color: #FFFFFF #808080 #808080 #FFFFFF;
            font-family: 'W95FA', sans-serif;
        }
        
        body.mode-nostalgia .picker-tab {
            background: #C0C0C0;
            border: 2px solid;
            border-color: #FFFFFF #808080 #808080 #FFFFFF;
            color: #000;
            font-family: 'W95FA', sans-serif;
            font-size: 11px;
        }
        
        body.mode-nostalgia .picker-tab.active {
            background: #E8E8E8;
            border-bottom-color: #808080;
        }
        
        body.mode-nostalgia .picker-item {
            font-family: 'W95FA', sans-serif;
        }
        
        body.mode-nostalgia .mention-dropdown {
            background: #ECE9D8;
            border: 2px solid;
            border-color: #FFFFFF #808080 #808080 #FFFFFF;
            font-family: 'W95FA', sans-serif;
        }
        
        body.mode-nostalgia .mention-item {
            font-size: 11px;
            font-family: 'W95FA', sans-serif;
        }
        
        body.mode-nostalgia .mention-item.selected {
            background: #0A246A;
            color: white;
        }
        
        body.mode-nostalgia .chat-container::-webkit-scrollbar-track {
            background: #D4D0C8;
            border-left: 1px solid #808080;
        }
        
        body.mode-nostalgia .chat-container::-webkit-scrollbar-thumb {
            background: #C0C0C0;
            border: 1px solid;
            border-color: #FFFFFF #808080 #808080 #FFFFFF;
        }
        
        body.mode-nostalgia .picker-content::-webkit-scrollbar-track,
        body.mode-nostalgia .mention-dropdown::-webkit-scrollbar-track,
        body.mode-nostalgia .emote-dropdown::-webkit-scrollbar-track {
            background: #D4D0C8;
        }
        
        body.mode-nostalgia .picker-content::-webkit-scrollbar-thumb,
        body.mode-nostalgia .mention-dropdown::-webkit-scrollbar-thumb,
        body.mode-nostalgia .emote-dropdown::-webkit-scrollbar-thumb {
            background: #C0C0C0;
            border: 1px solid;
            border-color: #FFFFFF #808080 #808080 #FFFFFF;
        }
        
        body.mode-nostalgia .empty-state {
            color: #666;
            font-family: 'W95FA', sans-serif;
        }
        
        /* ========================================
           SNAP STATE VISUAL FEEDBACK
           ======================================== */
        
        /* When snapped to buddy list, add a subtle glow effect */
        body.snapped-to-buddy .chat-window {
            border-color: rgba(145, 71, 255, 0.5);
            box-shadow: 0 8px 32px rgba(145, 71, 255, 0.3), 0 0 20px rgba(145, 71, 255, 0.1);
        }
        
        body.snapped-to-buddy .menu-bar {
            background: rgba(145, 71, 255, 0.15);
            border-bottom-color: rgba(145, 71, 255, 0.3);
        }
        
        /* Nostalgia mode snap feedback */
        body.mode-nostalgia.snapped-to-buddy .chat-window {
            border-color: #9147ff;
            border-left-width: 3px;
        }
        
        body.mode-nostalgia.snapped-to-buddy .menu-bar {
            background: linear-gradient(to bottom, #4b2d99 0%, #4b2d99 8%, #A6CAF0 92%, #A6CAF0 100%);
        }
    </style>
</head>
<body class="font-default">
    <div class="chat-window">
        <!-- Snap guide overlays (purple glow when close to snapping) -->
        <div class="snap-guide-overlay snap-left"></div>
        <div class="snap-guide-overlay snap-right"></div>
        <!-- Top menu bar -->
        <div class="menu-bar">
            <!-- Settings button (gear icon, far left) -->
            <button class="menu-button menu-button-icon" id="btnSettings" onclick="toggleSettings()" title="Settings">‚öôÔ∏è</button>
            <!-- Front button (pin icon, beside settings) -->
            <button class="menu-button menu-button-icon" id="btnBringToFront" onclick="bringToFront()" title="Bring to Front">üìå</button>
            <!-- Title -->
            <span class="chat-title">Chat</span>
            <!-- Connection status (centered) -->
            <div class="connection-status">
                <span class="status-dot" id="statusDot"></span>
                <span id="statusText">Disconnected</span>
            </div>
            <button class="close-button" onclick="closeWindow()">‚úï Close</button>
            
            <!-- Settings dropdown -->
            <div class="settings-dropdown" id="settingsDropdown">
                <div class="settings-row">
                    <button class="settings-action-btn" onclick="clearChat()">üóëÔ∏è Clear Chat</button>
                </div>
                <div class="settings-row">
                    <label for="styleMode">Style Mode:</label>
                    <select id="styleMode" onchange="changeStyleMode(this.value)">
                        <option value="modern">Modern</option>
                        <option value="nostalgia">Nostalgia</option>
                    </select>
                </div>
                <div class="settings-row">
                    <label for="fontSelect">Font:</label>
                    <select id="fontSelect" onchange="changeFont(this.value)">
                        <option value="default">Default</option>
                        <option value="tahoma">Tahoma</option>
                        <option value="w95fa">W95FA (Retro)</option>
                    </select>
                </div>
                <div class="settings-row">
                    <label for="fontSizeSelect">Font Size:</label>
                    <select id="fontSizeSelect" onchange="changeFontSize(this.value)">
                        <option value="small">Small (12px)</option>
                        <option value="medium" selected>Medium (14px)</option>
                        <option value="large">Large (16px)</option>
                    </select>
                </div>
                <div class="settings-row">
                    <label for="greyNonCampers" title="Grey out messages from users who haven't joined the campfire">Grey Non-Campers:</label>
                    <input type="checkbox" id="greyNonCampers" onchange="toggleGreyNonCampers(this.checked)" style="width: 18px; height: 18px; cursor: pointer;">
                </div>
            </div>
        </div>
        
        <!-- Chat messages -->
        <div class="chat-container" id="chatContainer">
            <div class="empty-state" id="emptyState">
                üí¨ Waiting for chat messages...<br>
                <small>Connect to Twitch in the dashboard to see chat.</small>
            </div>
        </div>
        
        <!-- Chat input -->
        <div class="chat-input-area">
            <select class="speaker-select" id="speakerSelect" title="Send as...">
                <option value="main">Main Account</option>
                <option value="bot">Bot Account</option>
            </select>
            <input type="text" class="chat-input" id="chatInput" placeholder="Send a message..." maxlength="500">
            <button class="emote-button" id="btnEmoji" onclick="togglePicker('emoji')" title="Emoji Picker">üòÄ</button>
            <button class="emote-button" id="btnEmote" onclick="togglePicker('emote')" title="Twitch Emotes">üì∫</button>
            <button class="send-button" id="btnSend" onclick="sendMessage()">Send</button>
            
            <!-- Emoji/Emote Picker Panel -->
            <div class="picker-panel" id="pickerPanel">
                <div class="picker-tabs">
                    <button class="picker-tab active" id="tabEmoji" onclick="switchPickerTab('emoji')">üòÄ Emoji</button>
                    <button class="picker-tab" id="tabGlobal" onclick="switchPickerTab('global')">üåê Global</button>
                    <button class="picker-tab" id="tabChannel" onclick="switchPickerTab('channel')">üì∫ Channel</button>
                    <button class="picker-tab" id="tabUser" onclick="switchPickerTab('user')">üë§ My Emotes</button>
                </div>
                <div class="picker-search">
                    <input type="text" id="emoteSearch" placeholder="Search emotes..." oninput="filterEmotes(this.value)">
                </div>
                <div class="picker-content" id="pickerContent">
                    <!-- Content loaded dynamically -->
                </div>
            </div>
            
            <!-- @ Mention Autocomplete Dropdown -->
            <div class="mention-dropdown" id="mentionDropdown">
                <!-- Populated dynamically -->
            </div>
            
            <!-- : Emote Autocomplete Dropdown -->
            <div class="emote-dropdown" id="emoteDropdown">
                <!-- Populated dynamically -->
            </div>
        </div>
    </div>
    
    <script>
        // ========================================
        // MODE DETECTION
        // ========================================
        
        // Detect if running in standalone mode (no Electron API)
        // or in Creator mode (with Electron IPC)
        const IS_STANDALONE = !window.electronAPI;
        const IS_CREATOR_MODE = !IS_STANDALONE;
        
        console.log('[ChatPopout] Mode detection:', { 
            isStandalone: IS_STANDALONE, 
            isCreatorMode: IS_CREATOR_MODE 
        });
        
        // ========================================
        // WINDOW SNAP STATE HANDLING
        // ========================================
        
        // Listen for snap state changes from main process
        function initSnapStateListener() {
            if (IS_STANDALONE) {
                // In standalone mode, no snap functionality
                console.log('[ChatPopout] Standalone mode - snap functionality disabled');
                return;
            }
            
            // Listen for snap status updates
            if (window.electronAPI && window.electronAPI.onWindowSnapChanged) {
                window.electronAPI.onWindowSnapChanged((data) => {
                    console.log('[ChatPopout] Snap state changed:', data);
                    
                    if (data.bothSnapped) {
                        // Apply visual feedback for snapped state
                        document.body.classList.add('snapped-to-buddy');
                    } else {
                        // Remove visual feedback
                        document.body.classList.remove('snapped-to-buddy');
                    }
                });
                console.log('[ChatPopout] Snap state listener initialized');
            }
            
            // Listen for snap guide visibility updates (purple glow when close to snapping)
            if (window.electronAPI && window.electronAPI.onSnapGuideChanged) {
                window.electronAPI.onSnapGuideChanged((data) => {
                    updateSnapGuide(data.snapGuideVisible, data.snapPosition);
                });
                console.log('[ChatPopout] Snap guide listener initialized');
            }
        }
        
        /**
         * Update visual snap guide (purple glow when close to snapping)
         * Shows overlay ONLY on the edge that will snap, not all sides
         * @param {boolean} visible - Whether snap guide should be visible
         * @param {string|null} snapPosition - 'buddy-left' or 'buddy-right'
         */
        function updateSnapGuide(visible, snapPosition) {
            const chatWindow = document.querySelector('.chat-window');
            if (!chatWindow) return;
            
            // Remove all indicator classes first
            chatWindow.classList.remove('snap-left-indicator', 'snap-right-indicator');
            
            // Get both overlays
            const leftOverlay = chatWindow.querySelector('.snap-left');
            const rightOverlay = chatWindow.querySelector('.snap-right');
            
            // Hide all overlays first
            if (leftOverlay) leftOverlay.style.display = 'none';
            if (rightOverlay) rightOverlay.style.display = 'none';
            
            if (visible && snapPosition) {
                chatWindow.classList.add('snap-guide-active');
                
                if (snapPosition === 'buddy-left') {
                    // Buddy on LEFT, Chat on RIGHT
                    // Show Chat's LEFT edge (where Buddy will snap to)
                    chatWindow.classList.add('snap-left-indicator');
                    if (leftOverlay) leftOverlay.style.display = 'block';
                } else if (snapPosition === 'buddy-right') {
                    // Buddy on RIGHT, Chat on LEFT
                    // Show Chat's RIGHT edge (where Buddy will snap to)
                    chatWindow.classList.add('snap-right-indicator');
                    if (rightOverlay) rightOverlay.style.display = 'block';
                }
            } else {
                chatWindow.classList.remove('snap-guide-active');
            }
        }
        
        // Initialize snap listener after a short delay to ensure electronAPI is ready
        setTimeout(initSnapStateListener, 100);
        
        // ========================================
        // UNIFIED API (works in both modes)
        // ========================================
        
        const ChatAPI = {
            // Send a chat message
            async sendMessage(message, speaker = 'main') {
                if (IS_STANDALONE) {
                    // Standalone: use direct IRC (tmi.js should be loaded)
                    if (window.ircClient && window.ircClient.connected) {
                        return await window.ircClient.say(`#${window.currentChannel}`, message);
                    }
                    return { ok: false, error: 'Not connected to IRC' };
                } else {
                    // Creator mode: use IPC
                    return await window.electronAPI.sendChatMessage(message, speaker);
                }
            },
            
            // Get connection status
            async getStatus() {
                if (IS_STANDALONE) {
                    return {
                        connected: window.ircClient?.connected || false,
                        channel: window.currentChannel || null
                    };
                } else {
                    return await window.electronAPI.getTwitchStatus();
                }
            },
            
            // Listen for chat messages
            onMessage(callback) {
                if (IS_STANDALONE) {
                    // Standalone: listen to IRC events
                    if (window.ircClient) {
                        window.ircClient.on('message', (channel, tags, message, self) => {
                            if (self) return;
                            callback({ channel, tags, message });
                        });
                    }
                } else {
                    // Creator mode: listen to IPC events
                    window.electronAPI.onChatMessage(callback);
                }
            },
            
            // Get chat history
            async getHistory() {
                if (IS_STANDALONE) {
                    // Standalone: get from localStorage
                    const history = localStorage.getItem('campfireChatHistory');
                    return history ? JSON.parse(history) : [];
                } else {
                    // Creator mode: get from IPC
                    return await window.electronAPI.getChatHistory();
                }
            },
            
            // Save chat history
            async saveHistory(messages) {
                if (IS_STANDALONE) {
                    // Standalone: save to localStorage
                    localStorage.setItem('campfireChatHistory', JSON.stringify(messages.slice(-200)));
                } else {
                    // Creator mode: handled by main process
                }
            }
        };
        
        // ========================================
        // CHAT STATE
        // ========================================
        
        // Chat message storage
        let messages = [];
        const maxMessages = 500;
        let autoScroll = true;
        let isConnected = false;
        let greyNonCampers = false;
        
        // Command categories that should use italic formatting (narrative style)
        const ITALIC_COMMAND_CATEGORIES = ['STATE', 'ANIMATION', 'MOVEMENT', 'APPEARANCE'];
        
        // Toggle grey non-campers setting
        function toggleGreyNonCampers(enabled) {
            greyNonCampers = enabled;
            localStorage.setItem('chatPopoutGreyNonCampers', enabled ? 'true' : 'false');
            // Update existing messages
            updateNonCamperStyles();
        }
        
        // Update styles for existing non-camper messages
        function updateNonCamperStyles() {
            const container = document.getElementById('chatContainer');
            const messages = container.querySelectorAll('.chat-message[data-is-camper="false"]');
            messages.forEach(msg => {
                if (greyNonCampers) {
                    msg.classList.add('non-camper');
                } else {
                    msg.classList.remove('non-camper');
                }
            });
        }
        
        // Load saved grey non-campers preference
        const savedGreyNonCampers = localStorage.getItem('chatPopoutGreyNonCampers') === 'true';
        greyNonCampers = savedGreyNonCampers;
        document.addEventListener('DOMContentLoaded', () => {
            const checkbox = document.getElementById('greyNonCampers');
            if (checkbox) checkbox.checked = savedGreyNonCampers;
        });
        
        // Toggle settings dropdown
        function toggleSettings() {
            const dropdown = document.getElementById('settingsDropdown');
            dropdown.classList.toggle('show');
        }
        
        // Close dropdown when clicking outside
        document.addEventListener('click', (e) => {
            const dropdown = document.getElementById('settingsDropdown');
            const btnSettings = document.getElementById('btnSettings');
            if (!dropdown.contains(e.target) && e.target !== btnSettings) {
                dropdown.classList.remove('show');
            }
        });
        
        // Change font
        function changeFont(font) {
            document.body.classList.remove('font-tahoma', 'font-w95fa');
            document.body.classList.add(`font-${font}`);
            localStorage.setItem('chatPopoutFont', font);
        }
        
        // Change font size
        function changeFontSize(size) {
            document.body.classList.remove('font-size-small', 'font-size-medium', 'font-size-large');
            document.body.classList.add(`font-size-${size}`);
            localStorage.setItem('chatPopoutFontSize', size);
        }
        
        // Change style mode (Modern vs Nostalgia)
        function changeStyleMode(mode) {
            document.body.classList.remove('mode-modern', 'mode-nostalgia');
            document.body.classList.add(`mode-${mode}`);
            localStorage.setItem('chatPopoutStyleMode', mode);
            
            // Notify other windows via localStorage event
            localStorage.setItem('styleModeSync', `${Date.now()}`);
        }
        
        // Listen for style mode changes from other windows
        window.addEventListener('storage', (e) => {
            if (e.key === 'styleModeSync') {
                const savedMode = localStorage.getItem('chatPopoutStyleMode') || 'modern';
                document.body.classList.remove('mode-modern', 'mode-nostalgia');
                document.body.classList.add(`mode-${savedMode}`);
                document.getElementById('styleMode').value = savedMode;
            }
        });
        
        // Initialize style mode
        const savedStyleMode = localStorage.getItem('chatPopoutStyleMode') || 'modern';
        document.body.classList.add(`mode-${savedStyleMode}`);
        document.getElementById('styleMode').value = savedStyleMode;
        
        // Load saved font preference
        const savedFont = localStorage.getItem('chatPopoutFont') || 'default';
        document.getElementById('fontSelect').value = savedFont;
        changeFont(savedFont);
        
        // Load saved font size preference
        const savedFontSize = localStorage.getItem('chatPopoutFontSize') || 'medium';
        document.getElementById('fontSizeSelect').value = savedFontSize;
        changeFontSize(savedFontSize);
        
        // Clear chat
        function clearChat() {
            messages = [];
            const container = document.getElementById('chatContainer');
            container.innerHTML = '<div class="empty-state" id="emptyState">üí¨ Chat cleared.</div>';
        }
        
        // Close window
        function closeWindow() {
            window.close();
        }
        
        // Bring widget window to front (so it appears above other applications)
        function bringToFront() {
            if (window.electronAPI && window.electronAPI.bringWidgetToFront) {
                window.electronAPI.bringWidgetToFront();
            }
        }
        
        // Update connection status
        function updateConnectionStatus(connected) {
            isConnected = connected;
            const dot = document.getElementById('statusDot');
            const text = document.getElementById('statusText');
            const sendBtn = document.getElementById('btnSend');
            const input = document.getElementById('chatInput');
            
            if (connected) {
                dot.classList.add('connected');
                text.textContent = 'Connected';
                sendBtn.disabled = false;
                input.placeholder = 'Send a message...';
            } else {
                dot.classList.remove('connected');
                text.textContent = 'Disconnected';
                sendBtn.disabled = true;
                input.placeholder = 'Connect to Twitch to chat...';
            }
        }
        
        // ============================================
        // EMOJI & EMOTE PICKER
        // ============================================
        
        // Common emoji categories
        const EMOJI_DATA = {
            'Smileys': ['üòÄ', 'üòÉ', 'üòÑ', 'üòÅ', 'üòÜ', 'üòÖ', 'ü§£', 'üòÇ', 'üôÇ', 'üôÉ', 'üòâ', 'üòä', 'üòá', 'ü•∞', 'üòç', 'ü§©', 'üòò', 'üòó', 'üòö', 'üòô', 'ü•≤', 'üòã', 'üòõ', 'üòú', 'ü§™', 'üòù', 'ü§ë', 'ü§ó', 'ü§≠', 'ü§´', 'ü§î', 'ü§ê', 'ü§®', 'üòê', 'üòë', 'üò∂', 'üòè', 'üòí', 'üôÑ', 'üò¨', 'ü§•', 'üòå', 'üòî', 'üò™', 'ü§§', 'üò¥', 'üò∑', 'ü§í', 'ü§ï', 'ü§¢', 'ü§Æ', 'ü§ß', 'ü•µ', 'ü•∂', 'ü•¥', 'üòµ', 'ü§Ø', 'ü§†', 'ü•≥', 'ü•∏', 'üòé', 'ü§ì', 'üßê'],
            'Gestures': ['üëã', 'ü§ö', 'üñêÔ∏è', '‚úã', 'üññ', 'üëå', 'ü§å', 'ü§è', '‚úåÔ∏è', 'ü§û', 'ü§ü', 'ü§ò', 'ü§ô', 'üëà', 'üëâ', 'üëÜ', 'üñï', 'üëá', '‚òùÔ∏è', 'üëç', 'üëé', '‚úä', 'üëä', 'ü§õ', 'ü§ú', 'üëè', 'üôå', 'üëê', 'ü§≤', 'ü§ù', 'üôè', '‚úçÔ∏è', 'üí™', 'ü¶æ', 'ü¶ø'],
            'Hearts': ['‚ù§Ô∏è', 'üß°', 'üíõ', 'üíö', 'üíô', 'üíú', 'üñ§', 'ü§ç', 'ü§é', 'üíî', '‚ù£Ô∏è', 'üíï', 'üíû', 'üíì', 'üíó', 'üíñ', 'üíò', 'üíù', 'üíü', '‚ô•Ô∏è'],
            'Symbols': ['‚≠ê', 'üåü', '‚ú®', 'üí´', 'üî•', 'üí•', 'üí¢', 'üí¶', 'üí®', 'üï≥Ô∏è', 'üí£', 'üí¨', 'üëÅÔ∏è‚Äçüó®Ô∏è', 'üó®Ô∏è', 'üóØÔ∏è', 'üí≠', 'üí§', 'üéµ', 'üé∂', 'üîî', 'üîï', 'üì¢', 'üì£', 'üí°', 'üîå', 'üîã', 'ü™´', 'üîç', 'üîé', 'üîí', 'üîì', 'üîë', 'üóùÔ∏è', 'üî®', 'ü™ì', '‚õèÔ∏è', '‚öíÔ∏è', 'üõ†Ô∏è', 'üó°Ô∏è', '‚öîÔ∏è', 'üî´', 'ü™É', 'üèπ', 'üõ°Ô∏è', 'ü™ö', 'üîß', 'ü™õ', 'üî©', '‚öôÔ∏è', 'üóúÔ∏è', '‚öñÔ∏è', 'ü¶Ø', 'üîó', '‚õìÔ∏è', 'ü™ù', 'üß∞', 'üß≤'],
            'Animals': ['üê∂', 'üê±', 'üê≠', 'üêπ', 'üê∞', 'ü¶ä', 'üêª', 'üêº', 'üêª‚Äç‚ùÑÔ∏è', 'üê®', 'üêØ', 'ü¶Å', 'üêÆ', 'üê∑', 'üê∏', 'üêµ', 'üôà', 'üôâ', 'üôä', 'üêí', 'üêî', 'üêß', 'üê¶', 'üê§', 'üê£', 'üê•', 'ü¶Ü', 'ü¶Ö', 'ü¶â', 'ü¶á', 'üê∫', 'üêó', 'üê¥', 'ü¶Ñ', 'üêù', 'ü™±', 'üêõ', 'ü¶ã', 'üêå', 'üêû', 'üêú', 'ü™∞', 'ü™≤', 'ü™≥', 'ü¶ü', 'ü¶ó', 'üï∑Ô∏è', 'üï∏Ô∏è', 'ü¶Ç', 'üê¢', 'üêç', 'ü¶é', 'ü¶ñ', 'ü¶ï', 'üêô', 'ü¶ë', 'ü¶ê', 'ü¶û', 'ü¶Ä', 'üê°', 'üê†', 'üêü', 'üê¨', 'üê≥', 'üêã', 'ü¶à', 'üêä', 'üêÖ', 'üêÜ', 'ü¶ì', 'ü¶ç', 'ü¶ß', 'ü¶£', 'üêò', 'ü¶õ', 'ü¶è', 'üê™', 'üê´', 'ü¶í', 'ü¶ò', 'ü¶¨', 'üêÉ', 'üêÇ', 'üêÑ', 'üêé', 'üêñ', 'üêè', 'üêë', 'ü¶ô', 'üêê', 'ü¶å', 'üêï', 'üê©', 'ü¶Æ', 'üêï‚Äçü¶∫', 'üêà', 'üêà‚Äç‚¨õ', 'ü™∂', 'üêì', 'ü¶É', 'ü¶§', 'ü¶ö', 'ü¶ú', 'ü¶¢', 'ü¶©', 'üïäÔ∏è', 'üêá', 'ü¶ù', 'ü¶®', 'ü¶°', 'ü¶´', 'ü¶¶', 'ü¶•', 'üêÅ', 'üêÄ', 'üêøÔ∏è', 'ü¶î'],
            'Food': ['üçé', 'üçê', 'üçä', 'üçã', 'üçå', 'üçâ', 'üçá', 'üçì', 'ü´ê', 'üçà', 'üçí', 'üçë', 'ü•≠', 'üçç', 'ü••', 'ü•ù', 'üçÖ', 'üçÜ', 'ü•ë', 'ü•¶', 'ü•¨', 'ü•í', 'üå∂Ô∏è', 'ü´ë', 'üåΩ', 'ü•ï', 'ü´í', 'üßÑ', 'üßÖ', 'ü•î', 'üç†', 'ü•ê', 'ü•Ø', 'üçû', 'ü•ñ', 'ü•®', 'üßÄ', 'ü•ö', 'üç≥', 'üßà', 'ü•û', 'üßá', 'ü•ì', 'ü•©', 'üçó', 'üçñ', 'ü¶¥', 'üå≠', 'üçî', 'üçü', 'üçï', 'ü´ì', 'ü•™', 'ü•ô', 'üßÜ', 'üåÆ', 'üåØ', 'ü´î', 'ü•ó', 'ü•ò', 'ü´ï', 'üçù', 'üçú', 'üç≤', 'üçõ', 'üç£', 'üç±', 'ü•ü', 'ü¶™', 'üç§', 'üçô', 'üçö', 'üçò', 'üç•', 'ü•†', 'ü•Æ', 'üç¢', 'üç°', 'üçß', 'üç®', 'üç¶', 'ü•ß', 'üßÅ', 'üç∞', 'üéÇ', 'üçÆ', 'üç≠', 'üç¨', 'üç´', 'üçø', 'üç©', 'üç™', 'üå∞', 'ü•ú', 'üçØ', 'ü•õ', 'üçº', 'ü´ñ', '‚òï', 'üçµ', 'üßÉ', 'ü•§', 'üßã', 'üç∂', 'üç∫', 'üçª', 'ü•Ç', 'üç∑', 'ü•É', 'üç∏', 'üçπ', 'üßâ', 'üçæ', 'üßä', 'ü•Ñ', 'üç¥', 'üçΩÔ∏è', 'ü•£', 'ü•°', 'ü•¢', 'üßÇ'],
            'Activities': ['‚öΩ', 'üèÄ', 'üèà', '‚öæ', 'ü•é', 'üéæ', 'üèê', 'üèâ', 'ü•è', 'üé±', 'ü™Ä', 'üèì', 'üè∏', 'üèí', 'üèë', 'ü•ç', 'üèè', 'ü™É', 'ü•Ö', '‚õ≥', 'ü™Å', 'üèπ', 'üé£', 'ü§ø', 'ü•ä', 'ü•ã', 'üéΩ', 'üõπ', 'üõº', 'üõ∑', '‚õ∏Ô∏è', 'ü•å', 'üéø', '‚õ∑Ô∏è', 'üèÇ', 'ü™Ç', 'üèãÔ∏è', 'ü§º', 'ü§∏', 'ü§∫', '‚õπÔ∏è', 'ü§æ', 'üèåÔ∏è', 'üèá', 'üßò', 'üèÑ', 'üèä', 'ü§Ω', 'üö£', 'üßó', 'üöµ', 'üö¥', 'üèÜ', 'ü•á', 'ü•à', 'ü•â', 'üèÖ', 'üéñÔ∏è', 'üèµÔ∏è', 'üéóÔ∏è', 'üé´', 'üéüÔ∏è', 'üé™', 'ü§π', 'üé≠', 'ü©∞', 'üé®', 'üé¨', 'üé§', 'üéß', 'üéº', 'üéπ', 'ü•Å', 'ü™ò', 'üé∑', 'üé∫', 'ü™ó', 'üé∏', 'ü™ï', 'üéª', 'üé≤', '‚ôüÔ∏è', 'üéØ', 'üé≥', 'üéÆ', 'üé∞', 'üß©'],
            'Travel': ['üöó', 'üöï', 'üöô', 'üöå', 'üöé', 'üèéÔ∏è', 'üöì', 'üöë', 'üöí', 'üöê', 'üõª', 'üöö', 'üöõ', 'üöú', 'ü¶Ø', 'ü¶Ω', 'ü¶º', 'üõ¥', 'üö≤', 'üõµ', 'üèçÔ∏è', 'üõ∫', 'üö®', 'üöî', 'üöç', 'üöò', 'üöñ', 'üö°', 'üö†', 'üöü', 'üöÉ', 'üöã', 'üöû', 'üöù', 'üöÑ', 'üöÖ', 'üöà', 'üöÇ', 'üöÜ', 'üöá', 'üöä', 'üöâ', '‚úàÔ∏è', 'üõ´', 'üõ¨', 'üõ©Ô∏è', 'üí∫', 'üõ∞Ô∏è', 'üöÄ', 'üõ∏', 'üöÅ', 'üõ∂', '‚õµ', 'üö§', 'üõ•Ô∏è', 'üõ≥Ô∏è', '‚õ¥Ô∏è', 'üö¢', '‚öì', 'ü™ù', '‚õΩ', 'üöß', 'üö¶', 'üö•', 'üöè', 'üó∫Ô∏è', 'üóø', 'üóΩ', 'üóº', 'üè∞', 'üèØ', 'üèüÔ∏è', 'üé°', 'üé¢', 'üé†', '‚õ≤', '‚õ±Ô∏è', 'üèñÔ∏è', 'üèùÔ∏è', 'üèúÔ∏è', 'üåã', '‚õ∞Ô∏è', 'üèîÔ∏è', 'üóª', 'üèïÔ∏è', '‚õ∫', 'üõñ', 'üè†', 'üè°', 'üèòÔ∏è', 'üèöÔ∏è', 'üèóÔ∏è', 'üè≠', 'üè¢', 'üè¨', 'üè£', 'üè§', 'üè•', 'üè¶', 'üè®', 'üè™', 'üè´', 'üè©', 'üíí', 'üèõÔ∏è', '‚õ™', 'üïå', 'üïç', 'üõï', 'üïã', '‚õ©Ô∏è', 'üõ§Ô∏è', 'üõ£Ô∏è', 'üóæ', 'üéë', 'üèûÔ∏è', 'üåÖ', 'üåÑ', 'üå†', 'üéá', 'üéÜ', 'üåá', 'üåÜ', 'üèôÔ∏è', 'üåÉ', 'üåå', 'üåâ', 'üåÅ']
        };
        
        // Emote cache
        let emoteCache = {
            global: null,
            channel: null,
            user: null
        };
        
        // Current picker state
        let currentPickerTab = 'emoji';
        let pickerVisible = false;
        
        // Toggle picker panel
        function togglePicker(type) {
            const panel = document.getElementById('pickerPanel');
            const btnEmoji = document.getElementById('btnEmoji');
            const btnEmote = document.getElementById('btnEmote');
            
            // If clicking the same button while open, close it
            if (pickerVisible && ((type === 'emoji' && currentPickerTab === 'emoji') ||
                                  (type === 'emote' && currentPickerTab !== 'emoji'))) {
                panel.classList.remove('show');
                btnEmoji.classList.remove('active');
                btnEmote.classList.remove('active');
                pickerVisible = false;
                return;
            }
            
            // Open panel and switch to appropriate tab
            panel.classList.add('show');
            pickerVisible = true;
            
            if (type === 'emoji') {
                switchPickerTab('emoji');
                btnEmoji.classList.add('active');
                btnEmote.classList.remove('active');
            } else {
                switchPickerTab('global');
                btnEmoji.classList.remove('active');
                btnEmote.classList.add('active');
            }
        }
        
        // Switch picker tab
        function switchPickerTab(tab) {
            currentPickerTab = tab;
            
            // Update tab buttons
            document.querySelectorAll('.picker-tab').forEach(t => t.classList.remove('active'));
            const tabBtn = document.getElementById('tab' + tab.charAt(0).toUpperCase() + tab.slice(1));
            if (tabBtn) tabBtn.classList.add('active');
            
            // Update button highlights
            const btnEmoji = document.getElementById('btnEmoji');
            const btnEmote = document.getElementById('btnEmote');
            if (tab === 'emoji') {
                btnEmoji.classList.add('active');
                btnEmote.classList.remove('active');
            } else {
                btnEmoji.classList.remove('active');
                btnEmote.classList.add('active');
            }
            
            // Load content
            const content = document.getElementById('pickerContent');
            
            if (tab === 'emoji') {
                renderEmojiPicker(content);
            } else {
                loadEmotes(tab, content);
            }
        }
        
        // Render emoji picker
        function renderEmojiPicker(container) {
            let html = '';
            for (const [category, emojis] of Object.entries(EMOJI_DATA)) {
                html += `<div class="picker-category">${category}</div>`;
                html += '<div class="picker-grid">';
                for (const emoji of emojis) {
                    html += `<div class="picker-item" onclick="insertEmoji('${emoji}')" title="${emoji}">${emoji}</div>`;
                }
                html += '</div>';
            }
            container.innerHTML = html;
        }
        
        // Load Twitch emotes
        async function loadEmotes(type, container) {
            // Check cache first
            if (emoteCache[type]) {
                renderEmotes(emoteCache[type], container, type);
                return;
            }
            
            container.innerHTML = '<div class="picker-loading">Loading emotes...</div>';
            
            try {
                if (window.electronAPI && window.electronAPI.getTwitchEmotes) {
                    const emotes = await window.electronAPI.getTwitchEmotes(type);
                    if (emotes && emotes.length > 0) {
                        emoteCache[type] = emotes;
                        renderEmotes(emotes, container, type);
                    } else {
                        container.innerHTML = `<div class="picker-empty">No ${type} emotes available</div>`;
                    }
                } else {
                    container.innerHTML = '<div class="picker-empty">Emote API not available</div>';
                }
            } catch (error) {
                console.error('Error loading emotes:', error);
                container.innerHTML = `<div class="picker-empty">Failed to load emotes</div>`;
            }
        }
        
        // Render emotes grid
        function renderEmotes(emotes, container, type) {
            if (!emotes || emotes.length === 0) {
                container.innerHTML = `<div class="picker-empty">No ${type} emotes available</div>`;
                return;
            }
            
            let html = '<div class="picker-grid">';
            for (const emote of emotes) {
                const url = emote.url || `https://static-cdn.jtvnw.net/emoticons/v2/${emote.id}/default/dark/2.0`;
                const name = emote.name || emote.code || 'emote';
                html += `<div class="picker-item" onclick="insertEmote('${escapeHtml(name)}')" title="${escapeHtml(name)}">`;
                html += `<img src="${url}" alt="${escapeHtml(name)}" loading="lazy">`;
                html += '</div>';
            }
            html += '</div>';
            container.innerHTML = html;
        }
        
        // Emote search state
        let emoteSearchQuery = '';
        
        // Filter emotes by search query
        function filterEmotes(query) {
            emoteSearchQuery = query.toLowerCase().trim();
            
            const container = document.getElementById('pickerContent');
            
            if (emoteSearchQuery === '') {
                // If no search, show current tab's emotes
                loadEmotes(currentPickerTab, container);
                return;
            }
            
            // Get all emotes from current tab's cache
            const allEmotes = emoteCache[currentPickerTab] || [];
            
            // Filter emotes by search query
            const filteredEmotes = allEmotes.filter(emote => {
                const name = emote.name || emote.code || '';
                return name.toLowerCase().includes(emoteSearchQuery);
            });
            
            if (filteredEmotes.length === 0) {
                container.innerHTML = `<div class="picker-empty">No emotes found for "${escapeHtml(query)}"</div>`;
            } else {
                renderEmotes(filteredEmotes, container, currentPickerTab);
            }
        }
        
        // Insert emoji at cursor position
        function insertEmoji(emoji) {
            const input = document.getElementById('chatInput');
            const start = input.selectionStart;
            const end = input.selectionEnd;
            const text = input.value;
            
            input.value = text.substring(0, start) + emoji + text.substring(end);
            input.focus();
            input.setSelectionRange(start + emoji.length, start + emoji.length);
        }
        
        // Insert emote text at cursor position
        function insertEmote(emoteName) {
            const input = document.getElementById('chatInput');
            const start = input.selectionStart;
            const end = input.selectionEnd;
            const text = input.value;
            
            // Add space before if needed
            const prefix = (start > 0 && text[start - 1] !== ' ') ? ' ' : '';
            // Add space after
            const suffix = ' ';
            const insertText = prefix + emoteName + suffix;
            
            input.value = text.substring(0, start) + insertText + text.substring(end);
            input.focus();
            input.setSelectionRange(start + insertText.length, start + insertText.length);
        }
        
        // Close picker when clicking outside
        document.addEventListener('click', (e) => {
            const panel = document.getElementById('pickerPanel');
            const btnEmoji = document.getElementById('btnEmoji');
            const btnEmote = document.getElementById('btnEmote');
            
            if (pickerVisible &&
                !panel.contains(e.target) &&
                e.target !== btnEmoji &&
                e.target !== btnEmote) {
                panel.classList.remove('show');
                btnEmoji.classList.remove('active');
                btnEmote.classList.remove('active');
                pickerVisible = false;
            }
        });
        
        // ============================================
        // END EMOJI & EMOTE PICKER
        // ============================================
        
        // Build emote HTML (Twitch emotes)
        function buildEmoteHtml(message, emotes) {
            if (!emotes || Object.keys(emotes).length === 0) {
                return escapeHtml(message);
            }
            
            // Parse emote positions
            const emotePositions = [];
            for (const [emoteId, positions] of Object.entries(emotes)) {
                for (const pos of positions) {
                    const [start, end] = pos.split('-').map(Number);
                    emotePositions.push({ id: emoteId, start, end });
                }
            }
            
            // Sort by position (descending to replace from end)
            emotePositions.sort((a, b) => b.start - a.start);
            
            // Replace emotes with images
            let result = message;
            for (const emote of emotePositions) {
                const emoteText = message.substring(emote.start, emote.end + 1);
                const emoteUrl = `https://static-cdn.jtvnw.net/emoticons/v2/${emote.id}/default/dark/2.0`;
                const emoteHtml = `<img src="${emoteUrl}" alt="${escapeHtml(emoteText)}" class="chat-emote" title="${escapeHtml(emoteText)}">`;
                result = result.substring(0, emote.start) + emoteHtml + result.substring(emote.end + 1);
            }
            
            return result;
        }
        
        // Escape HTML
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Add chat message
        function addChatMessage(data) {
            const container = document.getElementById('chatContainer');
            const emptyState = document.getElementById('emptyState');
            
            // DEBUG: Log what data we receive
            console.log('[ChatPopoutDebug] Received message:', {
                username: data.username,
                message: data.message,
                emotes: data.emotes,
                emotesType: typeof data.emotes,
                emotesKeys: data.emotes ? Object.keys(data.emotes) : 'none'
            });
            
            // Remove empty state
            if (emptyState) {
                emptyState.remove();
            }
            
            // Update connection status
            updateConnectionStatus(true);
            
            // Create message element
            const msgEl = document.createElement('div');
            msgEl.className = 'chat-message';
            
            // Check if this is an action message (/me) or a special command category
            const isAction = data.isAction || false;
            const commandCategory = data.commandCategory || null;
            const isCamper = data.isCamper !== false; // Default to true if not specified
            const isSpecialCategory = commandCategory && ITALIC_COMMAND_CATEGORIES.includes(commandCategory);
            
            // Store camper status for later style updates
            msgEl.setAttribute('data-is-camper', isCamper ? 'true' : 'false');
            
            // Apply non-camper styling if enabled
            if (!isCamper && greyNonCampers) {
                msgEl.classList.add('non-camper');
            }
            
            // Apply bot response styling for special categories
            if (isSpecialCategory) {
                msgEl.classList.add('bot-response');
            }
            
            if (isAction) msgEl.classList.add('action-message');
            
            // Build username with color
            const color = data.color || '#9147ff';
            const displayName = data.displayName || data.username;
            
            // Build message content with emotes
            const messageHtml = buildEmoteHtml(data.message, data.emotes);
            
            // For special command categories (STATE, ANIMATION, MOVEMENT, APPEARANCE),
            // show in italics without bot name prefix (narrative style)
            if (isSpecialCategory || isAction) {
                msgEl.innerHTML = `<em><span class="chat-text">${messageHtml}</span></em>`;
            } else if (displayName) {
                // Regular message with username
                msgEl.innerHTML = `<span class="chat-username" style="color: ${color}">${escapeHtml(displayName)}</span>: <span class="chat-text">${messageHtml}</span>`;
            } else {
                // Bot message without username (but not a special category)
                msgEl.innerHTML = `<span class="chat-text">${messageHtml}</span>`;
            }
            
            container.appendChild(msgEl);
            
            // Store message
            messages.push(data);
            
            // Limit messages
            if (messages.length > maxMessages) {
                messages.shift();
                if (container.firstChild) {
                    container.removeChild(container.firstChild);
                }
            }
            
            // Auto-scroll if at bottom
            if (autoScroll) {
                container.scrollTop = container.scrollHeight;
            }
        }
        
        // Send message
        // Get selected speaker account
        function getSelectedSpeaker() {
            const select = document.getElementById('speakerSelect');
            return select ? select.value : 'main';
        }
        
        async function sendMessage() {
            const input = document.getElementById('chatInput');
            const message = input.value.trim();
            const speaker = getSelectedSpeaker();
            
            if (!message || !isConnected) return;
            
            try {
                if (window.electronAPI && window.electronAPI.sendChatMessage) {
                    const result = await window.electronAPI.sendChatMessage(message, speaker);
                    if (result.ok) {
                        input.value = '';
                    } else {
                        console.error('Failed to send message:', result.error);
                    }
                }
            } catch (err) {
                console.error('Error sending message:', err);
            }
        }
        
        // ============================================
        // @ MENTION AUTOCOMPLETE
        // ============================================
        
        // Mention autocomplete state
        let mentionState = {
            active: false,
            query: '',
            selectedIndex: 0,
            filteredUsers: [],
            allUsers: [],
            cursorPosition: 0,
            mentionStartIndex: -1
        };
        
        // Load chatters list for autocomplete
        async function loadChattersList() {
            if (!window.electronAPI || !window.electronAPI.getChattersList) return;
            try {
                const chatters = await window.electronAPI.getChattersList();
                mentionState.allUsers = chatters || [];
                console.log(`[MentionAutocomplete] Loaded ${mentionState.allUsers.length} chatters`);
            } catch (err) {
                console.error('[MentionAutocomplete] Error loading chatters:', err);
            }
        }
        
        // Refresh chatters list periodically
        setInterval(loadChattersList, 30000); // Refresh every 30 seconds
        
        // Show mention dropdown with filtered users
        function showMentionDropdown(query) {
            const dropdown = document.getElementById('mentionDropdown');
            
            // Filter users based on query
            const queryLower = query.toLowerCase();
            mentionState.filteredUsers = mentionState.allUsers.filter(user =>
                user.username.toLowerCase().includes(queryLower)
            ).slice(0, 10); // Limit to 10 results
            
            if (mentionState.filteredUsers.length === 0) {
                dropdown.innerHTML = '<div class="mention-empty">No users found</div>';
            } else {
                dropdown.innerHTML = mentionState.filteredUsers.map((user, index) => {
                    const badgeClass = user.isBroadcaster ? 'broadcaster' :
                                      user.isMod ? 'mod' :
                                      user.isVip ? 'vip' : '';
                    const badgeText = user.isBroadcaster ? 'BROADCASTER' :
                                     user.isMod ? 'MOD' :
                                     user.isVip ? 'VIP' :
                                     user.isSubscriber ? 'SUB' : '';
                    const initial = user.username.charAt(0).toUpperCase();
                    
                    return `
                        <div class="mention-item ${index === mentionState.selectedIndex ? 'selected' : ''}"
                             data-index="${index}"
                             onclick="selectMention(${index})">
                            <div class="mention-avatar">${initial}</div>
                            <div class="mention-username">${escapeHtml(user.username)}</div>
                            ${badgeText ? `<div class="mention-badge ${badgeClass}">${badgeText}</div>` : ''}
                        </div>
                    `;
                }).join('');
            }
            
            dropdown.classList.add('show');
            mentionState.active = true;
        }
        
        // Hide mention dropdown
        function hideMentionDropdown() {
            const dropdown = document.getElementById('mentionDropdown');
            dropdown.classList.remove('show');
            mentionState.active = false;
            mentionState.query = '';
            mentionState.selectedIndex = 0;
            mentionState.filteredUsers = [];
        }
        
        // Select a mention and insert it
        function selectMention(index) {
            const user = mentionState.filteredUsers[index];
            if (!user) return;
            
            const input = document.getElementById('chatInput');
            const text = input.value;
            const beforeMention = text.substring(0, mentionState.mentionStartIndex);
            const afterCursor = text.substring(mentionState.cursorPosition);
            
            // Insert the mention with a trailing space
            input.value = beforeMention + '@' + user.username + ' ' + afterCursor;
            
            // Set cursor position after the inserted mention
            const newCursorPos = beforeMention.length + user.username.length + 2; // +2 for @ and space
            input.setSelectionRange(newCursorPos, newCursorPos);
            input.focus();
            
            hideMentionDropdown();
        }
        
        // Handle input for mention detection
        function handleMentionInput() {
            const input = document.getElementById('chatInput');
            const text = input.value;
            const cursorPos = input.selectionStart;
            
            // Find if we're in a mention context (after @)
            const textBeforeCursor = text.substring(0, cursorPos);
            const lastAtIndex = textBeforeCursor.lastIndexOf('@');
            
            if (lastAtIndex === -1) {
                hideMentionDropdown();
                return;
            }
            
            // Check if there's a space between @ and cursor (which means we're not in a mention)
            const textBetween = textBeforeCursor.substring(lastAtIndex + 1);
            if (textBetween.includes(' ')) {
                hideMentionDropdown();
                return;
            }
            
            // We're in a mention context
            mentionState.query = textBetween;
            mentionState.cursorPosition = cursorPos;
            mentionState.mentionStartIndex = lastAtIndex;
            mentionState.selectedIndex = 0;
            
            // Show dropdown with filtered results
            showMentionDropdown(mentionState.query);
        }
        
        // Handle keyboard navigation for mentions
        function handleMentionKeydown(e) {
            if (!mentionState.active) return false;
            
            switch (e.key) {
                case 'ArrowDown':
                    e.preventDefault();
                    mentionState.selectedIndex = (mentionState.selectedIndex + 1) % mentionState.filteredUsers.length;
                    showMentionDropdown(mentionState.query);
                    return true;
                    
                case 'ArrowUp':
                    e.preventDefault();
                    mentionState.selectedIndex = mentionState.selectedIndex <= 0
                        ? mentionState.filteredUsers.length - 1
                        : mentionState.selectedIndex - 1;
                    showMentionDropdown(mentionState.query);
                    return true;
                    
                case 'Enter':
                case 'Tab':
                    e.preventDefault();
                    if (mentionState.filteredUsers.length > 0) {
                        selectMention(mentionState.selectedIndex);
                    }
                    return true;
                    
                case 'Escape':
                    e.preventDefault();
                    hideMentionDropdown();
                    return true;
                    
                default:
                    return false;
            }
        }
        
        // Close mention dropdown when clicking outside
        document.addEventListener('click', (e) => {
            const dropdown = document.getElementById('mentionDropdown');
            const input = document.getElementById('chatInput');
            
            if (mentionState.active &&
                !dropdown.contains(e.target) &&
                e.target !== input) {
                hideMentionDropdown();
            }
        });
        
        // ============================================
        // END @ MENTION AUTOCOMPLETE
        // ============================================
        
        // ============================================
        // : EMOTE AUTOCOMPLETE
        // ============================================
        
        // Emote autocomplete state
        let emoteState = {
            active: false,
            query: '',
            selectedIndex: 0,
            filteredEmotes: [],
            allEmotes: []
        };
        
        // Load all emotes for autocomplete
        async function loadEmotesForAutocomplete() {
            // Combine all emote types for autocomplete
            const allEmotes = [];
            
            // Add global emotes
            if (emoteCache.global) {
                allEmotes.push(...emoteCache.global);
            }
            // Add channel emotes
            if (emoteCache.channel) {
                allEmotes.push(...emoteCache.channel);
            }
            // Add user (sub) emotes
            if (emoteCache.user) {
                allEmotes.push(...emoteCache.user);
            }
            
            // Sort all emotes alphabetically by name
            emoteState.allEmotes = allEmotes.sort((a, b) => {
                const nameA = (a.name || a.code || '').toLowerCase();
                const nameB = (b.name || b.code || '').toLowerCase();
                return nameA.localeCompare(nameB);
            });
            
            console.log(`[EmoteAutocomplete] Loaded and sorted ${allEmotes.length} emotes for autocomplete:`, {
                global: emoteCache.global?.length || 0,
                channel: emoteCache.channel?.length || 0,
                user: emoteCache.user?.length || 0
            });
        }
        
        // Pre-load emote cache silently for autocomplete
        async function preloadEmoteCache() {
            const types = ['global', 'channel', 'user'];
            
            console.log('[EmoteAutocomplete] Starting to preload emote cache...');
            
            for (const type of types) {
                if (emoteCache[type]) {
                    console.log(`[EmoteAutocomplete] ${type} emotes already cached (${emoteCache[type].length} emotes)`);
                    continue;
                }
                
                try {
                    if (window.electronAPI && window.electronAPI.getTwitchEmotes) {
                        console.log(`[EmoteAutocomplete] Loading ${type} emotes...`);
                        const emotes = await window.electronAPI.getTwitchEmotes(type);
                        if (emotes && emotes.length > 0) {
                            emoteCache[type] = emotes;
                            console.log(`[EmoteAutocomplete] Loaded ${emotes.length} ${type} emotes`);
                        } else {
                            console.log(`[EmoteAutocomplete] No ${type} emotes available (empty response)`);
                        }
                    } else {
                        console.warn('[EmoteAutocomplete] electronAPI.getTwitchEmotes not available');
                    }
                } catch (error) {
                    console.warn(`[EmoteAutocomplete] Failed to preload ${type} emotes:`, error);
                }
            }
            
            // Log final cache state
            console.log('[EmoteAutocomplete] Cache state:', {
                global: emoteCache.global?.length || 0,
                channel: emoteCache.channel?.length || 0,
                user: emoteCache.user?.length || 0
            });
            
            // Now load all emotes for autocomplete
            loadEmotesForAutocomplete();
        }
        
        // Show emote dropdown with filtered emotes
        function showEmoteDropdown(query) {
            const dropdown = document.getElementById('emoteDropdown');
            
            // Filter emotes based on query (without the leading :)
            const queryLower = query.toLowerCase();
            emoteState.filteredEmotes = emoteState.allEmotes.filter(emote => {
                const name = emote.name || emote.code || '';
                return name.toLowerCase().includes(queryLower);
            }).slice(0, 10); // Limit to 10 results
            
            if (emoteState.filteredEmotes.length === 0) {
                dropdown.innerHTML = '<div class="emote-empty">No emotes found</div>';
            } else {
                dropdown.innerHTML = emoteState.filteredEmotes.map((emote, index) => {
                    const name = emote.name || emote.code || 'emote';
                    const url = emote.url || `https://static-cdn.jtvnw.net/emoticons/v2/${emote.id}/default/dark/2.0`;
                    
                    return `
                        <div class="emote-dropdown-item ${index === emoteState.selectedIndex ? 'selected' : ''}"
                             data-index="${index}"
                             onclick="selectEmote(${index})">
                            <img class="emote-dropdown-preview" src="${url}" alt="${escapeHtml(name)}" onerror="this.style.display='none'">
                            <span class="emote-dropdown-name">${name}</span>
                        </div>
                    `;
                }).join('');
            }
            
            dropdown.classList.add('show');
            emoteState.active = true;
            
            // Scroll selected item into view
            scrollSelectedEmoteIntoView();
        }
        
        // Scroll the selected emote item into view
        function scrollSelectedEmoteIntoView() {
            const dropdown = document.getElementById('emoteDropdown');
            if (!dropdown) return;
            
            const selectedItem = dropdown.querySelector('.emote-dropdown-item.selected');
            if (selectedItem) {
                selectedItem.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
            }
        }
        
        // Hide emote dropdown
        function hideEmoteDropdown() {
            const dropdown = document.getElementById('emoteDropdown');
            dropdown.classList.remove('show');
            emoteState.active = false;
            emoteState.query = '';
            emoteState.selectedIndex = 0;
            emoteState.filteredEmotes = [];
        }
        
        // Select an emote and insert it
        function selectEmote(index) {
            const emote = emoteState.filteredEmotes[index];
            if (!emote) return;
            
            const input = document.getElementById('chatInput');
            const text = input.value;
            const beforeEmote = text.substring(0, emoteState.mentionStartIndex);
            const afterCursor = text.substring(emoteState.cursorPosition);
            
            const emoteName = emote.name || emote.code || 'emote';
            // Insert emote name WITHOUT colons - Twitch renders emotes by their name
            const insertText = emoteName + (afterCursor.startsWith(' ') ? '' : ' ') + afterCursor;
            
            input.value = beforeEmote + insertText;
            
            // Set cursor position after the inserted emote
            const newCursorPos = beforeEmote.length + emoteName.length + (afterCursor.startsWith(' ') ? 0 : 1);
            input.setSelectionRange(newCursorPos, newCursorPos);
            input.focus();
            
            hideEmoteDropdown();
        }
        
        // Handle input for emote detection (typing :)
        function handleEmoteInput() {
            const input = document.getElementById('chatInput');
            const text = input.value;
            const cursorPos = input.selectionStart;
            
            // Find if we're in an emote context (after :)
            const textBeforeCursor = text.substring(0, cursorPos);
            const lastColonIndex = textBeforeCursor.lastIndexOf(':');
            
            if (lastColonIndex === -1) {
                hideEmoteDropdown();
                return;
            }
            
            // Check if there's another : after the first one (which means we're past the trigger)
            const textBetween = textBeforeCursor.substring(lastColonIndex + 1);
            if (textBetween.includes(':')) {
                hideEmoteDropdown();
                return;
            }
            
            // Check if there's a space between : and cursor
            if (textBetween.includes(' ')) {
                hideEmoteDropdown();
                return;
            }
            
            // Check if we're at the start (just typed single :)
            if (textBetween.length === 0) {
                // Show dropdown with all emotes when just : is typed
                if (emoteState.allEmotes.length > 0) {
                    emoteState.query = '';
                    emoteState.cursorPosition = cursorPos;
                    emoteState.mentionStartIndex = lastColonIndex;
                    emoteState.selectedIndex = 0;
                    emoteState.filteredEmotes = emoteState.allEmotes.slice(0, 10);
                    showEmoteDropdown('');
                }
                return;
            }
            
            // We're in an emote context
            emoteState.query = textBetween;
            emoteState.cursorPosition = cursorPos;
            emoteState.mentionStartIndex = lastColonIndex;
            emoteState.selectedIndex = 0;
            
            // Show dropdown with filtered results
            showEmoteDropdown(emoteState.query);
        }
        
        // Handle keyboard navigation for emotes
        function handleEmoteKeydown(e) {
            if (!emoteState.active) return false;
            
            switch (e.key) {
                case 'ArrowDown':
                    e.preventDefault();
                    emoteState.selectedIndex = (emoteState.selectedIndex + 1) % emoteState.filteredEmotes.length;
                    showEmoteDropdown(emoteState.query);
                    return true;
                    
                case 'ArrowUp':
                    e.preventDefault();
                    emoteState.selectedIndex = emoteState.selectedIndex <= 0
                        ? emoteState.filteredEmotes.length - 1
                        : emoteState.selectedIndex - 1;
                    showEmoteDropdown(emoteState.query);
                    return true;
                    
                case 'Enter':
                case 'Tab':
                    e.preventDefault();
                    if (emoteState.filteredEmotes.length > 0) {
                        selectEmote(emoteState.selectedIndex);
                    }
                    return true;
                    
                case 'Escape':
                    e.preventDefault();
                    hideEmoteDropdown();
                    return true;
                    
                default:
                    return false;
            }
        }
        
        // Close emote dropdown when clicking outside
        function setupEmoteDropdownClickHandler() {
            document.addEventListener('click', (e) => {
                const dropdown = document.getElementById('emoteDropdown');
                const input = document.getElementById('chatInput');
                
                if (emoteState.active &&
                    !dropdown.contains(e.target) &&
                    e.target !== input) {
                    hideEmoteDropdown();
                }
            });
        }
        
        // ============================================
        // END : EMOTE AUTOCOMPLETE
        // ============================================
        
        // Handle Enter key in input
        document.getElementById('chatInput').addEventListener('keydown', (e) => {
            // Check for mention navigation first
            if (handleMentionKeydown(e)) {
                return;
            }
            // Check for emote navigation
            if (handleEmoteKeydown(e)) {
                return;
            }
            
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });
        
        // Handle input for mention and emote detection
        document.getElementById('chatInput').addEventListener('input', () => {
            handleMentionInput();
            handleEmoteInput();
        });
        
        // Load emote autocomplete when chat opens
        loadEmotesForAutocomplete();
        
        // Refresh emote cache periodically for autocomplete
        setInterval(() => {
            loadEmotesForAutocomplete();
        }, 60000); // Refresh every minute
        
        // Set up click handler for emote dropdown
        setupEmoteDropdownClickHandler();
        
        // Ensure emote cache is loaded for autocomplete
        // Trigger emote picker to load cache if not already loaded
        
        // Check if scrolled to bottom
        const container = document.getElementById('chatContainer');
        container.addEventListener('scroll', () => {
            const isAtBottom = container.scrollHeight - container.scrollTop <= container.clientHeight + 50;
            autoScroll = isAtBottom;
        });
        
        // Load speaker dropdown with account names
        async function loadSpeakerOptions() {
            if (!window.electronAPI || !window.electronAPI.getTwitchConfig) return;
            try {
                const config = await window.electronAPI.getTwitchConfig();
                const select = document.getElementById('speakerSelect');
                if (!select) return;
                
                // Get account names
                // botUsername = main account (the one that listens to chat)
                // chatBotUsername = separate bot account (for sending messages)
                const mainName = config.botUsername || 'Main Account';
                const botName = config.chatBotUsername || null;
                
                // Check if a separate bot account is configured
                const hasSeparateBot = botName && botName.toLowerCase() !== mainName.toLowerCase();
                
                // Update option labels
                if (hasSeparateBot) {
                    select.innerHTML = `
                        <option value="main">${mainName} (User)</option>
                        <option value="bot">${botName} (Bot)</option>
                    `;
                } else {
                    // Only one account configured
                    select.innerHTML = `
                        <option value="main">${mainName}</option>
                    `;
                }
                
                // Default to main account
                select.value = 'main';
            } catch (e) {
                console.error('Error loading speaker options:', e);
            }
        }
        
        // Load chat history from buffer (for persistence when reopening)
        async function loadChatHistory() {
            if (!window.electronAPI || !window.electronAPI.getChatHistory) return;
            
            try {
                const history = await window.electronAPI.getChatHistory();
                if (history && history.length > 0) {
                    console.log(`[ChatPopout] Loading ${history.length} messages from history`);
                    // Add each historical message
                    for (const msg of history) {
                        addChatMessage(msg);
                    }
                }
            } catch (e) {
                console.error('[ChatPopout] Error loading chat history:', e);
            }
        }
        
        // Listen for chat messages from main process
        if (window.electronAPI) {
            // Load chat history first (before listening for new messages)
            loadChatHistory();
            
            // Listen for chatMessage channel (same as widget uses)
            window.electronAPI.onChatMessage((data) => {
                addChatMessage(data);
            });
            
            // Listen for Twitch connection status changes
            if (window.electronAPI.onTwitchConnected) {
                window.electronAPI.onTwitchConnected(() => {
                    updateConnectionStatus(true);
                });
            }
            
            if (window.electronAPI.onTwitchDisconnected) {
                window.electronAPI.onTwitchDisconnected(() => {
                    updateConnectionStatus(false);
                });
            }
            
            // Get initial connection status
            if (window.electronAPI.getTwitchStatus) {
                window.electronAPI.getTwitchStatus().then(status => {
                    updateConnectionStatus(status && status.connected);
                }).catch(() => {
                    updateConnectionStatus(false);
                });
            }
            
            // Load speaker options
            loadSpeakerOptions();
            
            // Load chatters list for mention autocomplete
            loadChattersList();
            
            // Pre-load emote cache for autocomplete (silently, without displaying)
            preloadEmoteCache().then(() => {
                // Load all emotes for autocomplete AFTER cache is populated
                loadEmotesForAutocomplete();
            });
        }
    </script>
</body>
</html>
