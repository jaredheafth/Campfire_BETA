<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Campfire Widget - Dashboard</title>
    <!-- External CSS Files for Better Performance -->
    <link rel="stylesheet" href="styles/dashboard-base.css">
    <link rel="stylesheet" href="styles/dashboard-forms.css">
    <link rel="stylesheet" href="styles/dashboard-tabs.css">
    <link rel="stylesheet" href="styles/dashboard-modes.css">
    
    <!-- Performance Optimization Scripts -->
    <script src="scripts/performance-utils.js"></script>
    <script src="scripts/virtual-list.js"></script>
    <script src="scripts/performance-settings-ui.js"></script>
</head>
<body style="display: block !important; visibility: visible !important; opacity: 1 !important;">
    <div class="container" style="display: flex !important; visibility: visible !important; opacity: 1 !important;">
        
        <!-- Settings Modal -->
        <div id="settingsModal" class="settings-modal" onclick="if(event.target === this) closeSettings()">
            <div class="settings-modal-content" onclick="event.stopPropagation()">
                <div class="settings-modal-header">
                    <h2>‚öôÔ∏è Settings</h2>
                    <button class="settings-modal-close" onclick="closeSettings()">√ó</button>
                </div>
                
                <div class="settings-section-item">
                    <label>Default Sprites Path</label>
                    <div class="path-display" id="spritePathDisplay">Loading...</div>
                    <div class="path-info" id="spritePathInfo"></div>
                    <div class="path-actions">
                        <button class="button button-secondary" onclick="browseSpritePath()" style="flex: 1; min-width: 140px;">
                            üìÅ Browse Folder
                        </button>
                        <button class="button button-secondary" onclick="resetSpritePath()" id="resetSpritePathBtn" style="flex: 1; min-width: 140px; display: none;">
                            üîÑ Reset to Default
                        </button>
                    </div>
                </div>
                
                <div class="settings-section-item" style="border-top: 1px solid #333; padding-top: 20px; margin-top: 20px;">
                    <label>Widget Window Dimensions</label>
                    <div style="font-size: 11px; color: #888; margin-top: 5px; margin-bottom: 10px;">
                        Minimum: 600 x 600 pixels
                    </div>
                    <div style="margin-top: 10px; display: flex; gap: 15px; align-items: center; flex-wrap: wrap;">
                        <div style="flex: 1; min-width: 120px;">
                            <label style="font-size: 11px; color: #aaa; display: block; margin-bottom: 5px;">Width</label>
                            <input type="number" id="windowWidth" min="600" max="7680" step="1" style="width: 100%; padding: 6px; background: #2a2a2a; border: 1px solid #444; border-radius: 4px; color: #fff; font-size: 13px;">
                        </div>
                        <div style="flex: 1; min-width: 120px;">
                            <label style="font-size: 11px; color: #aaa; display: block; margin-bottom: 5px;">Height</label>
                            <input type="number" id="windowHeight" min="600" max="4320" step="1" style="width: 100%; padding: 6px; background: #2a2a2a; border: 1px solid #444; border-radius: 4px; color: #fff; font-size: 13px;">
                        </div>
                        <div style="display: flex; align-items: flex-end;">
                            <button id="toggleLockBtn" onclick="toggleWindowLock()" style="padding: 6px 14px; background: #444; border: 1px solid #666; border-radius: 4px; color: #fff; cursor: pointer; font-size: 13px; white-space: nowrap;">
                                üîì Unlock
                            </button>
                        </div>
                    </div>
                    <div style="margin-top: 10px; display: flex; gap: 10px;">
                        <button class="button button-secondary" onclick="applyWindowDimensions()" style="flex: 1; min-width: 140px;">
                            ‚úÖ Apply Dimensions
                        </button>
                    </div>
                    <div class="path-info" id="windowDimensionsInfo" style="margin-top: 8px; font-size: 11px; color: #888;"></div>

                    <div style="margin-top: 16px; border-top: 1px solid #333; padding-top: 16px;">
                        <label style="display:block; margin-bottom: 6px;">Capture Options</label>

                        <label style="display: flex; align-items: center; gap: 10px; cursor: pointer; font-size: 13px; color: #e0e0e0; margin-bottom: 8px;">
                            <input type="checkbox" id="useNativeFrame" checked onchange="updateFullPreview();" style="width: 16px; height: 16px; cursor: pointer;">
                            <span>Show Title Bar (native window frame)</span>
                        </label>
                        <div id="useNativeFrameHint" style="margin-top: 0; margin-bottom: 12px; font-size: 11px; color: #888;">
                            Tip: Turning this off makes the widget window frameless, and the in-widget menu bar becomes the draggable area.
                        </div>

                        <div>
                            <label style="font-size: 12px; color: #aaa; display: block; margin-bottom: 6px;">Widget Background</label>
                            <input type="hidden" id="widgetBackground" value="black">
                            <div class="bg-swatch-grid" aria-label="Widget Background">
                                <button type="button" class="bg-swatch bg-swatch-transparent" data-bg="transparent" onclick="setWidgetBackground('transparent')" title="Transparent"></button>
                                <button type="button" class="bg-swatch" data-bg="black" onclick="setWidgetBackground('black')" title="Black" style="background:#000;"></button>
                                <button type="button" class="bg-swatch" data-bg="white" onclick="setWidgetBackground('white')" title="White" style="background:#fff;"></button>
                                <button type="button" class="bg-swatch" data-bg="green" onclick="setWidgetBackground('green')" title="Green Screen" style="background:#00ff00;"></button>
                            </div>
                            <div style="margin-top: 8px; font-size: 11px; color: #888;">
                                Tip: Green is best for chroma key. Transparent depends on capture method (Browser Source is usually best).
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

    <!-- Status Indicator at Bottom Center -->
    <div style="position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%); z-index: 999999; display: flex; align-items: center; gap: 8px; padding: 8px 14px; background: rgba(26, 26, 26, 0.9); backdrop-filter: blur(10px); border: 1px solid rgba(255, 255, 255, 0.15); border-radius: 6px; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);">
        <div class="status-indicator" id="statusIndicator"></div>
        <span id="statusText" style="font-size: 11px; color: #fff;">Disconnected</span>
    </div>
    
    <style>
        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #ff3b30;
            animation: pulse 2s infinite;
        }
        
        .status-indicator.connected {
            background: #34c759;
        }
        
        @keyframes pulse {
            0% {
                transform: scale(1);
                opacity: 1;
            }
            50% {
                transform: scale(1.2);
                opacity: 0.7;
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }
    </style>
    
        
        <div id="overlayBackdrop" onclick="closeOverlay()"></div>
        <div id="overlayCard">
            <div id="overlayBody">
                <div id="dashboardPanels">
        <div class="main-layout">
            <div class="settings-panel">
                <div class="info-box">
                    <strong>üìã How to Use:</strong> Configure your settings below, then copy the generated code and paste it into OBS as a Browser Source or Custom Widget.
                    <div style="margin-top: 10px; display: flex; align-items: center; justify-content: space-between; gap: 10px; flex-wrap: wrap;">
                        <!-- Left side: Action buttons -->
                        <div style="display: flex; align-items: center; gap: 10px; flex-wrap: wrap;">
                            <button onclick="kickAllUsersConfirm()" class="button-secondary" title="Kick all (non-test) users">
                                ‚òÅÔ∏è
                            </button>
                            <button onclick="joinAllControlledConfirm()" class="button-secondary" title="Follow Join Rules">
                                üî•
                            </button>
                            <button onclick="joinAllChaosConfirm()" class="button-secondary" title="Override Join Rules">
                                ‚ö°
                            </button>
                            <span style="font-weight: 600; color: #888; font-size: 12px;">Test Users:</span>
                            <button onclick="showAllTestUsers()" class="button-secondary" title="Show all test users">
                                ‚úÖ
                            </button>
                            <button onclick="hideAllTestUsers()" class="button-secondary" title="Hide all test users">
                                ‚ùå
                            </button>
                        </div>
                        <!-- Right side: Settings and Save buttons -->
                        <div style="display: flex; align-items: center; gap: 10px; flex-wrap: wrap;">
                            <button onclick="checkForUpdates()" class="button-secondary" title="Check for Updates">
                                üîÑ
                            </button>
                            <button onclick="openSettings()" class="button-secondary" title="App Settings">
                                ‚öôÔ∏è
                            </button>
                            <button onclick="saveSettingsWithNotification()" class="button button-primary" style="background: rgba(76, 175, 80, 0.3); border-color: rgba(76, 175, 80, 0.5);" title="Save Settings">
                                üíæ
                            </button>
                        </div>
                    </div>
                </div>

                <div class="tabs">
                    <button class="tab active" onclick="switchSettingsTab('campfire', this)">Campfire</button>
                    <button class="tab" onclick="switchSettingsTab('sprites', this)">Sprites</button>
                    <button class="tab" onclick="switchSettingsTab('glow', this)">Glow</button>
                    <button class="tab" onclick="switchSettingsTab('size', this)">View</button>
                    <button class="tab" onclick="switchSettingsTab('twitch', this)">Twitch</button>
                    <button class="tab" onclick="switchSettingsTab('chat', this)">Chat</button>
                    <button class="tab" onclick="switchSettingsTab('join', this)">Join</button>
                    <button class="tab" onclick="switchSettingsTab('members', this)">Members</button>
                    <button class="tab" onclick="switchSettingsTab('commands', this)">Commands</button>
                    <button class="tab" onclick="switchSettingsTab('code', this)">Code</button>
                    <button class="tab" onclick="switchSettingsTab('audio', this)">Audio</button>
                </div>

                <div id="settingsTab" class="tab-content active">
                    <!-- Campfire Graphic Tab -->
                    <div id="campfireTab" class="settings-section active">
                        <div class="form-section">
                            <!-- Hide Campfire Toggle -->
                            <div class="form-group" style="margin-bottom: 20px; padding-bottom: 15px; border-bottom: 1px solid #3a3a3a;">
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <input type="checkbox" id="hideCampfireGraphic" onchange="toggleCampfireVisibility(this.checked)">
                                    <label for="hideCampfireGraphic" style="margin: 0; cursor: pointer;">
                                        <strong>Hide Campfire Graphic & Glow</strong>
                                        <span class="label-hint" style="display: block; margin-top: 4px;">Hide the campfire graphic and glow effect (sprites will still be visible)</span>
                                    </label>
                                </div>
                            </div>
                            
                            <div class="form-group">
                                <label>
                                    Upload Method
                                    <span class="label-hint">Choose how to provide the campfire graphic</span>
                                </label>
                                <div style="display: flex; gap: 10px;">
                                    <button type="button" id="btnMethodUrl" class="button" onclick="setCampfireMethod('url')" style="flex: 1;">
                                        URL
                                    </button>
                                    <button type="button" id="btnMethodUpload" class="button-secondary" onclick="setCampfireMethod('upload')" style="flex: 1;">
                                        UPLOAD
                                    </button>
                                </div>
                            </div>

                            <div id="campfireUrlSection" class="form-group">
                                <label for="campfireUrl">
                                    Campfire GIF/Video URL
                                    <span class="label-hint">Enter a direct URL to a GIF or video file. You can upload to Imgur, Giphy, or any image hosting service.</span>
                                </label>
                                <input type="url" id="campfireUrl" placeholder="https://example.com/campfire.gif" oninput="updateFullPreview()">
                                <div id="campfireUrlStatus" style="margin-top: 8px; font-size: 12px; color: #888; display: none;">
                                    <span style="color: #ffa500;">‚ö†Ô∏è</span> You have an uploaded graphic that will be overridden if you use a URL
                                </div>
                            </div>

                            <div id="campfireUploadSection" class="form-group" style="display: none;">
                                <label for="campfireUpload">
                                    Upload Campfire Graphic
                                    <span class="label-hint">Upload a GIF, image, or video file for your campfire</span>
                                </label>
                                <div style="display: flex; align-items: center; gap: 10px; flex-wrap: wrap;">
                                    <input type="file" id="campfireUpload" accept="image/*,.gif,video/*,.mp4,.webm,.mov" onchange="handleCampfireUpload(event)" style="flex: 1; min-width: 200px;">
                                    <button type="button" class="button-secondary" onclick="clearCampfireUpload()">üóëÔ∏è Clear Upload</button>
                                    <button type="button" class="button-secondary" onclick="clearAllGraphics()">üóëÔ∏è Clear All Graphics (Fix Issues)</button>
                                </div>
                                <div id="campfirePreview" class="sprite-preview" style="margin-top: 10px;">
                                    <span style="color: #888; font-size: 12px;">No campfire graphic uploaded</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Glow Settings Tab -->
                    <div id="glowTab" class="settings-section">
                        <div class="form-section">
                            <div class="form-group">
                                <label for="glowSize">
                                    Glow Size
                                    <span class="label-hint">Size of the glow effect around the campfire</span>
                                </label>
                                <div class="range-container">
                                    <input type="range" id="glowSize" min="100" max="800" value="500" step="10" oninput="updateGlowSizeDisplay(); updateFullPreview();">
                                    <div class="range-value" id="glowSizeValue">500px</div>
                                </div>
                            </div>

                            <div class="form-group">
                                <label for="glowIntensity">
                                    Glow Intensity
                                    <span class="label-hint">Overall opacity/brightness of the glow</span>
                                </label>
                                <div class="range-container">
                                    <input type="range" id="glowIntensity" min="0" max="100" value="77" step="1" oninput="updateGlowIntensityDisplay(); updateFullPreview();">
                                    <div class="range-value" id="glowIntensityValue">77%</div>
                                </div>
                            </div>

                            <div class="form-group">
                                <label for="shadowIntensity">
                                    Shadow Intensity
                                    <span class="label-hint">Intensity of drop shadows on the fire emoji</span>
                                </label>
                                <div class="range-container">
                                    <input type="range" id="shadowIntensity" min="0" max="100" value="91" step="1" oninput="updateShadowIntensityDisplay(); updateFullPreview();">
                                    <div class="range-value" id="shadowIntensityValue">91%</div>
                                </div>
                            </div>

                            <div class="form-group">
                                <label for="glowSpread">
                                    Glow Spread
                                    <span class="label-hint">How far the glow extends outward</span>
                                </label>
                                <div class="range-container">
                                    <input type="range" id="glowSpread" min="20" max="100" value="64" step="1" oninput="updateGlowSpreadDisplay(); updateFullPreview();">
                                    <div class="range-value" id="glowSpreadValue">64%</div>
                                </div>
                                <div class="range-labels">
                                    <span>Concentrated</span>
                                    <span>Diffused</span>
                                </div>
                            </div>

                            <div class="form-group" style="margin-bottom: 0;">
                                <div class="checkbox-group">
                                    <input type="checkbox" id="animatedGlow" checked onchange="updateFullPreview()">
                                    <label for="animatedGlow" style="margin: 0;">Animated Glow</label>
                                </div>
                                <span class="label-hint">Creates a gentle pulsing fire effect</span>
                            </div>

                            <div class="form-group" style="margin-top: 14px;">
                                <label for="flickerOpacity">
                                    Flicker Opacity
                                    <span class="label-hint">A second glow layer that sits in front of the campfire</span>
                                </label>
                                <div class="range-container">
                                    <input type="range" id="flickerOpacity" min="0" max="100" value="25" step="1" oninput="updateFlickerOpacityDisplay(); updateFullPreview();">
                                    <div class="range-value" id="flickerOpacityValue">25%</div>
                                </div>
                            </div>

                            <div class="form-group">
                                <label for="flickerSpread">
                                    Flicker Size / Spread
                                    <span class="label-hint">How wide the flicker glow expands (front layer)</span>
                                </label>
                                <div class="range-container">
                                    <input type="range" id="flickerSpread" min="20" max="100" value="55" step="1" oninput="updateFlickerSpreadDisplay(); updateFullPreview();">
                                    <div class="range-value" id="flickerSpreadValue">55%</div>
                                </div>
                                <div class="range-labels">
                                    <span>Tight</span>
                                    <span>Wide</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Size Settings Tab -->
                    <div id="sizeTab" class="settings-section">
                        <div class="form-section">
                            <h4>Perspective</h4>
                            <div class="form-group">
                                <label for="circleAngle">
                                    View Angle
                                    <span class="label-hint">Adjust from top-down view (circle) to side view (ellipse/line)</span>
                                </label>
                                <div class="range-container">
                                    <input type="range" id="circleAngle" min="0" max="90" value="64" step="1" oninput="updateAngleDisplay(); updateFullPreview();">
                                    <div class="range-value" id="angleValue">64¬∞</div>
                                </div>
                                <div class="range-labels">
                                    <span>Top-Down (Circle)</span>
                                    <span>Side View (Line)</span>
                                </div>
                            </div>

                            <h4>Sizing</h4>
                            <div class="form-group">
                                <label for="fireSize">
                                    Fire Size
                                    <span class="label-hint">Size of the fire emoji/graphic (in pixels)</span>
                                </label>
                                <div class="range-container">
                                    <input type="range" id="fireSize" min="24" max="120" value="48" step="2" oninput="updateFireSizeDisplay();">
                                    <div class="range-value" id="fireSizeValue">48px</div>
                                </div>
                            </div>

                            <div class="form-group">
                                <label for="spriteSize">
                                    Sprite Size
                                    <span class="label-hint">Size of user sprites/shapes (in pixels)</span>
                                </label>
                                <div class="range-container">
                                    <input type="range" id="spriteSize" min="20" max="300" value="40" step="5" oninput="updateSpriteSizeDisplay();">
                                    <div class="range-value" id="spriteSizeValue">40px</div>
                                </div>
                            </div>

                            <div class="form-group">
                                <label for="chatBubbleSize">
                                    Chat Bubbles Size
                                    <span class="label-hint">Size of chat message bubbles and font</span>
                                </label>
                                <div class="range-container">
                                    <input type="range" id="chatBubbleSize" min="8" max="20" value="11" step="1" oninput="updateChatBubbleSizeDisplay();">
                                    <div class="range-value" id="chatBubbleSizeValue">11px</div>
                                </div>
                            </div>

                            <h4>Offset</h4>
                            <div class="form-group">
                                <label for="campfireYOffset">
                                    Campfire Vertical Offset
                                    <span class="label-hint">Move the campfire graphic up/down. Center is 50.</span>
                                </label>
                                <div class="range-container">
                                    <input type="range" id="campfireYOffset" min="0" max="100" value="50" step="1" oninput="updateCampfireYOffsetDisplay();">
                                    <div class="range-value" id="campfireYOffsetValue">50 (+0px)</div>
                                </div>
                                <div class="range-labels">
                                    <span>Up</span>
                                    <span>Down</span>
                                </div>
                            </div>

                            <div class="form-group">
                                <label for="nameBubbleOffset">
                                    Name/Bubble Offset
                                    <span class="label-hint">Adjust vertical position of usernames and chat bubbles above sprites</span>
                                </label>
                                <div class="range-container">
                                    <input type="range" id="nameBubbleOffset" min="-50" max="50" value="25" step="1" oninput="updateNameBubbleOffsetDisplay();">
                                    <div class="range-value" id="nameBubbleOffsetValue">-25px</div>
                                </div>
                                <div class="range-labels">
                                    <span>Lower</span>
                                    <span>Higher</span>
                                </div>
                            </div>
                        </div>
                    </div>


                    <!-- Twitch Connection Tab -->
                    <div id="twitchTab" class="settings-section">
                        <div class="form-section" style="max-height: 500px; overflow-y: auto; padding-right: 8px;">
                            <div class="form-group">
                                <label>
                                    Twitch Connection
                                    <span class="label-hint">Connect your Twitch account to enable chat integration</span>
                                </label>
                                <div id="twitchConnectionStatus" style="padding: 15px; background: #2a2a2a; border-radius: 8px; margin-bottom: 15px;">
                                    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
                                        <span id="twitchStatusIcon">‚ö™</span>
                                        <span id="twitchStatusText">Not Connected</span>
                                    </div>
                                    <div id="twitchConfigDisplay" style="display: none; font-size: 12px; color: #888; margin-top: 10px;">
                                        <div>Username: <span id="twitchUsernameDisplay">-</span></div>
                                        <div>Channel: <span id="twitchChannelDisplay">-</span></div>
                                        <div id="twitchBotAccountDisplay" style="display: none;">Bot Account: <span id="twitchBotAccountName">-</span></div>
                                    </div>
                                </div>
                                
                            </div>
                            
                            <!-- Top controls: Checkbox and Save button -->
                            <div style="display: flex; align-items: center; justify-content: space-between; margin-top: 20px; margin-bottom: 15px; padding: 12px; background: #1f1f1f; border-radius: 6px; border: 1px solid #333;">
                                <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; font-size: 14px; color: #fff;">
                                    <input type="checkbox" id="useSeparateChatBot" onchange="toggleChatBotInputs()" style="cursor: pointer; width: 16px; height: 16px;">
                                    <span>Use separate bot account for sending messages</span>
                                </label>
                                <button type="button" class="button button-primary" onclick="saveTwitchConfig()" style="padding: 8px 20px; font-size: 13px;">
                                    üíæ Save Configuration
                                </button>
                            </div>
                            
                            <div class="form-group">
                                <label for="twitchChannelName">
                                    Channel Name
                                    <span class="label-hint">Channel to monitor (usually same as your username)</span>
                                </label>
                                <input type="text" id="twitchChannelName" placeholder="your_channel" oninput="updateTwitchConfig(); autoFillUsernameFromChannel();">
                            </div>
                            
                            <!-- Side-by-side layout for Main Account and Chat Bot Account -->
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 20px;">
                                <!-- Main Account Column -->
                                <div style="border: 1px solid #333; border-radius: 8px; padding: 15px; background: #1f1f1f;">
                                    <h3 style="margin-top: 0; margin-bottom: 5px; color: #ff6b35; font-size: 16px;">üì∫ Main Account</h3>
                                    <div id="mainAccountStatusIndicator" style="margin-bottom: 15px; font-size: 11px; color: #888;">
                                        <span id="mainAccountStatusIcon">‚ö™</span>
                                        <span id="mainAccountStatusText">Not configured</span>
                                    </div>
                                    
                            <div class="form-group">
                                <label for="twitchBotUsername">
                                    Twitch Username
                                    <span class="label-hint">Your Twitch username</span>
                                </label>
                                <input type="text" id="twitchBotUsername" placeholder="your_username" readonly onfocus="this.removeAttribute('readonly')" onblur="this.setAttribute('readonly', ''); autoFillUsernameFromChannel();" style="background: #2a2a2a; cursor: text;" oninput="updateTwitchConfig()">
                            </div>
                                    
                                    <div class="form-group">
                                        <label for="twitchAccessToken">
                                            ACCESS TOKEN
                                            <span class="label-hint">From token generator</span>
                                        </label>
                                        <div style="display: flex; gap: 5px; margin-bottom: 10px;">
                                            <input type="password" id="twitchAccessToken" placeholder="Access Token..." style="flex: 1; font-size: 11px;">
                                            <button type="button" class="button button-secondary" onclick="toggleAccessTokenVisibility()" style="white-space: nowrap; padding: 5px 10px; font-size: 11px;">
                                                üëÅÔ∏è
                                            </button>
                                        </div>
                                    </div>
                                    
                                    <div class="form-group">
                                        <label for="twitchRefreshToken">
                                            REFRESH TOKEN
                                            <span class="label-hint">From token generator (optional)</span>
                                        </label>
                                        <div style="display: flex; gap: 5px; margin-bottom: 10px;">
                                            <input type="password" id="twitchRefreshToken" placeholder="Refresh Token..." style="flex: 1; font-size: 11px;">
                                            <button type="button" class="button button-secondary" onclick="toggleRefreshTokenVisibility()" style="white-space: nowrap; padding: 5px 10px; font-size: 11px;">
                                                üëÅÔ∏è
                                            </button>
                                        </div>
                                    </div>
                                    
                                    <div class="form-group">
                                        <label for="twitchClientId">
                                            CLIENT ID
                                            <span class="label-hint">From token generator</span>
                                        </label>
                                        <input type="text" id="twitchClientId" placeholder="Client ID..." style="width: 100%; font-size: 11px;">
                                    </div>
                                    
                                    <button type="button" class="button button-primary" id="generateTwitchToken" onclick="generateTwitchToken('main')" style="width: 100%; margin-top: 10px; font-size: 12px;">
                                        üîë Generate Token
                                    </button>
                                    
                                    <div style="display: flex; gap: 8px; margin-top: 8px;">
                                        <button type="button" class="button button-primary" onclick="connectTwitchAccount('main')" style="flex: 1; font-size: 12px; background: #4caf50;">
                                            üîå Connect
                                        </button>
                                        <button type="button" class="button button-secondary" id="disconnectMainBtn" onclick="disconnectTwitchAccount('main')" style="flex: 1; font-size: 12px; background: #ff4444; display: none;">
                                            üîå Disconnect
                                        </button>
                                    </div>
                                </div>
                                
                                <!-- Chat Bot Account Column -->
                                <div style="border: 1px solid #333; border-radius: 8px; padding: 15px; background: #1f1f1f;">
                                        <h3 style="margin-top: 0; margin-bottom: 5px; color: #ff6b35; font-size: 16px;">ü§ñ Chat Bot Account</h3>
                                        <div id="chatBotStatusIndicator" style="margin-bottom: 15px; font-size: 11px; color: #888;">
                                            <span id="chatBotStatusIcon">‚ö™</span>
                                            <span id="chatBotStatusText">Not configured</span>
                                        </div>
                                    
                                    <div class="form-group">
                                        <label for="twitchChatBotUsername">
                                            Twitch Username
                                            <span class="label-hint">Bot account username</span>
                                        </label>
                                        <input type="text" id="twitchChatBotUsername" placeholder="bot_username" oninput="updateTwitchConfig()" disabled style="opacity: 0.5; cursor: not-allowed;">
                                    </div>
                                    
                                    <div class="form-group">
                                        <label for="twitchChatBotAccessToken">
                                            ACCESS TOKEN
                                            <span class="label-hint">From token generator</span>
                                        </label>
                                        <div style="display: flex; gap: 5px; margin-bottom: 10px;">
                                            <input type="password" id="twitchChatBotAccessToken" placeholder="Access Token..." style="flex: 1; font-size: 11px;" disabled>
                                            <button type="button" class="button button-secondary" onclick="toggleChatBotAccessTokenVisibility()" style="white-space: nowrap; padding: 5px 10px; font-size: 11px;" disabled>
                                                üëÅÔ∏è
                                            </button>
                                        </div>
                                    </div>
                                    
                                    <div class="form-group">
                                        <label for="twitchChatBotRefreshToken">
                                            REFRESH TOKEN
                                            <span class="label-hint">From token generator (optional)</span>
                                        </label>
                                        <div style="display: flex; gap: 5px; margin-bottom: 10px;">
                                            <input type="password" id="twitchChatBotRefreshToken" placeholder="Refresh Token..." style="flex: 1; font-size: 11px;" disabled>
                                            <button type="button" class="button button-secondary" onclick="toggleChatBotRefreshTokenVisibility()" style="white-space: nowrap; padding: 5px 10px; font-size: 11px;" disabled>
                                                üëÅÔ∏è
                                            </button>
                                        </div>
                                    </div>
                                    
                                    <div class="form-group">
                                        <label for="twitchChatBotClientId">
                                            CLIENT ID
                                            <span class="label-hint">From token generator</span>
                                        </label>
                                        <input type="text" id="twitchChatBotClientId" placeholder="Client ID..." style="width: 100%; font-size: 11px;" disabled>
                                    </div>
                                    
                                    <button type="button" class="button button-primary" id="generateChatBotToken" onclick="generateTwitchToken('chatbot')" style="width: 100%; margin-top: 10px; font-size: 12px;" disabled>
                                        üîë Generate Token
                                    </button>
                                    
                                    <div style="display: flex; gap: 8px; margin-top: 8px;">
                                        <button type="button" class="button button-primary" id="connectChatBotBtn" onclick="connectTwitchAccount('chatbot')" style="flex: 1; font-size: 12px; background: #4caf50;" disabled>
                                            üîå Connect
                                        </button>
                                        <button type="button" class="button button-secondary" id="disconnectChatBotBtn" onclick="disconnectTwitchAccount('chatbot')" style="flex: 1; font-size: 12px; background: #ff4444; display: none;" disabled>
                                            üîå Disconnect
                                        </button>
                                    </div>
                                </div>
                            </div>
                            </div>
                            
                            <div style="margin-top: 15px; padding: 10px; background: #1a1a1a; border-radius: 5px; border-left: 3px solid #ff6b35;">
                                <p style="margin: 0; font-size: 11px; color: #888;">
                                    üí° <strong>Tip:</strong> Click "Generate Token" to open the token generator. Use the checkbox at the top to configure a separate bot account for sending messages.
                                </p>
                                <p style="margin: 8px 0 0 0; font-size: 11px; color: #888;">
                                    ü§ñ <strong>About Bot Account:</strong> The bot account uses the Main Account's connection to Twitch. When connected, bot messages are sent using the bot's credentials. Both accounts share the same connection status.
                                </p>
                            </div>
                            
                            <div style="margin-top: 20px; padding: 15px; background: #1a1a1a; border-radius: 8px; border-left: 3px solid #ff6b35;">
                                <strong style="color: #ff6b35;">‚ÑπÔ∏è How it works:</strong>
                                <ol style="margin-top: 10px; padding-left: 20px; font-size: 13px; line-height: 1.8;">
                                    <li>Enter your Twitch username (channel name will auto-fill)</li>
                                    <li>Click "Generate Token" to open the token generator</li>
                                    <li>Copy and paste your Access Token, Refresh Token, and Client ID</li>
                                    <li>Click "Save Configuration" at the top</li>
                                    <li>The widget will automatically connect to your channel</li>
                                </ol>
                                <p style="margin-top: 10px; font-size: 12px; color: #888;">
                                    <strong>Why Channel Name?</strong> The channel name tells the widget which Twitch channel's chat to monitor. 
                                    It's usually the same as your username, but you can monitor a different channel if needed (e.g., if you're using a bot account to monitor another streamer's chat).
                                </p>
                            </div>
                        </div>
                    </div>

                    <!-- Twitch Chat Tab -->
                    <div id="chatTab" class="settings-section">
                        <div class="form-section">
                            <div class="form-group">
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                    <label style="margin: 0;">
                                        Twitch Chat
                                        <span class="label-hint">Live chat from your channel. Connect in the Twitch tab to see messages.</span>
                                    </label>
                                    <button class="button button-secondary" onclick="openChatPopout()" style="padding: 6px 12px; font-size: 12px;">
                                        üóó Pop Out Chat
                                    </button>
                                </div>
                                <div id="twitchChatLog" style="height: 320px; overflow-y: auto; background: #1a1a1a; border: 1px solid #333; border-radius: 8px; padding: 12px; font-family: 'Consolas', 'Monaco', monospace; font-size: 13px; line-height: 1.5;">
                                    <div id="twitchChatEmpty" style="color: #666;">Connect to Twitch in the Twitch tab to see chat. Messages will appear here when they're sent in your channel.</div>
                                </div>
                            </div>

                            <h4>Chat Bubble Settings</h4>
                            <div class="form-group">
                                <label for="chatBubbleDuration">
                                    Chat Bubble Duration
                                    <span class="label-hint">How long chat bubbles stay visible above sprites (in seconds)</span>
                                </label>
                                <div class="range-container">
                                    <input type="range" id="chatBubbleDuration" min="1" max="30" value="3" step="1" oninput="updateChatBubbleDurationDisplay();">
                                    <div class="range-value" id="chatBubbleDurationValue">3s</div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Join Settings Tab -->
                    <div id="joinTab" class="settings-section">
                        <div class="form-section">
                            <!-- Join Method, Command/Emote/Cheer, and Max Users in one row -->
                            <div class="form-row">
                                <!-- Join Method -->
                                <div class="form-group form-group-compact">
                                    <label for="joinMethod">
                                        Join Method
                                        <span class="label-hint">How viewers join</span>
                                    </label>
                                    <select id="joinMethod" onchange="updateJoinMethod(); updateFullPreview();">
                                        <option value="command">Chat Command</option>
                                        <option value="emote">Emote</option>
                                        <option value="cheer">Cheer/Payment</option>
                                    </select>
                                </div>

                                <!-- Command Settings (shown when method is "command") -->
                                <div id="commandSettings" class="form-group form-group-compact">
                                    <label for="command">
                                        Join Command(s)
                                        <span class="label-hint">e.g., !join, !camp (comma-separated)</span>
                                    </label>
                                    <input type="text" id="command" value="!join" placeholder="!join" oninput="updateFullPreview(); updateCurrentCommandDisplay();">
                                </div>

                                <!-- AFK Command Settings -->
                                <div class="form-group form-group-compact">
                                    <label for="afkCommand">
                                        AFK Command(s)
                                        <span class="label-hint">e.g., !afk, !brb (comma-separated)</span>
                                    </label>
                                    <input type="text" id="afkCommand" value="!afk" placeholder="!afk" oninput="updateAfkCommandDisplay();">
                                </div>

                                <!-- Lurk Command Settings -->
                                <div class="form-group form-group-compact">
                                    <label for="lurkCommand">
                                        Lurk Command(s)
                                        <span class="label-hint">e.g., !lurk (comma-separated)</span>
                                    </label>
                                    <input type="text" id="lurkCommand" value="!lurk" placeholder="!lurk" oninput="updateLurkCommandDisplay();">
                                </div>

                                <!-- Emote Settings (shown when method is "emote") -->
                                <div id="emoteSettings" class="form-group form-group-compact" style="display: none;">
                                    <label for="emoteName">
                                        Emote Name
                                        <span class="label-hint">e.g., Campfire</span>
                                    </label>
                                    <input type="text" id="emoteName" value="" placeholder="Campfire" oninput="updateFullPreview();">
                                </div>

                                <!-- Cheer Settings (shown when method is "cheer") -->
                                <div id="cheerSettings" class="form-group form-group-compact" style="display: none;">
                                    <label for="cheerMethod">
                                        Payment Type
                                        <span class="label-hint">What they pay with</span>
                                    </label>
                                    <select id="cheerMethod" onchange="updateFullPreview();">
                                        <option value="bits">Bits</option>
                                        <option value="giftsubs">Gift Subs</option>
                                        <option value="both">Bits or Gift Subs</option>
                                    </select>
                                </div>

                                <!-- Cheer Amount (shown when method is "cheer") -->
                                <div id="cheerAmountSettings" class="form-group form-group-compact" style="display: none;">
                                    <label for="cheerAmount">
                                        Amount
                                        <span class="label-hint">Required amount</span>
                                    </label>
                                    <input type="number" id="cheerAmount" value="100" min="1" oninput="updateFullPreview();">
                                </div>

                                <!-- Maximum Users -->
                                <div class="form-group form-group-compact">
                                    <label for="maxUsers">
                                        Maximum Users
                                        <span class="label-hint">Max around campfire</span>
                                    </label>
                                    <div style="display: flex; gap: 10px; align-items: flex-end;">
                                        <input type="number" id="maxUsers" value="20" min="1" max="50" oninput="updateFullPreview();" style="flex: 1;">
                                        <button class="button button-primary" onclick="saveJoinSettings()" style="padding: 6px 12px; font-size: 12px; white-space: nowrap;">
                                            SET
                                        </button>
                                    </div>
                                </div>
                            </div>

                            <hr style="border: none; border-top: 1px solid #333; margin: 20px 0;">

                            <!-- Restrictions (Two Columns) -->
                            <div class="form-group">
                                <label>
                                    Restrictions
                                    <span class="label-hint">Who can join the campfire</span>
                                </label>
                                <div style="display: flex; gap: 20px; margin-top: 8px;">
                                    <!-- Left Column: Subscriber Requirements -->
                                    <div style="flex: 1;">
                                        <div style="font-size: 12px; font-weight: 600; color: #aaa; margin-bottom: 8px;">Subscriber Requirements</div>
                                        <div style="display: flex; flex-direction: column; gap: 8px;">
                                            <div class="checkbox-group">
                                                <input type="checkbox" id="subscriberOnly" onchange="updateFullPreview();">
                                                <label for="subscriberOnly" style="margin: 0;">Any Subscriber (Tier 1, 2, or 3)</label>
                                            </div>
                                            <div class="checkbox-group">
                                                <input type="checkbox" id="subTier2Only" onchange="updateFullPreview();">
                                                <label for="subTier2Only" style="margin: 0;">Tier 2+ Subscribers Only</label>
                                            </div>
                                            <div class="checkbox-group">
                                                <input type="checkbox" id="subTier3Only" onchange="updateFullPreview();">
                                                <label for="subTier3Only" style="margin: 0;">Tier 3 Subscribers Only</label>
                                            </div>
                                        </div>
                                    </div>

                                    <!-- Right Column: Other Restrictions -->
                                    <div style="flex: 1;">
                                        <div style="font-size: 12px; font-weight: 600; color: #aaa; margin-bottom: 8px;">Other Restrictions</div>
                                        <div style="display: flex; flex-direction: column; gap: 8px;">
                                            <div class="checkbox-group">
                                                <input type="checkbox" id="vipOnly" onchange="updateFullPreview();">
                                                <label for="vipOnly" style="margin: 0;">VIP Only</label>
                                            </div>
                                            <div class="checkbox-group">
                                                <input type="checkbox" id="primeOnly" onchange="updateFullPreview();">
                                                <label for="primeOnly" style="margin: 0;">Prime/Turbo Only</label>
                                            </div>
                                            <div class="checkbox-group">
                                                <input type="checkbox" id="followersOnly" onchange="updateFullPreview();">
                                                <label for="followersOnly" style="margin: 0;">Followers Only</label>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                <span class="label-hint" style="margin-top: 8px; display: block;">
                                    Leave all unchecked to allow all viewers
                                </span>
                            </div>

                            <hr style="border: none; border-top: 1px solid #333; margin: 20px 0;">

                            <!-- Current Commands List -->
                            <div class="form-group">
                                <label>Available Commands</label>
                                <div style="background: #2a2a2a; padding: 15px; border-radius: 8px; font-size: 13px; line-height: 1.4;">
                                    <div style="margin-bottom: 10px;"><strong>Join Commands:</strong></div>
                                    <div id="joinCommandDisplay" style="color: #4caf50; margin-bottom: 8px;">‚Ä¢ <span id="currentJoinCommand">!join</span> - Join the campfire</div>
                                    <div style="color: #888;">‚Ä¢ !leave - Leave the campfire</div>
                                    <div id="alternativeCommandDisplay" style="color: #888;"><span id="alternativeJoinCommands"></span><span id="alternativeText"> - Alternative join command(s)</span></div>

                                    <div style="margin-top: 15px; margin-bottom: 10px;"><strong>Status Commands:</strong></div>
                                    <div id="afkCommandDisplay" style="color: #ff9800; margin-bottom: 8px;">‚Ä¢ <span id="currentAfkCommand">!afk</span> - Go AFK (clears on any chat)</div>
                                    <div id="lurkCommandDisplay" style="color: #9c27b0; margin-bottom: 8px;">‚Ä¢ <span id="currentLurkCommand">!lurk</span> - Go lurk mode (requires join command to return)</div>

                                    <div style="margin-top: 15px; margin-bottom: 10px;"><strong>Other Commands:</strong></div>
                                    <div style="color: #888;">‚Ä¢ !status - Show campfire status</div>
                                    <div style="color: #888;">‚Ä¢ !users - List current members</div>
                                    <div style="color: #888;">‚Ä¢ !kick [username] - Remove user (broadcaster only)</div>
                                </div>
                                <span class="label-hint" style="margin-top: 8px; display: block;">
                                    Commands are triggered in Twitch chat. Configure the join command above.
                                </span>
                            </div>
                        </div>
                    </div>

                    <!-- Sprite Settings Tab -->
                    <div id="spritesTab" class="settings-section">
                        <div class="form-section" style="max-height: 500px; overflow-y: auto; padding-right: 8px;">
                            <div class="form-group">
                                <label for="spriteMode">
                                    Sprite Mode
                                    <span class="label-hint">Choose how user sprites are displayed</span>
                                </label>
                                <select id="spriteMode" onchange="updateSpriteMode(); updateFullPreview();">
                                    <option value="circles">CIRCLES</option>
                                    <option value="circle">SHADOWS</option>
                                    <option value="rpg-characters">ADVENTURERS</option>
                                    <option value="pixel-morphs">MORPHS</option>
                                    <option value="custom">CUSTOM</option>
                                </select>
                            </div>

                            <!-- Circle Mode (SHADOWS) -->
                            <div id="circleSpriteSection" class="form-group" style="display: none;">
                                <label>
                                    SHADOWS Sprites
                                    <span class="label-hint">Preloaded pixel art circles (black shapes that will be colorized by Twitch username colors)</span>
                                </label>
                                <div style="background: #1a1a1a; border: 1px solid #333; border-radius: 6px; padding: 15px; margin-top: 10px;">
                                    <div style="color: #4caf50; font-size: 13px; margin-bottom: 8px;">‚úÖ Default sprites are preloaded with the installer</div>
                                    <div style="color: #888; font-size: 12px;">No upload needed - sprites are included automatically</div>
                                </div>
                                <div id="shadowSpritesList" class="sprite-list" style="margin-top: 10px; display: grid; grid-template-columns: repeat(auto-fill, minmax(60px, 1fr)); gap: 10px;">
                                    <span style="color: #888; font-size: 12px; grid-column: 1 / -1;">Loading default sprites...</span>
                                </div>
                            </div>

                            <!-- RPG Characters Mode (ADVENTURERS) -->
                            <div id="rpgSpriteSection" class="form-group" style="display: none;">
                                <label>
                                    ADVENTURERS Sprites
                                    <span class="label-hint">Preloaded RPG character sprites. Viewers can choose from these, or they'll be randomly assigned.</span>
                                </label>
                                <div style="background: #1a1a1a; border: 1px solid #333; border-radius: 6px; padding: 15px; margin-top: 10px;">
                                    <div style="color: #4caf50; font-size: 13px; margin-bottom: 8px;">‚úÖ Default sprites are preloaded with the installer</div>
                                    <div style="color: #888; font-size: 12px;">No upload needed - sprites are included automatically</div>
                                </div>
                                <div id="rpgSpritesList" class="sprite-list" style="margin-top: 10px; display: grid; grid-template-columns: repeat(auto-fill, minmax(60px, 1fr)); gap: 10px;">
                                    <span style="color: #888; font-size: 12px; grid-column: 1 / -1;">Loading default sprites...</span>
                                </div>
                            </div>

                            <!-- Pixel Morphs Mode (MORPHS) -->
                            <div id="morphSpriteSection" class="form-group" style="display: none;">
                                <label>
                                    MORPHS Sprites
                                    <span class="label-hint">Preloaded pixel art shapes (black shapes that will be colorized by Twitch username colors)</span>
                                </label>
                                <div style="background: #1a1a1a; border: 1px solid #333; border-radius: 6px; padding: 15px; margin-top: 10px;">
                                    <div style="color: #4caf50; font-size: 13px; margin-bottom: 8px;">‚úÖ Default sprites are preloaded with the installer</div>
                                    <div style="color: #888; font-size: 12px;">No upload needed - sprites are included automatically</div>
                                </div>
                                <div id="morphSpritesList" class="sprite-list" style="margin-top: 10px; display: grid; grid-template-columns: repeat(auto-fill, minmax(60px, 1fr)); gap: 10px;">
                                    <span style="color: #888; font-size: 12px; grid-column: 1 / -1;">Loading default sprites...</span>
                                </div>
                            </div>

                            <!-- Custom Mode -->
                            <div id="customSpriteSection" class="form-group" style="display: none;">
                                <label for="customSpriteUpload">
                                    Custom Sprite
                                    <span class="label-hint">Upload a custom sprite/GIF/image for users (or allow viewers to upload their own)</span>
                                </label>
                                <input type="file" id="customSpriteUpload" accept="image/*,.gif" onchange="handleCustomSpriteUpload(event)">
                                <div id="customSpritePreview" class="sprite-preview">
                                    <span style="color: #888; font-size: 12px;">No custom sprite uploaded</span>
                                </div>
                            </div>

                            <div class="form-group">
                                <label>
                                    Sprite Default Direction
                                    <span class="label-hint">Which direction is your sprite facing by default? This ensures the flip mechanics work correctly.</span>
                                </label>
                                <div style="display: flex; gap: 10px; align-items: center; margin-top: 8px;">
                                    <button type="button" id="spriteDirectionLeft" class="direction-button" onclick="setSpriteDirection('left')" style="flex: 1; padding: 12px; background: #1a1a1a; border: 2px solid #333; border-radius: 8px; cursor: pointer; font-size: 24px; transition: all 0.2s;">
                                        ‚Üê
                                    </button>
                                    <button type="button" id="spriteDirectionRight" class="direction-button" onclick="setSpriteDirection('right')" style="flex: 1; padding: 12px; background: #1a1a1a; border: 2px solid #333; border-radius: 8px; cursor: pointer; font-size: 24px; transition: all 0.2s;">
                                        ‚Üí
                                    </button>
                                </div>
                                <div id="spriteDirectionDisplay" style="margin-top: 8px; color: #888; font-size: 12px; text-align: center;">
                                    Default: Left
                                </div>
                            </div>

                            <!-- Status Icon Placement Section -->
                            <div class="form-group" style="border-top: 1px solid #333; padding-top: 20px; margin-top: 20px;">
                                <label>
                                    Status Icon Placement
                                    <span class="label-hint">Adjust the position of sleepy (üí§) and lurk (üëÅÔ∏è) icons on sprites</span>
                                </label>
                                <div style="display: flex; gap: 20px; margin-top: 15px;">
                                    <!-- Preview Area -->
                                    <div style="flex: 0 0 120px; display: flex; flex-direction: column; align-items: center;">
                                        <div id="statusIconPreview" style="width: 80px; height: 80px; background: #2a2a2a; border: 2px solid #444; border-radius: 8px; position: relative; display: flex; align-items: center; justify-content: center;">
                                            <div style="width: 50px; height: 50px; background: #666; border-radius: 50%;"></div>
                                            <div id="statusIconPreviewIcon" style="position: absolute; font-size: 16px; transition: all 0.2s;">üí§</div>
                                        </div>
                                        <span style="color: #888; font-size: 11px; margin-top: 8px;">Preview</span>
                                    </div>
                                    <!-- Controls -->
                                    <div style="flex: 1; display: flex; flex-direction: column; gap: 12px;">
                                        <div style="display: flex; align-items: center; gap: 10px;">
                                            <label style="min-width: 80px; font-size: 12px; color: #aaa;">Top Offset:</label>
                                            <input type="range" id="statusIconTop" min="-20" max="40" value="0" oninput="updateStatusIconPreview()" style="flex: 1;">
                                            <span id="statusIconTopValue" style="min-width: 40px; font-size: 12px; color: #888;">0px</span>
                                        </div>
                                        <div style="display: flex; align-items: center; gap: 10px;">
                                            <label style="min-width: 80px; font-size: 12px; color: #aaa;">Right Offset:</label>
                                            <input type="range" id="statusIconRight" min="-20" max="40" value="0" oninput="updateStatusIconPreview()" style="flex: 1;">
                                            <span id="statusIconRightValue" style="min-width: 40px; font-size: 12px; color: #888;">0px</span>
                                        </div>
                                        <div style="display: flex; gap: 10px; margin-top: 5px;">
                                            <button class="button button-secondary" onclick="resetStatusIconPosition()" style="padding: 6px 12px; font-size: 12px;">Reset</button>
                                            <button class="button button-primary" onclick="saveStatusIconPosition()" style="padding: 6px 12px; font-size: 12px;">Apply</button>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- Role-Based Sprites Section -->
                            <div class="form-group" style="border-top: 1px solid #333; padding-top: 20px; margin-top: 20px;">
                                <label style="display: flex; align-items: center; gap: 10px;">
                                    <input type="checkbox" id="enableRoleBasedSprites" onchange="toggleRoleBasedSprites()">
                                    <span>Enable Role-Based Sprites</span>
                                </label>
                                <span class="label-hint">Assign different sprites based on user roles (Broadcaster, Mod, VIP, Subscriber)</span>
                            </div>
                            
                            <div id="roleBasedSpritesSection" style="display: none; margin-top: 15px; padding: 15px; background: #1a1a1a; border: 1px solid #333; border-radius: 8px;">
                                <div style="margin-bottom: 15px; color: #888; font-size: 12px;">
                                    Configure sprites for each role. Higher priority roles (top) override lower ones.
                                </div>
                                
                                <!-- Broadcaster Role -->
                                <div class="role-sprite-row" style="display: flex; align-items: center; gap: 10px; margin-bottom: 12px; padding: 10px; background: #252525; border-radius: 6px;">
                                    <input type="checkbox" id="roleBroadcasterEnabled" checked onchange="updateRoleSpriteSettings()">
                                    <span style="min-width: 100px; color: #ff6b35; font-weight: bold;">üì∫ Broadcaster</span>
                                    <select id="roleBroadcasterSprite" onchange="updateRoleSpriteSettings()" style="flex: 1; padding: 6px; background: #2a2a2a; border: 1px solid #444; border-radius: 4px; color: #fff;">
                                        <option value="">Use Default</option>
                                    </select>
                                    <input type="file" id="roleBroadcasterUpload" accept="image/*,.gif" onchange="handleRoleSpriteUpload('broadcaster', event)" style="display: none;">
                                    <button class="button button-secondary" onclick="document.getElementById('roleBroadcasterUpload').click()" style="padding: 6px 12px; font-size: 12px;">üìÅ Upload</button>
                                </div>
                                
                                <!-- Moderator Role -->
                                <div class="role-sprite-row" style="display: flex; align-items: center; gap: 10px; margin-bottom: 12px; padding: 10px; background: #252525; border-radius: 6px;">
                                    <input type="checkbox" id="roleModeratorEnabled" checked onchange="updateRoleSpriteSettings()">
                                    <span style="min-width: 100px; color: #00ad03; font-weight: bold;">üó°Ô∏è Moderator</span>
                                    <select id="roleModeratorSprite" onchange="updateRoleSpriteSettings()" style="flex: 1; padding: 6px; background: #2a2a2a; border: 1px solid #444; border-radius: 4px; color: #fff;">
                                        <option value="">Use Default</option>
                                    </select>
                                    <input type="file" id="roleModeratorUpload" accept="image/*,.gif" onchange="handleRoleSpriteUpload('moderator', event)" style="display: none;">
                                    <button class="button button-secondary" onclick="document.getElementById('roleModeratorUpload').click()" style="padding: 6px 12px; font-size: 12px;">üìÅ Upload</button>
                                </div>
                                
                                <!-- VIP Role -->
                                <div class="role-sprite-row" style="display: flex; align-items: center; gap: 10px; margin-bottom: 12px; padding: 10px; background: #252525; border-radius: 6px;">
                                    <input type="checkbox" id="roleVipEnabled" checked onchange="updateRoleSpriteSettings()">
                                    <span style="min-width: 100px; color: #e005b9; font-weight: bold;">üíé VIP</span>
                                    <select id="roleVipSprite" onchange="updateRoleSpriteSettings()" style="flex: 1; padding: 6px; background: #2a2a2a; border: 1px solid #444; border-radius: 4px; color: #fff;">
                                        <option value="">Use Default</option>
                                    </select>
                                    <input type="file" id="roleVipUpload" accept="image/*,.gif" onchange="handleRoleSpriteUpload('vip', event)" style="display: none;">
                                    <button class="button button-secondary" onclick="document.getElementById('roleVipUpload').click()" style="padding: 6px 12px; font-size: 12px;">üìÅ Upload</button>
                                </div>
                                
                                <!-- Subscriber Role -->
                                <div class="role-sprite-row" style="display: flex; align-items: center; gap: 10px; margin-bottom: 12px; padding: 10px; background: #252525; border-radius: 6px;">
                                    <input type="checkbox" id="roleSubscriberEnabled" checked onchange="updateRoleSpriteSettings()">
                                    <span style="min-width: 100px; color: #9147ff; font-weight: bold;">‚≠ê Subscriber</span>
                                    <select id="roleSubscriberSprite" onchange="updateRoleSpriteSettings()" style="flex: 1; padding: 6px; background: #2a2a2a; border: 1px solid #444; border-radius: 4px; color: #fff;">
                                        <option value="">Use Default</option>
                                    </select>
                                    <input type="file" id="roleSubscriberUpload" accept="image/*,.gif" onchange="handleRoleSpriteUpload('subscriber', event)" style="display: none;">
                                    <button class="button button-secondary" onclick="document.getElementById('roleSubscriberUpload').click()" style="padding: 6px 12px; font-size: 12px;">üìÅ Upload</button>
                                </div>
                                
                                <!-- Regular Viewer (fallback) -->
                                <div class="role-sprite-row" style="display: flex; align-items: center; gap: 10px; padding: 10px; background: #252525; border-radius: 6px; opacity: 0.7;">
                                    <input type="checkbox" checked disabled>
                                    <span style="min-width: 100px; color: #888;">üë§ Regular</span>
                                    <span style="flex: 1; color: #666; font-size: 12px;">Uses the default sprite mode selected above</span>
                                </div>
                            </div>

                            <div class="form-group">
                                <label>
                                    Viewer Dashboard Link
                                    <span class="label-hint">Share this link with your viewers</span>
                                </label>
                                <div style="display: flex; gap: 10px; align-items: center;">
                                    <input type="text" id="viewerDashboardLink" readonly value="viewer-dashboard.html" style="flex: 1;">
                                    <button class="button button-secondary" onclick="copyViewerLink()" style="padding: 8px 16px; font-size: 13px;">Copy</button>
                                </div>
                            </div>

                        </div>
                        
                        <!-- User Activity States Section (moved from Audio tab) -->
                        <div class="form-section">
                            <div class="form-group">
                                <label>üëÅÔ∏è User Activity States</label>
                                <span class="label-hint">Show visual indicators based on user activity (SLEEPY users become STILL, AFK users move to outer ring)</span>
                            </div>
                            <div class="form-group">
                                <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 12px;">
                                    <input type="checkbox" id="userStatesEnabled" onchange="updateUserStateSetting('enabled', this.checked)">
                                    <label for="userStatesEnabled" style="margin: 0;">Enable User State Indicators</label>
                                </div>
                                <div style="margin-left: 20px;">
                                    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
                                        <span style="width: 140px;">üü¢ Active ‚Üí üíô Sleepy:</span>
                                        <input type="range" id="sleepyMinutes" min="1" max="30" value="5" onchange="updateUserStateSetting('sleepyMinutes', parseInt(this.value)); document.getElementById('sleepyMinutesValue').textContent = this.value + ' min'">
                                        <span id="sleepyMinutesValue">5 min</span>
                                    </div>
                                    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
                                        <span style="width: 140px;">üíô Sleepy ‚Üí üí§ AFK:</span>
                                        <input type="range" id="afkMinutes" min="5" max="60" value="15" onchange="updateUserStateSetting('afkMinutes', parseInt(this.value)); document.getElementById('afkMinutesValue').textContent = this.value + ' min'">
                                        <span id="afkMinutesValue">15 min</span>
                                    </div>
                                    <div style="display: flex; align-items: center; gap: 10px;">
                                        <span style="width: 140px;">üí§ AFK ‚Üí üëã Auto Leave:</span>
                                        <select id="autoLeaveMinutes" onchange="updateUserStateSetting('autoLeaveMinutes', parseInt(this.value))">
                                            <option value="0">Disabled</option>
                                            <option value="30">30 minutes</option>
                                            <option value="60">1 hour</option>
                                            <option value="90">1.5 hours</option>
                                            <option value="120">2 hours</option>
                                            <option value="180">3 hours</option>
                                            <option value="240">4 hours</option>
                                            <option value="360">6 hours</option>
                                            <option value="480">8 hours</option>
                                        </select>
                                    </div>
                                </div>
                                <div style="margin-top: 12px; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 4px;">
                                    <div style="font-size: 11px; color: #888;">
                                        <strong>State Indicators:</strong><br>
                                        üü° <strong>Joined</strong> - Yellow pulse when user first joins (3 pulses)<br>
                                        üü¢ <strong>Active</strong> - Green glow when user recently chatted<br>
                                        üíô <strong>Sleepy</strong> - Blue overlay, üí§ animation, STILL mode<br>
                                        üí§ <strong>AFK</strong> - Dimmed sprite, &lt;AFK&gt; badge, outer ring, STILL mode<br>
                                        üíôüí§ <strong>Sleepy+AFK</strong> - Blue dimmed sprite, üí§ animation, outer ring<br>
                                        üëÅÔ∏è <strong>Lurk</strong> - Purple overlay, eye icon, outer ring (manual via !lurk)
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Members Tab -->
                    <div id="membersTab" class="settings-section">
                        <div class="form-section">
                            <div class="info-box" style="margin-bottom: 20px; display: flex; align-items: center; justify-content: space-between;">
                                <div>
                                    <strong>üë• Campfire Members</strong>
                                    <p style="margin-top: 10px; font-size: 13px; opacity: 0.8;">
                                        Manage viewers around the campfire. Members persist across page refreshes.
                                    </p>
                                </div>
                                <button class="button button-secondary" onclick="refreshMembersList()" style="white-space: nowrap; margin-left: 10px;">üîÑ Refresh</button>
                            </div>
                            
                            <div id="membersList" style="display: grid; gap: 10px; max-height: 500px; overflow-y: auto; padding-right: 8px;">
                                <!-- Member list will be populated here -->
                                <div style="text-align: center; padding: 40px; color: #888;">
                                    <p>Loading members...</p>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Commands Tab -->
                    <div id="commandsTab" class="settings-section">
                        <div class="form-section" style="max-height: calc(100vh - 350px); overflow-y: auto; padding-right: 8px;">
                            <div class="form-group">
                                <label title="Configure chat commands that viewers can use to interact with the campfire widget">
                                    Commands Configuration
                                    <span class="label-hint">Enable/disable and customize commands and their responses</span>
                                </label>

                                <!-- Sub-tabs for command categories -->
                                <div class="command-sub-tabs" style="display: flex; flex-wrap: wrap; gap: 5px; margin-top: 15px; margin-bottom: 15px; border-bottom: 1px solid #3a3a3a; padding-bottom: 10px;">
                                    <button class="command-sub-tab active" onclick="switchCommandSubTab('state', this)" style="padding: 8px 12px; background: #667eea; border: none; border-radius: 4px 4px 0 0; color: #fff; cursor: pointer; font-size: 12px;" title="Commands that change user state (join, leave, afk, lurk, return)">
                                        üî¥ State
                                    </button>
                                    <button class="command-sub-tab" onclick="switchCommandSubTab('movement', this)" style="padding: 8px 12px; background: #333; border: none; border-radius: 4px 4px 0 0; color: #aaa; cursor: pointer; font-size: 12px;" title="Movement commands (cw, ccw, still, roam, wander)">
                                        üéÆ Movement
                                    </button>
                                    <button class="command-sub-tab" onclick="switchCommandSubTab('appearance', this)" style="padding: 8px 12px; background: #333; border: none; border-radius: 4px 4px 0 0; color: #aaa; cursor: pointer; font-size: 12px;" title="Appearance commands (sprite, color, next, back, random, reset)">
                                        üé® Appearance
                                    </button>
                                    <button class="command-sub-tab" onclick="switchCommandSubTab('animation', this)" style="padding: 8px 12px; background: #333; border: none; border-radius: 4px 4px 0 0; color: #aaa; cursor: pointer; font-size: 12px;" title="Animation commands (spin, dance, sparkle)">
                                        ‚ú® Animation
                                    </button>
                                    <button class="command-sub-tab" onclick="switchCommandSubTab('auto-states', this)" style="padding: 8px 12px; background: #333; border: none; border-radius: 4px 4px 0 0; color: #aaa; cursor: pointer; font-size: 12px;" title="Auto state change responses (sleepy, auto-afk, auto-return, auto-leave)">
                                        ‚è≥ Auto States
                                    </button>
                                    <button class="command-sub-tab" onclick="switchCommandSubTab('app', this)" style="padding: 8px 12px; background: #333; border: none; border-radius: 4px 4px 0 0; color: #aaa; cursor: pointer; font-size: 12px;" title="App-specific commands (!who and other special features)">
                                        üî• App
                                    </button>
                                    <button class="command-sub-tab" onclick="switchCommandSubTab('custom', this)" style="padding: 8px 12px; background: #333; border: none; border-radius: 4px 4px 0 0; color: #aaa; cursor: pointer; font-size: 12px;" title="Your custom commands">
                                        üí¨ Custom
                                    </button>
                                </div>

                                <!-- STATE COMMANDS Sub-tab Content -->
                                <div id="stateSubTab" class="command-sub-content" style="display: block;">
                                    <div style="margin-bottom: 20px;">
                                        <h3 style="color: #ff4444; font-size: 16px; margin-bottom: 10px; display: flex; align-items: center; gap: 8px;" title="Commands that change user state (join, leave, afk, lurk, return). These control campfire membership and status.">
                                            <span>üî¥ STATE COMMANDS</span>
                                            <span style="font-size: 11px; color: #888; font-weight: normal;">(Join/Leave/AFK/Lurk/Return)</span>
                                        </h3>
                                        <div id="stateCommandsList" style="display: grid; gap: 15px;">
                                            <!-- State commands will be populated here -->
                                        </div>
                                    </div>
                                </div>

                                <!-- MOVEMENT COMMANDS Sub-tab Content -->
                                <div id="movementSubTab" class="command-sub-content" style="display: none;">
                                    <div style="margin-bottom: 20px;">
                                        <h3 style="color: #ff6b35; font-size: 16px; margin-bottom: 10px; display: flex; align-items: center; gap: 8px;" title="Commands for sprite movement (rotation and position)">
                                            <span>üéÆ MOVEMENT COMMANDS</span>
                                            <span style="font-size: 11px; color: #888; font-weight: normal;">(CW/CCW/Still/Roam/Wander)</span>
                                        </h3>
                                        <div id="movementCommandsList" style="display: grid; gap: 15px;">
                                            <!-- Movement commands will be populated here -->
                                        </div>
                                    </div>
                                </div>

                                <!-- APPEARANCE COMMANDS Sub-tab Content -->
                                <div id="appearanceSubTab" class="command-sub-content" style="display: none;">
                                    <div style="margin-bottom: 20px;">
                                        <h3 style="color: #4caf50; font-size: 16px; margin-bottom: 10px; display: flex; align-items: center; gap: 8px;" title="Commands for changing sprite appearance">
                                            <span>üé® APPEARANCE COMMANDS</span>
                                            <span style="font-size: 11px; color: #888; font-weight: normal;">(Sprite/Color/Next/Back/Random/Reset)</span>
                                        </h3>
                                        <div id="appearanceCommandsList" style="display: grid; gap: 15px;">
                                            <!-- Appearance commands will be populated here -->
                                        </div>
                                    </div>
                                </div>

                                <!-- ANIMATION COMMANDS Sub-tab Content -->
                                <div id="animationSubTab" class="command-sub-content" style="display: none;">
                                    <div style="margin-bottom: 20px;">
                                        <h3 style="color: #e91e63; font-size: 16px; margin-bottom: 10px; display: flex; align-items: center; gap: 8px;" title="Animation commands for fun effects">
                                            <span>‚ú® ANIMATION COMMANDS</span>
                                            <span style="font-size: 11px; color: #888; font-weight: normal;">(Spin/Dance/Sparkle)</span>
                                        </h3>
                                        <div id="animationCommandsList" style="display: grid; gap: 15px;">
                                            <!-- Animation commands will be populated here -->
                                        </div>
                                    </div>
                                </div>

                                <!-- AUTO STATES Sub-tab Content -->
                                <div id="autoStatesSubTab" class="command-sub-content" style="display: none;">
                                    <div style="margin-bottom: 20px;">
                                        <h3 style="color: #ff9500; font-size: 16px; margin-bottom: 10px; display: flex; align-items: center; gap: 8px;" title="Auto state change responses triggered by timers (sleepy, afk, auto-leave)">
                                            <span>‚è≥ AUTO STATE RESPONSES</span>
                                            <span style="font-size: 11px; color: #888; font-weight: normal;">(Timer-based state changes)</span>
                                        </h3>
                                        <div id="autoStatesList" style="display: grid; gap: 15px;">
                                            <!-- Auto state responses will be populated here -->
                                        </div>
                                    </div>
                                </div>

                                <!-- APP COMMANDS Sub-tab Content -->
                                <div id="appSubTab" class="command-sub-content" style="display: none;">
                                    <div style="margin-bottom: 20px;">
                                        <h3 style="color: #ff6600; font-size: 16px; margin-bottom: 10px; display: flex; align-items: center; gap: 8px;" title="App-specific commands that provide special functionality">
                                            <span>üî• APP COMMANDS</span>
                                            <span style="font-size: 11px; color: #888; font-weight: normal;">(Special app features)</span>
                                        </h3>
                                        <div id="appCommandsList" style="display: grid; gap: 15px;">
                                            <!-- App commands will be populated here -->
                                        </div>
                                    </div>
                                </div>

                                <!-- CUSTOM COMMANDS Sub-tab Content -->
                                <div id="customSubTab" class="command-sub-content" style="display: none;">
                                    <div style="margin-bottom: 20px;">
                                        <h3 style="color: #9146ff; font-size: 16px; margin-bottom: 10px; display: flex; align-items: center; gap: 8px;" title="Create your own custom commands with custom responses. Great for fun interactions with your community!">
                                            <span>üí¨ CUSTOM COMMANDS</span>
                                            <span style="font-size: 11px; color: #888; font-weight: normal;">(Your custom commands)</span>
                                        </h3>
                                        <div style="margin-bottom: 15px;">
                                            <button class="button button-primary" onclick="addBotMessage()" style="padding: 10px 20px; font-size: 14px; white-space: nowrap;" title="Create a new custom command with your own trigger word and response message">
                                                ‚ûï Add Custom Command
                                            </button>
                                        </div>
                                        <div id="customBotMessagesList" style="display: grid; gap: 15px;">
                                            <!-- Custom bot messages will be populated here -->
                                        </div>
                                        <div id="noCustomMessages" style="display: none; text-align: center; padding: 20px; color: #888; background: #1f1f1f; border-radius: 6px; border: 1px dashed #3a3a3a;">
                                            No custom commands yet. Click "Add Custom Command" to create one!
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Code Tab -->
                    <div id="codeTab" class="settings-section">
                        <div class="form-section">
                            <div class="info-box" style="margin-bottom: 15px;">
                                <strong>üìù Instructions:</strong>
                                <ol style="margin-left: 20px; margin-top: 10px;">
                                    <li>Go to OBS and add a Browser Source, or use your streaming software's custom widget feature</li>
                                    <li>Click "Create New Widget" or edit existing</li>
                                    <li>Paste the HTML code below into the HTML section</li>
                                    <li>Save and add to your scene in OBS</li>
                                </ol>
                            </div>
                            <button class="button copy-button" onclick="copyCode()" style="margin-bottom: 15px;">üìã Copy Code</button>
                            <div class="code-section" style="margin-top: 5px;">
                                <h3>HTML Code (paste this entire code block):</h3>
                                <pre id="widgetCode"></pre>
                            </div>
                        </div>
                    </div>

                    <!-- Audio Tab -->
                    <div id="audioTab" class="settings-section">
                        <!-- Audio Output Device Section -->
                        <div class="form-section">
                            <div class="form-group">
                                <label>üîä Audio Output Device</label>
                                <span class="label-hint">Select which audio device to use for playback</span>
                                <div style="display: flex; gap: 10px; align-items: center; margin-top: 8px;">
                                    <select id="audioOutputDevice" onchange="setAudioOutputDevice(this.value)" style="flex: 1; padding: 8px; background: #2a2a2a; border: 1px solid #444; color: #fff; border-radius: 4px;">
                                        <option value="">Default System Output</option>
                                    </select>
                                    <button type="button" class="button button-secondary" onclick="refreshAudioDevices()" style="padding: 6px 12px; font-size: 12px;">üîÑ Refresh</button>
                                </div>
                            </div>
                        </div>
                        
                        <div class="form-section">
                            <div class="form-group">
                                <label>Audio Channels</label>
                                <span class="label-hint">Configure background music, ambience, and sound effects</span>
                            </div>
                            <!-- Music Channel -->
                            <div class="form-group">
                                <label>üéµ Music</label>
                                <div style="display: flex; gap: 10px; align-items: center; margin-top: 8px; flex-wrap: wrap;">
                                    <div class="audio-file-wrapper" style="display: flex; align-items: center; gap: 5px;">
                                        <input type="file" id="musicFile" accept="audio/*" style="display: none;" onchange="handleAudioFileSelect(this, 'musicFileName'); updateAudioSetting('music', 'file', this.files[0])">
                                        <button type="button" class="button button-secondary" onclick="document.getElementById('musicFile').click()" style="padding: 4px 10px; font-size: 12px;">üìÅ Choose</button>
                                        <span id="musicFileName" style="font-size: 11px; color: #888; max-width: 120px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">No file</span>
                                    </div>
                                    <input type="range" id="musicVolume" min="0" max="100" value="70" onchange="updateAudioSetting('music', 'volume', this.value); document.getElementById('musicVolumeValue').textContent = this.value + '%'">
                                    <span id="musicVolumeValue">70%</span>
                                    <input type="checkbox" id="musicLoop" checked onchange="updateAudioSetting('music', 'loop', this.checked)">
                                    <label for="musicLoop" style="margin: 0;">Loop</label>
                                    <input type="checkbox" id="musicAutoPlay" onchange="updateAudioSetting('music', 'autoPlay', this.checked)">
                                    <label for="musicAutoPlay" style="margin: 0;">Auto-play</label>
                                    <button id="musicPlayBtn" onclick="toggleAudioPlayback('music')" style="padding: 4px 8px;">‚ñ∂Ô∏è Play</button>
                                    <button onclick="previewAudio('music')" title="Preview">üîä</button>
                                </div>
                            </div>
                            <!-- Ambience Channel -->
                            <div class="form-group">
                                <label>üåø Ambience</label>
                                <div style="display: flex; gap: 10px; align-items: center; margin-top: 8px; flex-wrap: wrap;">
                                    <div class="audio-file-wrapper" style="display: flex; align-items: center; gap: 5px;">
                                        <input type="file" id="ambienceFile" accept="audio/*" style="display: none;" onchange="handleAudioFileSelect(this, 'ambienceFileName'); updateAudioSetting('ambience', 'file', this.files[0])">
                                        <button type="button" class="button button-secondary" onclick="document.getElementById('ambienceFile').click()" style="padding: 4px 10px; font-size: 12px;">üìÅ Choose</button>
                                        <span id="ambienceFileName" style="font-size: 11px; color: #888; max-width: 120px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">No file</span>
                                    </div>
                                    <input type="range" id="ambienceVolume" min="0" max="100" value="50" onchange="updateAudioSetting('ambience', 'volume', this.value); document.getElementById('ambienceVolumeValue').textContent = this.value + '%'">
                                    <span id="ambienceVolumeValue">50%</span>
                                    <input type="checkbox" id="ambienceLoop" checked onchange="updateAudioSetting('ambience', 'loop', this.checked)">
                                    <label for="ambienceLoop" style="margin: 0;">Loop</label>
                                    <input type="checkbox" id="ambienceAutoPlay" onchange="updateAudioSetting('ambience', 'autoPlay', this.checked)">
                                    <label for="ambienceAutoPlay" style="margin: 0;">Auto-play</label>
                                    <button id="ambiencePlayBtn" onclick="toggleAudioPlayback('ambience')" style="padding: 4px 8px;">‚ñ∂Ô∏è Play</button>
                                    <button onclick="previewAudio('ambience')" title="Preview">üîä</button>
                                </div>
                            </div>
                            <!-- User Sounds -->
                            <div class="form-group">
                                <label>üë§ User Sounds</label>
                                <div style="margin-top: 8px;">
                                    <!-- Join Sound -->
                                    <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 8px; flex-wrap: wrap;">
                                        <span style="width: 50px;">Join:</span>
                                        <div class="audio-file-wrapper" style="display: flex; align-items: center; gap: 5px;">
                                            <input type="file" id="joinSoundFile" accept="audio/*" style="display: none;" onchange="handleAudioFileSelect(this, 'joinFileName'); updateAudioSetting('userSounds', 'join', {file: this.files[0]?.name || '', gain: document.getElementById('joinGain').value})">
                                            <button type="button" class="button button-secondary" onclick="document.getElementById('joinSoundFile').click()" style="padding: 4px 10px; font-size: 12px;">üìÅ</button>
                                            <span id="joinFileName" style="font-size: 11px; color: #888; max-width: 80px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">No file</span>
                                        </div>
                                        <input type="range" id="joinGain" min="0" max="100" value="80" style="width: 80px;" onchange="updateAudioSetting('userSounds', 'join', {file: document.getElementById('joinSoundFile').files[0]?.name || '', gain: this.value}); document.getElementById('joinGainValue').textContent = this.value + '%'">
                                        <span id="joinGainValue" style="width: 35px;">80%</span>
                                        <button onclick="previewAudio('join')">‚ñ∂Ô∏è</button>
                                    </div>
                                    <!-- Leave Sound -->
                                    <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 8px; flex-wrap: wrap;">
                                        <span style="width: 50px;">Leave:</span>
                                        <div class="audio-file-wrapper" style="display: flex; align-items: center; gap: 5px;">
                                            <input type="file" id="leaveSoundFile" accept="audio/*" style="display: none;" onchange="handleAudioFileSelect(this, 'leaveFileName'); updateAudioSetting('userSounds', 'leave', {file: this.files[0]?.name || '', gain: document.getElementById('leaveGain').value})">
                                            <button type="button" class="button button-secondary" onclick="document.getElementById('leaveSoundFile').click()" style="padding: 4px 10px; font-size: 12px;">üìÅ</button>
                                            <span id="leaveFileName" style="font-size: 11px; color: #888; max-width: 80px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">No file</span>
                                        </div>
                                        <input type="range" id="leaveGain" min="0" max="100" value="60" style="width: 80px;" onchange="updateAudioSetting('userSounds', 'leave', {file: document.getElementById('leaveSoundFile').files[0]?.name || '', gain: this.value}); document.getElementById('leaveGainValue').textContent = this.value + '%'">
                                        <span id="leaveGainValue" style="width: 35px;">60%</span>
                                        <button onclick="previewAudio('leave')">‚ñ∂Ô∏è</button>
                                    </div>
                                    <!-- Speak Sound -->
                                    <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 8px; flex-wrap: wrap;">
                                        <span style="width: 50px;">Speak:</span>
                                        <div class="audio-file-wrapper" style="display: flex; align-items: center; gap: 5px;">
                                            <input type="file" id="speakSoundFile" accept="audio/*" style="display: none;" onchange="handleAudioFileSelect(this, 'speakFileName'); updateAudioSetting('userSounds', 'speak', {file: this.files[0]?.name || '', gain: document.getElementById('speakGain').value})">
                                            <button type="button" class="button button-secondary" onclick="document.getElementById('speakSoundFile').click()" style="padding: 4px 10px; font-size: 12px;">üìÅ</button>
                                            <span id="speakFileName" style="font-size: 11px; color: #888; max-width: 80px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">No file</span>
                                        </div>
                                        <input type="range" id="speakGain" min="0" max="100" value="40" style="width: 80px;" onchange="updateAudioSetting('userSounds', 'speak', {file: document.getElementById('speakSoundFile').files[0]?.name || '', gain: this.value}); document.getElementById('speakGainValue').textContent = this.value + '%'">
                                        <span id="speakGainValue" style="width: 35px;">40%</span>
                                        <button onclick="previewAudio('speak')">‚ñ∂Ô∏è</button>
                                    </div>
                                    <!-- AFK Sound -->
                                    <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 8px; flex-wrap: wrap;">
                                        <span style="width: 50px;">AFK:</span>
                                        <div class="audio-file-wrapper" style="display: flex; align-items: center; gap: 5px;">
                                            <input type="file" id="afkSoundFile" accept="audio/*" style="display: none;" onchange="handleAudioFileSelect(this, 'afkFileName'); updateAudioSetting('userSounds', 'afk', {file: this.files[0]?.name || '', gain: document.getElementById('afkGain').value})">
                                            <button type="button" class="button button-secondary" onclick="document.getElementById('afkSoundFile').click()" style="padding: 4px 10px; font-size: 12px;">üìÅ</button>
                                            <span id="afkFileName" style="font-size: 11px; color: #888; max-width: 80px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">No file</span>
                                        </div>
                                        <input type="range" id="afkGain" min="0" max="100" value="50" style="width: 80px;" onchange="updateAudioSetting('userSounds', 'afk', {file: document.getElementById('afkSoundFile').files[0]?.name || '', gain: this.value}); document.getElementById('afkGainValue').textContent = this.value + '%'">
                                        <span id="afkGainValue" style="width: 35px;">50%</span>
                                        <button onclick="previewAudio('afk')">‚ñ∂Ô∏è</button>
                                    </div>
                                    <!-- Lurk Sound -->
                                    <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
                                        <span style="width: 50px;">Lurk:</span>
                                        <div class="audio-file-wrapper" style="display: flex; align-items: center; gap: 5px;">
                                            <input type="file" id="lurkSoundFile" accept="audio/*" style="display: none;" onchange="handleAudioFileSelect(this, 'lurkFileName'); updateAudioSetting('userSounds', 'lurk', {file: this.files[0]?.name || '', gain: document.getElementById('lurkGain').value})">
                                            <button type="button" class="button button-secondary" onclick="document.getElementById('lurkSoundFile').click()" style="padding: 4px 10px; font-size: 12px;">üìÅ</button>
                                            <span id="lurkFileName" style="font-size: 11px; color: #888; max-width: 80px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">No file</span>
                                        </div>
                                        <input type="range" id="lurkGain" min="0" max="100" value="50" style="width: 80px;" onchange="updateAudioSetting('userSounds', 'lurk', {file: document.getElementById('lurkSoundFile').files[0]?.name || '', gain: this.value}); document.getElementById('lurkGainValue').textContent = this.value + '%'">
                                        <span id="lurkGainValue" style="width: 35px;">50%</span>
                                        <button onclick="previewAudio('lurk')">‚ñ∂Ô∏è</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                </div>

                </div>
            </div>

        </div>
    </div>

    <script>
        let widgetCode = '';
        let livePreviewEnabled = false;
        let livePreviewSyncBound = false;
        let widgetPreviewReady = false;
        function escapeHtml(str) { if (str == null) return ''; var s = String(str); return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#39;'); }
        function escapeJsQuoted(str) { if (str == null) return ''; return String(str).replace(/\\/g,'\\\\').replace(/'/g,"\\'").replace(/\r/g,'\\r').replace(/\n/g,'\\n'); }

        async function loadWidgetCode() {
            try {
                const response = await fetch('widget.html');
                widgetCode = await response.text();
            } catch (e) {
                console.error('Could not load widget.html.');
            }
        }

        function isDesktopApp() {
            return !!window.electronAPI;
        }

        function getLivePreviewDefault() {
            // Desktop app: Live Preview is the main widget view
            return true;
        }

        function loadLivePreviewSetting() {
            const stored = localStorage.getItem('livePreviewEnabled');
            if (stored === null) return getLivePreviewDefault();
            return stored === 'true';
        }

        function setLivePreviewEnabled(enabled) {
            livePreviewEnabled = !!enabled;
            localStorage.setItem('livePreviewEnabled', String(livePreviewEnabled));
            updateLivePreviewUI();
        }

        function updateLivePreviewUI() {
            const panel = document.getElementById('previewPanel');
            const btn = document.getElementById('toggleLivePreviewBtn');
            const iframe = document.getElementById('fullWidgetPreview');
            if (!panel || !btn || !iframe) {
                console.error('[Preview] Missing elements:', { panel: !!panel, btn: !!btn, iframe: !!iframe });
                return;
            }
            
            console.log('[Preview] updateLivePreviewUI called, livePreviewEnabled:', livePreviewEnabled, 'isDesktopApp:', isDesktopApp());
            
            if (isDesktopApp()) {
                // Force enable in desktop app
                livePreviewEnabled = true;
                btn.style.display = 'none';
                panel.classList.remove('collapsed');
                panel.style.display = 'flex';
                panel.style.visibility = 'visible';
                panel.style.opacity = '1';
                
                // Force iframe to load in desktop app
                const src = iframe.getAttribute('data-src') || 'widget.html';
                console.log('[Preview] Desktop app - Loading iframe with src:', src);
                iframe.src = src;
                attachLivePreviewSync();
            } else if (livePreviewEnabled) {
                panel.classList.remove('collapsed');
                panel.style.display = 'flex';
                btn.textContent = 'Hide Preview';
                if (!iframe.src || iframe.src === 'about:blank' || iframe.src === '') {
                    const src = iframe.getAttribute('data-src') || 'widget.html';
                    console.log('[Preview] Loading iframe with src:', src);
                    iframe.src = src;
                }
                attachLivePreviewSync();
            } else {
                panel.classList.add('collapsed');
                btn.textContent = 'Show Preview';
                iframe.src = 'about:blank';
            }
        }

        function toggleLivePreview() {
            if (isDesktopApp()) return;
            setLivePreviewEnabled(!livePreviewEnabled);
        }

        function attachLivePreviewSync() {
            if (livePreviewSyncBound) return;
            livePreviewSyncBound = true;
            
            const iframe = document.getElementById('fullWidgetPreview');
            if (!iframe) return;
            
            const syncPreview = async () => {
                if (!livePreviewEnabled || !window.electronAPI) return;
                try {
                    const widgetUsers = await window.electronAPI.getWidgetUsers();
                    if (iframe.contentWindow) {
                        iframe.contentWindow.postMessage({
                            type: 'syncFullState',
                            users: widgetUsers
                        }, '*');
                    }
                } catch (e) {
                    console.error('Error syncing preview:', e);
                }
            };
            
            iframe.addEventListener('load', () => {
                if (!livePreviewEnabled) return;
                widgetPreviewReady = true;
                syncPreview();
                
                if (window.electronAPI) {
                    window.electronAPI.onUserJoin(() => {
                        if (livePreviewEnabled) setTimeout(syncPreview, 100);
                    });
                    window.electronAPI.onUserLeave(() => {
                        if (livePreviewEnabled) setTimeout(syncPreview, 100);
                    });
                }
            });
        }

        async function waitForPreviewReady(maxWaitMs = 2000) {
            // In desktop app, widget runs in separate window, always ready
            return true;
        }

        function openOverlay(mode) {
            document.body.classList.add('overlay-open');
            const title = document.getElementById('overlayTitle');
            if (title) {
                title.textContent = mode === 'members' ? 'Members' : (mode === 'settings' ? 'Settings' : 'Dashboard');
            }
            
            if (mode === 'members') {
                switchTab('members');
            } else if (mode === 'settings') {
                switchSettingsTab('campfire');
            } else {
                switchSettingsTab('campfire');
            }
        }

        function closeOverlay() {
            document.body.classList.remove('overlay-open');
        }

        function updateOverlayStatus(connected) {
            const dot = document.getElementById('overlayStatusDot');
            const text = document.getElementById('overlayStatusText');
            if (dot) {
                dot.classList.toggle('connected', !!connected);
            }
            if (text) {
                text.textContent = connected ? 'Connected' : 'Disconnected';
            }
        }

        // Bottom-center status badge (separate dashboard window uses this)
        function updateBottomConnectionBadge(connected) {
            const dot = document.getElementById('statusIndicator');
            const text = document.getElementById('statusText');
            if (dot) dot.classList.toggle('connected', !!connected);
            if (text) text.textContent = connected ? 'Connected' : 'Disconnected';
        }

        function setupBottomConnectionIndicator() {
            if (!window.electronAPI) return;
            // Initial state from main
            window.electronAPI.getTwitchStatus()
                .then(s => updateBottomConnectionBadge(!!s?.connected))
                .catch(() => updateBottomConnectionBadge(false));
            // Real-time updates
            window.electronAPI.onTwitchConnected(() => updateBottomConnectionBadge(true));
            window.electronAPI.onTwitchDisconnected(() => updateBottomConnectionBadge(false));
            window.electronAPI.onTwitchError(() => updateBottomConnectionBadge(false));
            // Safety net: poll occasionally in case renderers miss an event
            setInterval(() => {
                window.electronAPI.getTwitchStatus()
                    .then(s => updateBottomConnectionBadge(!!s?.connected))
                    .catch(() => {});
            }, 5000);
        }
        
        function initDesktopMenuBar() {
            console.log('[Menu Bar] initDesktopMenuBar() called');
            
            const hasElectronAPI = typeof window.electronAPI !== 'undefined';
            const hasProcess = typeof window.process !== 'undefined';
            const userAgentHasElectron = navigator.userAgent.includes('Electron');
            const isDesktopApp = hasElectronAPI || hasProcess || userAgentHasElectron;
            
            console.log('[Menu Bar] Checking desktop app mode:', isDesktopApp);
            
            const menuBar = document.getElementById('desktopMenuBar');
            console.log('[Menu Bar] Menu bar element found:', !!menuBar);
            
            if (!menuBar) {
                console.error('[Menu Bar] Menu bar element not found!');
                return;
            }
            
            // Show menu bar if in Electron
            if (isDesktopApp) {
                menuBar.classList.add('desktop-app');
                console.log('[Menu Bar] Added desktop-app class');
                
                // DISABLE AUTO-HIDE FOR NOW - Keep menu bar always visible
                menuBar.classList.remove('hidden');
                menuBar.style.opacity = '1';
                menuBar.style.transform = 'translateX(-50%) translateY(0)';
                menuBar.style.display = 'flex';
                menuBar.style.visibility = 'visible';
                console.log('[Menu Bar] Menu bar shown and kept visible (auto-hide disabled)');
            }
            
            if (isDesktopApp && typeof window.electronAPI !== 'undefined') {
                const btnDashboard = document.getElementById('btnDashboard');
                const btnSettings = document.getElementById('btnSettings');
                const btnMembers = document.getElementById('btnMembers');
                const btnEnd = document.getElementById('btnEnd');
                const statusIndicator = document.getElementById('statusIndicator');
                const statusText = document.getElementById('statusText');
                
                if (btnDashboard) {
                    btnDashboard.addEventListener('click', () => {
                        openOverlay('dashboard');
                    });
                }
                
                if (btnSettings) {
                    btnSettings.addEventListener('click', () => {
                        openOverlay('settings');
                    });
                }
                
                if (btnMembers) {
                    btnMembers.addEventListener('click', () => {
                        openOverlay('members');
                    });
                }
                
                if (btnEnd) {
                    btnEnd.addEventListener('click', async () => {
                        if (confirm('Are you sure you want to shut down the widget and all servers?')) {
                            await window.electronAPI.shutdownApp();
                        }
                    });
                }
                
                if (window.electronAPI) {
                    window.electronAPI.onTwitchConnected(() => {
                        if (statusIndicator) statusIndicator.classList.add('connected');
                        if (statusText) statusText.textContent = 'Connected';
                    });
                    
                    window.electronAPI.onTwitchDisconnected(() => {
                        if (statusIndicator) statusIndicator.classList.remove('connected');
                        if (statusText) statusText.textContent = 'Disconnected';
                    });
                    
                    window.electronAPI.getTwitchStatus().then(status => {
                        if (status.connected) {
                            if (statusIndicator) statusIndicator.classList.add('connected');
                            if (statusText) statusText.textContent = 'Connected';
                        }
                    }).catch(err => {
                        console.error('[Menu Bar] Error getting Twitch status:', err);
                    });
                }
            }
        }
        
        function enableHoverControls() {
            if (!isDesktopApp()) return;
            let hideTimer = null;
            const show = () => {
                document.body.classList.add('show-controls');
                if (hideTimer) clearTimeout(hideTimer);
                hideTimer = setTimeout(() => {
                    document.body.classList.remove('show-controls');
                }, 2000);
            };
            document.addEventListener('mousemove', show);
            document.addEventListener('mouseenter', show);
            show();
        }

        function switchSettingsTab(tabName, clickedButton) {
            try {
                // Hide ALL other tab-content divs (members, code)
                document.querySelectorAll('.tab-content').forEach(content => {
                    content.classList.remove('active');
                });
                
                // Show settings tab content
                const settingsTab = document.getElementById('settingsTab');
                if (settingsTab) {
                    settingsTab.classList.add('active');
                }
                
                // Hide all settings sections
                document.querySelectorAll('.settings-section').forEach(section => {
                    section.classList.remove('active');
                });
                
                // Remove active class from all tabs
                document.querySelectorAll('.tab').forEach(tab => {
                    tab.classList.remove('active');
                });
                
                // Show selected section
                const section = document.getElementById(tabName + 'Tab');
                if (section) {
                    section.classList.add('active');
                } else {
                    console.error('Tab section not found:', tabName + 'Tab');
                }
                
                // Activate corresponding tab button
                if (clickedButton) {
                    clickedButton.classList.add('active');
                } else {
                    // Fallback: find tab by text content
                    const tabButtons = document.querySelectorAll('.tab');
                    tabButtons.forEach(tab => {
                        const tabText = tab.textContent.trim();
                        if ((tabName === 'campfire' && tabText.includes('Campfire')) ||
                            (tabName === 'glow' && tabText.includes('Glow')) ||
                            (tabName === 'size' && tabText.includes('Size')) ||
                            (tabName === 'circle' && tabText.includes('Perspective')) ||
                            (tabName === 'chat' && tabText.includes('Chat')) ||
                            (tabName === 'join' && tabText.includes('Join')) ||
                            (tabName === 'members' && tabText.includes('Members')) ||
                            (tabName === 'code' && tabText.includes('Code')) ||
                            (tabName === 'audio' && tabText.includes('Audio')) ||
                            (tabName === 'sprites' && tabText.includes('Sprites'))) {
                            tab.classList.add('active');
                        }
                    });
                }
                
                // Reset scroll so content starts at top (settings-panel is the scroll container when tab uses flex: 0 0 auto)
                if (settingsTab) settingsTab.scrollTop = 0;
                const sp = document.querySelector('.settings-panel');
                if (sp) sp.scrollTop = 0;
                
                // Handle tab-specific actions
                if (tabName === 'members') {
                    if (typeof loadDashboardMembers === 'function') loadDashboardMembers();
                } else if (tabName === 'commands') {
                    // Load the default State subtab when Commands tab is opened
                    loadStateCommands();
                } else if (tabName === 'chat') {
                    const log = document.getElementById('twitchChatLog');
                    if (log) log.scrollTop = log.scrollHeight;
                } else if (tabName === 'code') {
                    // Generate code when Code tab is opened
                    setTimeout(() => {
                        if (typeof generateCode === 'function') {
                            generateCode();
                        }
                    }, 100);
                }
                
                updateFullPreview();
            } catch (error) {
                console.error('Error switching tab:', error);
            }
        }

        // Switch between command sub-tabs (State, Movement, Appearance, Animation, Auto States, App, Custom)
        function switchCommandSubTab(subTabName, clickedButton) {
            try {
                // Hide all command sub-content
                document.querySelectorAll('.command-sub-content').forEach(content => {
                    content.style.display = 'none';
                });
                
                // Reset all sub-tab buttons
                document.querySelectorAll('.command-sub-tab').forEach(tab => {
                    tab.style.background = '#333';
                    tab.style.color = '#aaa';
                });
                
                // Show selected sub-content and load data if needed
                switch (subTabName) {
                    case 'state':
                        const stateTab = document.getElementById('stateSubTab');
                        if (stateTab) stateTab.style.display = 'block';
                        loadStateCommands();
                        break;
                    case 'movement':
                        const movementTab = document.getElementById('movementSubTab');
                        if (movementTab) movementTab.style.display = 'block';
                        loadMovementCommands();
                        break;
                    case 'appearance':
                        const appearanceTab = document.getElementById('appearanceSubTab');
                        if (appearanceTab) appearanceTab.style.display = 'block';
                        loadAppearanceCommands();
                        break;
                    case 'animation':
                        const animationTab = document.getElementById('animationSubTab');
                        if (animationTab) animationTab.style.display = 'block';
                        loadAnimationCommands();
                        break;
                    case 'auto-states':
                        const autoStatesTab = document.getElementById('autoStatesSubTab');
                        if (autoStatesTab) autoStatesTab.style.display = 'block';
                        loadAutoStateCommands();
                        break;
                    case 'app':
                        const appTab = document.getElementById('appSubTab');
                        if (appTab) appTab.style.display = 'block';
                        loadAppCommands();
                        break;
                    case 'custom':
                        const customTab = document.getElementById('customSubTab');
                        if (customTab) customTab.style.display = 'block';
                        loadCustomCommands();
                        break;
                }
                
                // Activate clicked button
                if (clickedButton) {
                    clickedButton.style.background = '#667eea';
                    clickedButton.style.color = '#fff';
                }
            } catch (error) {
                console.error('Error switching command sub-tab:', error);
            }
        }

        function toggleSection(header) {
            const content = header.nextElementSibling;
            const toggle = header.querySelector('.section-toggle');
            content.classList.toggle('collapsed');
            toggle.classList.toggle('collapsed');
        }

        function switchTab(tabName, element) {
            try {
                // Hide ALL tab-content divs (including settingsTab)
                document.querySelectorAll('.tab-content').forEach(content => {
                    content.classList.remove('active');
                });
                
                // Hide all settings sections (in case we're coming from a settings tab)
                document.querySelectorAll('.settings-section').forEach(section => {
                    section.classList.remove('active');
                });
                
                // Remove active class from all tabs
                document.querySelectorAll('.tab').forEach(tab => {
                    tab.classList.remove('active');
                });
                
                // Add active class to clicked tab
                if (element) {
                    element.classList.add('active');
                } else {
                    // Fallback: find tab by text content
                    document.querySelectorAll('.tab').forEach(tab => {
                        if ((tabName === 'members' && tab.textContent.includes('üë•')) ||
                            (tabName === 'code' && tab.textContent.includes('üìù'))) {
                            tab.classList.add('active');
                        }
                    });
                }
                
                // Show the target tab
                const targetTab = document.getElementById(tabName + 'Tab');
                if (targetTab) {
                    targetTab.classList.add('active');
                    targetTab.scrollTop = 0;
                    const sp = document.querySelector('.settings-panel');
                    if (sp) sp.scrollTop = 0;
                } else {
                    console.error('Tab not found:', tabName + 'Tab');
                }
                
                if (tabName === 'code') {
                    // Only generate code when Code tab is clicked, with error handling
                    setTimeout(() => {
                        try {
                            const codeTab = document.getElementById('codeTab');
                            if (codeTab && codeTab.classList.contains('active')) {
                                if (typeof generateCode === 'function') {
                                    generateCode();
                                } else {
                                    console.error('generateCode function not found');
                                    const codeArea = document.getElementById('widgetCode');
                                    if (codeArea) {
                                        codeArea.textContent = '<!-- Error: generateCode function not available -->';
                                    }
                                }
                            }
                        } catch (e) {
                            console.error('Error generating code:', e);
                            const codeArea = document.getElementById('widgetCode');
                            if (codeArea) {
                                codeArea.textContent = '<!-- Error generating code. Please refresh the page and try again. -->';
                            }
                        }
                    }, 100);
                } else if (tabName === 'members') {
                    // Load members when Members tab is clicked
                    try {
                        loadDashboardMembers();
                        // Set up refresh listener (only once)
                        if (window.electronAPI && window.electronAPI.onRefreshMembers && !window.membersRefreshListenerSet) {
                            window.electronAPI.onRefreshMembers(() => {
                                loadDashboardMembers();
                            });
                            window.membersRefreshListenerSet = true;
                        }
                        if (window.electronAPI && window.electronAPI.onSyncFullState && !window.syncFullStateListenerSet) {
                            window.electronAPI.onSyncFullState((users) => {
                                if (!livePreviewEnabled) return;
                                const iframe = document.getElementById('fullWidgetPreview');
                                if (iframe && iframe.contentWindow) {
                                    iframe.contentWindow.postMessage({
                                        type: 'syncFullState',
                                        users: Array.isArray(users) ? users : []
                                    }, '*');
                                }
                            });
                            window.syncFullStateListenerSet = true;
                        }
                    } catch (e) {
                        console.error('Error loading members:', e);
                        const membersList = document.getElementById('membersList');
                        if (membersList) {
                            membersList.innerHTML = '<div class="empty-state">Error loading members. Please try again.</div>';
                        }
                    }
                } else {
                    // Clear code area when switching away from Code tab to prevent text leakage
                    const codeArea = document.getElementById('widgetCode');
                    if (codeArea) {
                        codeArea.textContent = '';
                    }
                }
            } catch (error) {
                console.error('Error switching tab:', error);
            }
        }

        // Show all test users
        async function showAllTestUsers() {
            console.log('[Dashboard] showAllTestUsers called');
            if (!window.electronAPI) {
                alert('Not available in web version');
                return;
            }
            
            try {
                console.log('[Dashboard] Calling joinAllTestUsers...');
                const result = await window.electronAPI.joinAllTestUsers();
                console.log('[Dashboard] joinAllTestUsers result:', result);
                if (result && result.success === true) {
                    console.log('‚úÖ Test users joined successfully:', result.results);
                    // Small delay to ensure activeUsers is updated
                    await new Promise(resolve => setTimeout(resolve, 100));
                    // Refresh members list to update toggle states
                    if (typeof loadDashboardMembers === 'function') {
                        await loadDashboardMembers();
                    }
                    // Also refresh the members window if it exists
                    if (window.electronAPI && window.electronAPI.refreshMembers) {
                        await window.electronAPI.refreshMembers();
                    }
                } else {
                    console.error('Failed to join test users:', result);
                    alert('Failed to show test users. Check console for details.');
                }
            } catch (error) {
                console.error('Error showing test users:', error);
                alert('Error showing test users: ' + (error.message || error));
            }
        }
        
        // Hide all test users
        async function hideAllTestUsers() {
            console.log('[Dashboard] hideAllTestUsers called');
            if (!window.electronAPI) {
                alert('Not available in web version');
                return;
            }
            
            try {
                console.log('[Dashboard] Calling kickAllTestUsers...');
                const result = await window.electronAPI.kickAllTestUsers();
                console.log('[Dashboard] kickAllTestUsers result:', result);
                if (result && result.success === true) {
                    console.log('‚úÖ Test users removed successfully:', result.results);
                    // Small delay to ensure activeUsers and widget are updated
                    await new Promise(resolve => setTimeout(resolve, 500));
                    // Refresh members list to update toggle states
                    if (typeof loadDashboardMembers === 'function') {
                        await loadDashboardMembers();
                    }
                    // Also refresh the members window if it exists
                    if (window.electronAPI && window.electronAPI.refreshMembers) {
                        await window.electronAPI.refreshMembers();
                    }
                } else {
                    console.error('Failed to kick test users:', result);
                    alert('Failed to hide test users. Check console for details.');
                }
            } catch (error) {
                console.error('Error hiding test users:', error);
                alert('Error hiding test users: ' + (error.message || error));
            }
        }

        async function kickAllUsersConfirm() {
            if (!window.electronAPI || !window.electronAPI.kickAllUsers) {
                alert('Not available in web version');
                return;
            }
            showConfirmation('Kick All Users', 'Kick ALL (non-test) users from the campfire?', async () => {
                try {
                    await window.electronAPI.kickAllUsers();
                    if (typeof loadDashboardMembers === 'function') {
                        await new Promise(r => setTimeout(r, 150));
                        await loadDashboardMembers();
                    }
                } catch (e) {
                    console.error('Error kicking all users:', e);
                    alert('Failed to kick all users.');
                }
            }, 'Kick All', 'Cancel');
        }

        async function joinAllControlledConfirm() {
            if (!window.electronAPI || !window.electronAPI.joinAllUsers) {
                alert('Not available in web version');
                return;
            }
            showConfirmation('Join All Users (Controlled)', 'This will join all users from chat following the join rules (respecting user limits, cooldowns, badge requirements, etc.). Continue?', async () => {
                try {
                    await window.electronAPI.joinAllUsers({ mode: 'controlled' });
                    if (typeof loadDashboardMembers === 'function') {
                        await new Promise(r => setTimeout(r, 500));
                        await loadDashboardMembers();
                    }
                } catch (e) {
                    console.error('Error joining all users:', e);
                    alert('Failed to join all users.');
                }
            }, 'Confirm', 'Cancel');
        }

        async function joinAllChaosConfirm() {
            if (!window.electronAPI || !window.electronAPI.joinAllUsers) {
                alert('Not available in web version');
                return;
            }
            showConfirmation('Join All Users (Chaos)', 'This will join all users from chat overriding the join rules (ignores limits, cooldowns, and badge requirements). Continue?', async () => {
                try {
                    await window.electronAPI.joinAllUsers({ mode: 'chaos' });
                    if (typeof loadDashboardMembers === 'function') {
                        await new Promise(r => setTimeout(r, 500));
                        await loadDashboardMembers();
                    }
                } catch (e) {
                    console.error('Error joining all users:', e);
                    alert('Failed to join all users.');
                }
            }, 'Confirm', 'Cancel');
        }
        
        // Debounce updateFullPreview to prevent excessive calls while dragging sliders
        let previewUpdateTimeout = null;
        let dashboardInitializing = true; // Prevent updates during initialization

        function updateFullPreview() {
            // In desktop app with separate dashboard, preview iframe doesn't exist
            if (dashboardInitializing) return; // Skip during initialization to prevent widget restarts

            const settings = getSettings();
            localStorage.setItem('campfireWidgetSettings', JSON.stringify(settings));
            // Desktop app: also send to main (debounced) so the widget updates live
            if (window.electronAPI?.saveSettings) {
                if (previewUpdateTimeout) clearTimeout(previewUpdateTimeout);
                previewUpdateTimeout = setTimeout(() => {
                    try { window.electronAPI.saveSettings(settings); } catch (e) {}
                }, 50);
            }
        }

        function updateAngleDisplay() {
            const input = document.getElementById('circleAngle');
            const angle = input.value;
            document.getElementById('angleValue').textContent = angle + '¬∞';
            updateSliderBackground(input);
        }

        function updateCampfireYOffsetDisplay() {
            const input = document.getElementById('campfireYOffset');
            if (!input) return;
            const v = parseInt(input.value || 50, 10);
            // Map 0‚Äì100 ‚Üí -200px..+200px (50 = 0px)
            const px = (v - 50) * 4;
            const el = document.getElementById('campfireYOffsetValue');
            if (el) el.textContent = `${v} (${px >= 0 ? '+' : ''}${px}px)`;
            updateSliderBackground(input);
            updateFullPreview();
        }

        function updateGlowSizeDisplay() {
            const input = document.getElementById('glowSize');
            const size = input.value;
            document.getElementById('glowSizeValue').textContent = size + 'px';
            updateSliderBackground(input);
        }

        function updateGlowIntensityDisplay() {
            const input = document.getElementById('glowIntensity');
            const intensity = input.value;
            document.getElementById('glowIntensityValue').textContent = intensity + '%';
            updateSliderBackground(input);
        }

        function updateNameBubbleOffsetDisplay() {
            const input = document.getElementById('nameBubbleOffset');
            if (!input) return;
            const v = parseInt(input.value || 25, 10);
            const el = document.getElementById('nameBubbleOffsetValue');
            if (el) el.textContent = `${v}px`;
            updateSliderBackground(input);
            
            // Skip saving during initialization to prevent overwriting loaded settings
            if (dashboardInitializing) return;
            
            // Send update to widget via updateFullPreview (debounced)
            updateFullPreview();
        }
        
        function updateSliderBackground(input) {
            const value = (input.value - input.min) / (input.max - input.min) * 100;
            input.style.background = `linear-gradient(to right, #667eea 0%, #667eea ${value}%, #3a3a3a ${value}%, #3a3a3a 100%)`;
        }
        
        function initializeAllSliders() {
            document.querySelectorAll('input[type="range"]').forEach(slider => {
                updateSliderBackground(slider);
                slider.addEventListener('input', () => updateSliderBackground(slider));
            });
        }

        function updateShadowIntensityDisplay() {
            const intensity = document.getElementById('shadowIntensity').value;
            document.getElementById('shadowIntensityValue').textContent = intensity + '%';
        }

        function updateGlowSpreadDisplay() {
            const spread = document.getElementById('glowSpread').value;
            document.getElementById('glowSpreadValue').textContent = spread + '%';
        }

        function updateFlickerOpacityDisplay() {
            const input = document.getElementById('flickerOpacity');
            if (!input) return;
            const v = input.value;
            const el = document.getElementById('flickerOpacityValue');
            if (el) el.textContent = v + '%';
        }

        function updateFlickerSpreadDisplay() {
            const input = document.getElementById('flickerSpread');
            if (!input) return;
            const v = input.value;
            const el = document.getElementById('flickerSpreadValue');
            if (el) el.textContent = v + '%';
        }

        function updateFireSizeDisplay() {
            const size = document.getElementById('fireSize').value;
            document.getElementById('fireSizeValue').textContent = size + 'px';
            // Only save fireSize setting, not all settings
            const currentSettings = JSON.parse(localStorage.getItem('campfireWidgetSettings') || '{}');
            const newSize = parseInt(size);
            const oldSize = currentSettings.fireSize || 48;
            if (newSize !== oldSize) {
                currentSettings.fireSize = newSize;
                localStorage.setItem('campfireWidgetSettings', JSON.stringify(currentSettings));
            }
        }

        function updateSpriteSizeDisplay() {
            const size = document.getElementById('spriteSize').value;
            document.getElementById('spriteSizeValue').textContent = size + 'px';
            // Only save spriteSize setting, not all settings
            const currentSettings = JSON.parse(localStorage.getItem('campfireWidgetSettings') || '{}');
            const newSize = parseInt(size);
            const oldSize = currentSettings.spriteSize || 40;
            if (newSize !== oldSize) {
                currentSettings.spriteSize = newSize;
                localStorage.setItem('campfireWidgetSettings', JSON.stringify(currentSettings));
            }
        }

        function updateChatBubbleSizeDisplay() {
            const size = document.getElementById('chatBubbleSize').value;
            document.getElementById('chatBubbleSizeValue').textContent = size + 'px';
            // Only save chatBubbleSize setting, not all settings
            const currentSettings = JSON.parse(localStorage.getItem('campfireWidgetSettings') || '{}');
            const newSize = parseInt(size);
            const oldSize = currentSettings.chatBubbleSize || 11;
            if (newSize !== oldSize) {
                currentSettings.chatBubbleSize = newSize;
                localStorage.setItem('campfireWidgetSettings', JSON.stringify(currentSettings));
                // Dispatch event for same-window updates (Quick Settings overlay)
                window.dispatchEvent(new CustomEvent('campfireSettingsUpdate', { detail: { chatBubbleSize: newSize } }));
                // Also send to main process for cross-window updates (widget)
                // Send the full merged settings to avoid partial update issues
                if (window.electronAPI?.saveSettings) {
                    try {
                        window.electronAPI.saveSettings(currentSettings);
                    } catch (e) {
                        console.warn('Failed to save settings via electronAPI:', e);
                    }
                }
            }
        }

        function updateChatBubbleDurationDisplay() {
            const input = document.getElementById('chatBubbleDuration');
            if (!input) return;
            const duration = parseInt(input.value || 3, 10);
            const el = document.getElementById('chatBubbleDurationValue');
            if (el) el.textContent = duration + 's';
            updateSliderBackground(input);
            
            // Skip saving during initialization
            if (dashboardInitializing) return;
            
            // Send update to widget via updateFullPreview (debounced)
            updateFullPreview();
        }

        // Flag to prevent infinite loops when syncing dropdowns
        let _syncingSpriteMode = false;
        
        function updateSpriteMode(skipSave = false) {
            const mode = document.getElementById('spriteMode').value;
            
            // Hide all sections
            document.getElementById('circleSpriteSection').style.display = 'none';
            document.getElementById('rpgSpriteSection').style.display = 'none';
            document.getElementById('morphSpriteSection').style.display = 'none';
            document.getElementById('customSpriteSection').style.display = 'none';
            
            // Show relevant section
            if (mode === 'circles') {
                // Circles mode: no section needed (uses simple colored circles)
                // All sections remain hidden
            } else if (mode === 'circle') {
                document.getElementById('circleSpriteSection').style.display = 'block';
                loadSpriteList('shadow');
            } else if (mode === 'rpg-characters') {
                document.getElementById('rpgSpriteSection').style.display = 'block';
                loadSpriteList('rpg');
            } else if (mode === 'pixel-morphs') {
                document.getElementById('morphSpriteSection').style.display = 'block';
                loadSpriteList('morph');
            } else if (mode === 'custom') {
                document.getElementById('customSpriteSection').style.display = 'block';
            }
            
            // Restore direction for this sprite mode
            const saved = JSON.parse(localStorage.getItem('campfireWidgetSettings') || '{}');
            const directions = saved.spriteDefaultDirections || {};
            const modeDirection = directions[mode] || saved.spriteDefaultDirection || 'left';
            setSpriteDirection(modeDirection, false); // Don't save on mode switch

            // Set appropriate defaults for View settings based on sprite mode
            // Skip this when loading settings (skipSave=true) to preserve loaded values
            if (!skipSave) {
                const nameBubbleOffsetEl = document.getElementById('nameBubbleOffset');
                if (nameBubbleOffsetEl) {
                    // RPG characters need much lower positioning (below sprite)
                    const defaultOffset = (mode === 'rpg-characters') ? 35 : -25;
                    // Only update if no custom setting exists for this mode
                    const saved = JSON.parse(localStorage.getItem('campfireWidgetSettings') || '{}');
                    const nameBubbleOffsets = saved.nameBubbleOffsets || {};
                    if (nameBubbleOffsets[mode] === undefined) {
                        nameBubbleOffsetEl.value = defaultOffset;
                        updateNameBubbleOffsetDisplay();
                    }
                }
            }
            
            // Only save if not called programmatically (skipSave flag)
            if (!skipSave && !_syncingSpriteMode) {
                _syncingSpriteMode = true;
                try {
                    // Save to localStorage and dispatch event to sync with Quick Settings
                    const settings = getSettings();
                    localStorage.setItem('campfireWidgetSettings', JSON.stringify(settings));
                    window.dispatchEvent(new CustomEvent('campfireSettingsUpdate', { detail: settings }));
                } finally {
                    _syncingSpriteMode = false;
                }
            }
        }
        
        // Load and display sprite lists
        function loadSpriteList(type) {
            const listKey = `${type}SpritesList`;
            const container = document.getElementById(listKey);
            if (!container) return;
            
            const sprites = JSON.parse(localStorage.getItem(`${type}Sprites`) || '[]');
            
            if (sprites.length === 0) {
                container.innerHTML = '<span style="color: #888; font-size: 12px; grid-column: 1 / -1;">No sprites uploaded</span>';
                return;
            }
            
            container.innerHTML = sprites.map((sprite, index) => `
                <div style="position: relative; border: 2px solid #333; border-radius: 4px; overflow: hidden;">
                    <img src="${sprite.data}" style="width: 100%; height: 60px; object-fit: contain; background: #1a1a1a;" alt="${sprite.name}">
                    <button onclick="removeSprite('${type}', ${index})" style="position: absolute; top: 2px; right: 2px; background: rgba(255,0,0,0.8); color: white; border: none; border-radius: 3px; width: 20px; height: 20px; cursor: pointer; font-size: 12px;">√ó</button>
                </div>
            `).join('');
        }
        
        // Handle sprite uploads (multiple files)
        function handleCircleSpriteUpload(event) {
            handleMultiSpriteUpload(event, 'shadow');
        }
        
        function handleRpgSpriteUpload(event) {
            handleMultiSpriteUpload(event, 'rpg');
        }
        
        function handleMorphSpriteUpload(event) {
            handleMultiSpriteUpload(event, 'morph');
        }
        
        function handleMultiSpriteUpload(event, type) {
            const files = Array.from(event.target.files);
            if (files.length === 0) return;
            
            const sprites = JSON.parse(localStorage.getItem(`${type}Sprites`) || '[]');
            let loaded = 0;
            
            files.forEach((file, index) => {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const base64 = e.target.result;
                    sprites.push({
                        name: file.name,
                        data: base64,
                        size: file.size
                    });
                    loaded++;
                    
                    if (loaded === files.length) {
                        localStorage.setItem(`${type}Sprites`, JSON.stringify(sprites));
                        loadSpriteList(type);
                        updateFullPreview();
                        event.target.value = ''; // Clear input
                    }
                };
                reader.readAsDataURL(file);
            });
        }
        
        function removeSprite(type, index) {
            const sprites = JSON.parse(localStorage.getItem(`${type}Sprites`) || '[]');
            sprites.splice(index, 1);
            localStorage.setItem(`${type}Sprites`, JSON.stringify(sprites));
            loadSpriteList(type);
            updateFullPreview();
        }
        
        // Load RPG sprites from the server folder
        async function loadRpgSpritesFromFolder() {
            // Check if we're in Electron or web server
            const isElectron = !!window.electronAPI;
            const isFileProtocol = window.location.protocol === 'file:';
            
            // Skip only if file:// AND not Electron
            if (isFileProtocol && !isElectron) {
                console.log('Skipping sprite loading - dashboard opened as file:// (use http://localhost:3000/dashboard.html or Electron app)');
                return;
            }
            
            console.log('üîÑ Loading RPG sprites...', isElectron ? '(Electron mode)' : '(Web mode)');
            
            // Check if RPG sprites are already loaded (but allow reload if count doesn't match)
            const existingSprites = JSON.parse(localStorage.getItem('rpgSprites') || '[]');
            const expectedCount = 20; // We expect 20 RPG sprites
            if (existingSprites.length === expectedCount) {
                console.log(`‚úÖ RPG sprites already loaded: ${existingSprites.length} sprites`);
                return;
            } else if (existingSprites.length > 0) {
                console.log(`Reloading RPG sprites (found ${existingSprites.length}, expected ${expectedCount})`);
            }
            
            // List of RPG character files found in the folder (updated with normalized sprites)
            const rpgCharacterFiles = [
                'Archer.gif',
                'Armored Axeman.gif',
                'Armored Orc.gif',
                'Armored Skeleton.gif',
                'Elite Orc.gif',
                'Greatsword Skeleton.gif',
                'Knight.gif',
                'Knight Templar.gif',
                'Lancer.gif',
                'Orc.gif',
                'Orc rider.gif',
                'Priest.gif',
                'Skeleton.gif',
                'Skeleton Archer.gif',
                'Slime.gif',
                'Soldier.gif',
                'Swordsman.gif',
                'Werebear.gif',
                'Werewolf.gif',
                'Wizard.gif'
            ];
            
            console.log(`Loading ${rpgCharacterFiles.length} RPG sprites from server...`);
            
            const loadedSprites = [];
            let loadedCount = 0;
            
            // Load each sprite file
            for (const filename of rpgCharacterFiles) {
                try {
                    // URL encode the filename to handle spaces
                    const encodedFilename = encodeURIComponent(filename);
                    // Use appropriate path based on environment
                    // In Electron (file://), use relative path. In web server, use absolute path.
                    const spriteUrl = isElectron 
                        ? `sprites/defaults/rpg-characters/${encodedFilename}`
                        : `/sprites/defaults/rpg-characters/${encodedFilename}`;
                    const response = await fetch(spriteUrl);
                    if (response.ok) {
                        const blob = await response.blob();
                        const reader = new FileReader();
                        
                        await new Promise((resolve, reject) => {
                            reader.onload = (e) => {
                                const base64 = e.target.result;
                                // Clean up filename to get sprite name (remove .gif extension)
                                const spriteName = filename.replace('.gif', '').trim();
                                loadedSprites.push({
                                    name: spriteName,
                                    filename: filename,
                                    data: base64,
                                    size: blob.size
                                });
                                loadedCount++;
                                resolve();
                            };
                            reader.onerror = reject;
                            reader.readAsDataURL(blob);
                        });
                    } else {
                        console.warn(`‚ùå Could not load ${filename}: HTTP ${response.status} - ${response.statusText}`);
                        console.warn(`   Attempted URL: ${spriteUrl}`);
                        console.warn(`   Full URL: ${window.location.origin}${spriteUrl}`);
                    }
                } catch (error) {
                    console.error(`‚ùå Error loading ${filename}:`, error);
                    console.error(`   Attempted URL: ${spriteUrl}`);
                    console.error(`   Full URL: ${window.location.origin}${spriteUrl}`);
                }
            }
            
            if (loadedSprites.length > 0) {
                localStorage.setItem('rpgSprites', JSON.stringify(loadedSprites));
                console.log(`‚úÖ Loaded ${loadedSprites.length} RPG sprites from folder`);
                
                // Update the sprite list if RPG mode is active
                const currentMode = document.getElementById('spriteMode')?.value;
                if (currentMode === 'rpg-characters') {
                    loadSpriteList('rpg');
                }
            } else {
                console.warn('No RPG sprites could be loaded from server');
            }
        }

        async function loadShadowSpritesFromFolder() {
            // Check if we're in Electron or web server
            const isElectron = !!window.electronAPI;
            const isFileProtocol = window.location.protocol === 'file:';
            
            // Skip only if file:// AND not Electron
            if (isFileProtocol && !isElectron) {
                console.log('Skipping sprite loading - dashboard opened as file:// (use http://localhost:3000/dashboard.html or Electron app)');
                return;
            }
            
            console.log('üîÑ Loading shadow sprites...', isElectron ? '(Electron mode)' : '(Web mode)');
            
            // Check if shadow sprites are already loaded
            const existingSprites = JSON.parse(localStorage.getItem('shadowSprites') || '[]');
            if (existingSprites.length > 0) {
                console.log(`‚úÖ Shadow sprites already loaded: ${existingSprites.length} sprites`);
                return;
            }
            
            // Try to load GIF files from the shadows folder
            const shadowFiles = [
                '3dgifmaker92871.gif'
            ];
            
            console.log(`Loading shadow sprites from server...`);
            
            const loadedSprites = [];
            
            // Load each shadow GIF file
            for (const filename of shadowFiles) {
                try {
                    const encodedFilename = encodeURIComponent(filename);
                    // Use appropriate path based on environment
                    const spriteUrl = isElectron
                        ? `sprites/defaults/shadows/${encodedFilename}`
                        : `/sprites/defaults/shadows/${encodedFilename}`;
                    const response = await fetch(spriteUrl);
                    if (response.ok) {
                        const blob = await response.blob();
                        const reader = new FileReader();
                        
                        await new Promise((resolve, reject) => {
                            reader.onload = (e) => {
                                const base64 = e.target.result;
                                const spriteName = filename.replace('.gif', '').trim();
                                loadedSprites.push({
                                    name: spriteName,
                                    filename: filename,
                                    data: base64,
                                    size: blob.size
                                });
                                resolve();
                            };
                            reader.onerror = reject;
                            reader.readAsDataURL(blob);
                        });
                    } else {
                        console.warn(`‚ùå Could not load ${filename}: HTTP ${response.status} - ${response.statusText}`);
                        console.warn(`   Attempted URL: ${spriteUrl}`);
                        console.warn(`   Full URL: ${window.location.origin}${spriteUrl}`);
                    }
                } catch (error) {
                    console.error(`‚ùå Error loading ${filename}:`, error);
                    console.error(`   Attempted URL: ${spriteUrl}`);
                    console.error(`   Full URL: ${window.location.origin}${spriteUrl}`);
                }
            }
            
            if (loadedSprites.length > 0) {
                localStorage.setItem('shadowSprites', JSON.stringify(loadedSprites));
                console.log(`‚úÖ Loaded ${loadedSprites.length} shadow sprites from folder`);
                
                // Update the sprite list if circle mode is active
                const currentMode = document.getElementById('spriteMode')?.value;
                if (currentMode === 'circle') {
                    loadSpriteList('shadow');
                }
            } else {
                console.log('No shadow GIFs found, will use SVG circle fallback');
            }
        }

        async function loadMorphSpritesFromFolder() {
            // Check if we're in Electron or web server
            const isElectron = !!window.electronAPI;
            const isFileProtocol = window.location.protocol === 'file:';
            
            // Skip only if file:// AND not Electron
            if (isFileProtocol && !isElectron) {
                console.log('Skipping sprite loading - dashboard opened as file:// (use http://localhost:3000/dashboard.html or Electron app)');
                return;
            }
            
            console.log('üîÑ Loading pixel morph sprites...', isElectron ? '(Electron mode)' : '(Web mode)');
            
            // Check if morph sprites are already loaded (but allow reload if count doesn't match)
            const existingSprites = JSON.parse(localStorage.getItem('morphSprites') || '[]');
            const expectedCount = 10; // We expect 10 pixel morph sprites
            if (existingSprites.length === expectedCount) {
                console.log(`‚úÖ Pixel morph sprites already loaded: ${existingSprites.length} sprites`);
                return;
            } else if (existingSprites.length > 0) {
                console.log(`Reloading pixel morph sprites (found ${existingSprites.length}, expected ${expectedCount})`);
            }
            
            // List of pixel morph files found in the folder
            const morphFiles = [
                'pixelmorph_blue.gif',
                'pixelmorph_brown.gif',
                'pixelmorph_gray.gif',
                'pixelmorph_green.gif',
                'pixelmorph_lavender.gif',
                'pixelmorph_orange.gif',
                'pixelmorph_purple.gif',
                'pixelmorph_teal.gif',
                'pixelmorph_white.gif',
                'pixelmorph_yellow.gif'
            ];
            
            console.log(`Loading ${morphFiles.length} pixel morph sprites from server...`);
            
            const loadedSprites = [];
            
            // Load each sprite file
            for (const filename of morphFiles) {
                try {
                    const encodedFilename = encodeURIComponent(filename);
                    // Use appropriate path based on environment
                    const spriteUrl = isElectron
                        ? `sprites/defaults/pixel-morphs/${encodedFilename}`
                        : `/sprites/defaults/pixel-morphs/${encodedFilename}`;
                    const response = await fetch(spriteUrl);
                    if (response.ok) {
                        const blob = await response.blob();
                        const reader = new FileReader();
                        
                        await new Promise((resolve, reject) => {
                            reader.onload = (e) => {
                                const base64 = e.target.result;
                                // Clean up filename to get sprite name (remove .gif extension and pixelmorph_ prefix)
                                const spriteName = filename.replace('pixelmorph_', '').replace('.gif', '').trim();
                                loadedSprites.push({
                                    name: spriteName.charAt(0).toUpperCase() + spriteName.slice(1), // Capitalize first letter
                                    filename: filename,
                                    data: base64,
                                    size: blob.size
                                });
                                resolve();
                            };
                            reader.onerror = reject;
                            reader.readAsDataURL(blob);
                        });
                    } else {
                        console.warn(`‚ùå Could not load ${filename}: HTTP ${response.status} - ${response.statusText}`);
                        console.warn(`   Attempted URL: ${spriteUrl}`);
                        console.warn(`   Full URL: ${window.location.origin}${spriteUrl}`);
                    }
                } catch (error) {
                    console.error(`‚ùå Error loading ${filename}:`, error);
                    console.error(`   Attempted URL: ${spriteUrl}`);
                    console.error(`   Full URL: ${window.location.origin}${spriteUrl}`);
                }
            }
            
            if (loadedSprites.length > 0) {
                localStorage.setItem('morphSprites', JSON.stringify(loadedSprites));
                console.log(`‚úÖ Loaded ${loadedSprites.length} pixel morph sprites from folder`);
                
                // Update the sprite list if pixel morph mode is active
                const currentMode = document.getElementById('spriteMode')?.value;
                if (currentMode === 'pixel-morphs') {
                    loadSpriteList('morph');
                }
            } else {
                console.warn('No pixel morph sprites could be loaded from server');
            }
        }

        function clearCampfireUpload() {
            if (confirm('Are you sure you want to clear the uploaded campfire graphic?')) {
                localStorage.removeItem('campfireGraphicData');
                const uploadInput = document.getElementById('campfireUpload');
                if (uploadInput) {
                    uploadInput.value = '';
                }
                const preview = document.getElementById('campfirePreview');
                if (preview) {
                    preview.innerHTML = '<span style="color: #888; font-size: 12px;">No campfire graphic uploaded</span>';
                }
                updateFullPreview();
            }
        }

        function clearAllGraphics() {
            if (confirm('This will clear ALL uploaded graphics (campfire, sprites). This may fix dashboard issues. Continue?')) {
                localStorage.removeItem('campfireGraphicData');
                localStorage.removeItem('defaultSpriteData');
                localStorage.removeItem('customSpriteData');
                
                // Reset file inputs
                const campfireUpload = document.getElementById('campfireUpload');
                const defaultSpriteUpload = document.getElementById('defaultSpriteUpload');
                const customSpriteUpload = document.getElementById('customSpriteUpload');
                if (campfireUpload) campfireUpload.value = '';
                if (defaultSpriteUpload) defaultSpriteUpload.value = '';
                if (customSpriteUpload) customSpriteUpload.value = '';
                
                // Reset previews
                const campfirePreview = document.getElementById('campfirePreview');
                const defaultSpritePreview = document.getElementById('defaultSpritePreview');
                const customSpritePreview = document.getElementById('customSpritePreview');
                if (campfirePreview) campfirePreview.innerHTML = '<span style="color: #888; font-size: 12px;">No campfire graphic uploaded</span>';
                if (defaultSpritePreview) defaultSpritePreview.innerHTML = '<span style="color: #888; font-size: 12px;">No sprite uploaded</span>';
                if (customSpritePreview) customSpritePreview.innerHTML = '<span style="color: #888; font-size: 12px;">No sprite uploaded</span>';
                
                alert('‚úÖ All graphics cleared! Please refresh the page.');
                location.reload();
            }
        }

        function clearAllDataAndReload() {
            if (confirm('This will clear ALL data (settings, graphics, everything) and reload the page. This should fix any dashboard issues. Continue?')) {
                try {
                    localStorage.clear();
                    alert('‚úÖ All data cleared! Reloading page...');
                    location.reload();
                } catch (e) {
                    alert('Error clearing data: ' + e.message + '\n\nPlease manually clear your browser cache and localStorage.');
                }
            }
        }

        function setCampfireMethod(method) {
            const btnUrl = document.getElementById('btnMethodUrl');
            const btnUpload = document.getElementById('btnMethodUpload');
            const urlSection = document.getElementById('campfireUrlSection');
            const uploadSection = document.getElementById('campfireUploadSection');
            const urlStatus = document.getElementById('campfireUrlStatus');
            
            if (!urlSection || !uploadSection || !btnUrl || !btnUpload) {
                console.error('Campfire sections or buttons not found');
                return;
            }
            
            // Check if uploaded data exists
            const campfireData = localStorage.getItem('campfireGraphicData');
            const hasUploadedData = campfireData && campfireData.length > 0;
            
            if (method === 'url') {
                // Style URL button as active
                btnUrl.className = 'button';
                btnUpload.className = 'button-secondary';
                
                urlSection.style.display = 'block';
                uploadSection.style.display = 'none';
                
                // Show warning if uploaded data exists
                if (urlStatus) {
                    urlStatus.style.display = hasUploadedData ? 'block' : 'none';
                }
            } else {
                // Style UPLOAD button as active
                btnUrl.className = 'button-secondary';
                btnUpload.className = 'button';
                
                urlSection.style.display = 'none';
                uploadSection.style.display = 'block';
                
                // Hide URL status warning
                if (urlStatus) {
                    urlStatus.style.display = 'none';
                }
                
                // Always show preview if there's uploaded data
                const preview = document.getElementById('campfirePreview');
                if (preview) {
                    if (hasUploadedData) {
                        const isVideo = campfireData.startsWith('data:video/');
                        if (isVideo) {
                            preview.innerHTML = `<video src="${campfireData}" style="max-width: 100%; max-height: 100px; border-radius: 4px;" controls autoplay loop muted></video>`;
                        } else {
                            preview.innerHTML = `<img src="${campfireData}" style="max-width: 100%; max-height: 100px; border-radius: 4px;" alt="Campfire Graphic">`;
                        }
                    } else {
                        preview.innerHTML = '<span style="color: #888; font-size: 12px;">No campfire graphic uploaded</span>';
                    }
                }
            }
            
            updateFullPreview();
        }

        function updateCampfireMethod() {
            const method = document.getElementById('campfireMethod')?.value || 'url';
            setCampfireMethod(method);
        }

        function handleCampfireUpload(event) {
            const file = event.target.files[0];
            if (!file) {
                // Clear the input if no file selected
                event.target.value = '';
                return;
            }
            
            // Check file size (limit to 10MB to prevent localStorage issues)
            const maxSize = 10 * 1024 * 1024; // 10MB
            if (file.size > maxSize) {
                alert('‚ö†Ô∏è File is too large! Maximum size is 10MB. Please use a smaller file or compress it.');
                event.target.value = '';
                return;
            }
            
            const reader = new FileReader();
            reader.onerror = function() {
                alert('‚ùå Error reading file. Please try again.');
                event.target.value = '';
            };
            
            reader.onload = function(e) {
                try {
                    const base64 = e.target.result;
                    localStorage.setItem('campfireGraphicData', base64);
                    
                    // Ensure upload section is visible
                    const uploadSection = document.getElementById('campfireUploadSection');
                    const urlSection = document.getElementById('campfireUrlSection');
                    if (uploadSection && urlSection) {
                        uploadSection.style.display = 'block';
                        urlSection.style.display = 'none';
                        // Update method selector
                        const methodSelect = document.getElementById('campfireMethod');
                        if (methodSelect) {
                            methodSelect.value = 'upload';
                        }
                    }
                    
                    // Update preview
                    const preview = document.getElementById('campfirePreview');
                    if (preview) {
                        const fileExtension = file.name.split('.').pop().toLowerCase();
                        const isVideo = ['mp4', 'webm', 'mov', 'avi'].includes(fileExtension);
                        const isGif = fileExtension === 'gif';
                        
                        if (isVideo || file.type.startsWith('video/')) {
                            preview.innerHTML = `<video src="${base64}" style="max-width: 100%; max-height: 100px; border-radius: 4px;" controls autoplay loop muted></video>`;
                        } else if (isGif || file.type === 'image/gif') {
                            preview.innerHTML = `<img src="${base64}" style="max-width: 100%; max-height: 100px; border-radius: 4px;" alt="Campfire GIF">`;
                        } else {
                            preview.innerHTML = `<img src="${base64}" style="max-width: 100%; max-height: 100px; border-radius: 4px;" alt="Campfire Graphic">`;
                        }
                    }
                    
                    updateFullPreview();
                } catch (error) {
                    console.error('Error handling upload:', error);
                    alert('‚ùå Error processing file. Please try again.');
                    event.target.value = '';
                }
            };
            
            reader.readAsDataURL(file);
        }

        function updateJoinMethod() {
            const method = document.getElementById('joinMethod').value;
            const commandSettings = document.getElementById('commandSettings');
            const emoteSettings = document.getElementById('emoteSettings');
            const cheerSettings = document.getElementById('cheerSettings');
            const cheerAmountSettings = document.getElementById('cheerAmountSettings');

            // Hide all first
            commandSettings.style.display = 'none';
            emoteSettings.style.display = 'none';
            cheerSettings.style.display = 'none';
            cheerAmountSettings.style.display = 'none';

            // Show relevant ones
            if (method === 'command') {
                commandSettings.style.display = 'block';
                updateCurrentCommandDisplay();
            } else if (method === 'emote') {
                emoteSettings.style.display = 'block';
            } else if (method === 'cheer') {
                cheerSettings.style.display = 'block';
                cheerAmountSettings.style.display = 'block';
            }
        }

        function updateCurrentCommandDisplay() {
            const commands = (document.getElementById('command').value || '!join').split(',').map(c => c.trim()).filter(c => c);
            if (commands.length === 0) {
                document.getElementById('currentJoinCommand').textContent = '!join';
                document.getElementById('alternativeJoinCommands').textContent = '';
                document.getElementById('alternativeCommandDisplay').style.display = 'none';
                return;
            }

            // First command is the main one
            const mainCommand = commands[0];
            document.getElementById('currentJoinCommand').textContent = mainCommand;

            // Rest are alternatives
            const alternativeCommands = commands.slice(1);
            if (alternativeCommands.length > 0) {
                document.getElementById('alternativeJoinCommands').textContent = alternativeCommands.join(', ');
                document.getElementById('alternativeCommandDisplay').style.display = 'block';
            } else {
                document.getElementById('alternativeCommandDisplay').style.display = 'none';
            }
        }

        function updateAfkCommandDisplay() {
            const commands = (document.getElementById('afkCommand').value || '!afk').split(',').map(c => c.trim()).filter(c => c);
            if (commands.length === 0) {
                document.getElementById('currentAfkCommand').textContent = '!afk';
                return;
            }
            document.getElementById('currentAfkCommand').textContent = commands.join(', ');
        }

        function updateLurkCommandDisplay() {
            const commands = (document.getElementById('lurkCommand').value || '!lurk').split(',').map(c => c.trim()).filter(c => c);
            if (commands.length === 0) {
                document.getElementById('currentLurkCommand').textContent = '!lurk';
                return;
            }
            document.getElementById('currentLurkCommand').textContent = commands.join(', ');
        }

        async function saveJoinSettings() {
            try {
                saveSettings();
                // Sync STATE command displays after JOIN settings change
                syncStateCommandNames();
                // Visual feedback
                const btn = event.target;
                const originalText = btn.textContent;
                btn.textContent = '‚úÖ SAVED!';
                btn.style.background = '#4caf50';
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.style.background = '';
                }, 2000);
            } catch (e) {
                console.error('Error saving join settings:', e);
                alert('Failed to save settings.');
            }
        }

        async function refreshMembersList() {
            const btn = event?.target;
            const originalText = btn?.textContent || 'üîÑ Refresh';
            
            try {
                // Show loading state
                if (btn) {
                    btn.textContent = '‚è≥ Refreshing...';
                    btn.style.background = '#666';
                    btn.disabled = true;
                }
                
                // First, try to refresh chatters from Twitch API
                if (window.electronAPI && window.electronAPI.refreshChatters) {
                    try {
                        const result = await window.electronAPI.refreshChatters();
                        if (result.success) {
                            console.log(`[refreshMembersList] API refresh: ${result.newCount} new, ${result.updatedCount} updated chatters`);
                        } else {
                            console.warn('[refreshMembersList] API refresh failed:', result.error);
                            // Continue anyway - we'll still load from existing data
                        }
                    } catch (apiError) {
                        console.warn('[refreshMembersList] API refresh error:', apiError);
                        // Continue anyway - we'll still load from existing data
                    }
                }
                
                // Then reload the dashboard members list
                await loadDashboardMembers();
                
                // Visual feedback - success
                if (btn) {
                    btn.textContent = '‚úÖ REFRESHED!';
                    btn.style.background = '#2196f3';
                    setTimeout(() => {
                        btn.textContent = originalText;
                        btn.style.background = '';
                        btn.disabled = false;
                    }, 1500);
                }
            } catch (e) {
                console.error('Error refreshing members:', e);
                
                // Visual feedback - error
                if (btn) {
                    btn.textContent = '‚ùå Error';
                    btn.style.background = '#f44336';
                    setTimeout(() => {
                        btn.textContent = originalText;
                        btn.style.background = '';
                        btn.disabled = false;
                    }, 2000);
                }
                
                if (e.message === 'All member data sources failed to load') {
                    alert('Failed to refresh members list - no data sources available.');
                } else {
                    alert('Failed to refresh members list. Some data may be missing.');
                }
            }
        }

        function handleDefaultSpriteUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                const base64 = e.target.result;
                localStorage.setItem('defaultSpriteData', base64);
                const preview = document.getElementById('defaultSpritePreview');
                preview.innerHTML = `<img src="${base64}" style="max-width: 100%; max-height: 60px; border-radius: 4px;">`;
                updateFullPreview();
            };
            reader.readAsDataURL(file);
        }

        function handleCustomSpriteUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                const base64 = e.target.result;
                localStorage.setItem('customSpriteData', base64);
                const preview = document.getElementById('customSpritePreview');
                preview.innerHTML = `<img src="${base64}" style="max-width: 100%; max-height: 60px; border-radius: 4px;">`;
                updateFullPreview();
                // Update role sprite selects to include the new custom sprite
                populateRoleSpriteSelects();
            };
            reader.readAsDataURL(file);
        }

        // Role-Based Sprites Functions
        function toggleRoleBasedSprites() {
            const enabled = document.getElementById('enableRoleBasedSprites').checked;
            const section = document.getElementById('roleBasedSpritesSection');
            section.style.display = enabled ? 'block' : 'none';
            
            // Save setting
            localStorage.setItem('enableRoleBasedSprites', enabled ? 'true' : 'false');
            updateRoleSpriteSettings();
        }
        
        function updateRoleSpriteSettings() {
            const enabled = document.getElementById('enableRoleBasedSprites').checked;
            
            const roleSprites = {
                enabled: enabled,
                broadcaster: {
                    enabled: document.getElementById('roleBroadcasterEnabled').checked,
                    sprite: document.getElementById('roleBroadcasterSprite').value,
                    customData: localStorage.getItem('roleBroadcasterSpriteData') || null
                },
                moderator: {
                    enabled: document.getElementById('roleModeratorEnabled').checked,
                    sprite: document.getElementById('roleModeratorSprite').value,
                    customData: localStorage.getItem('roleModeratorSpriteData') || null
                },
                vip: {
                    enabled: document.getElementById('roleVipEnabled').checked,
                    sprite: document.getElementById('roleVipSprite').value,
                    customData: localStorage.getItem('roleVipSpriteData') || null
                },
                subscriber: {
                    enabled: document.getElementById('roleSubscriberEnabled').checked,
                    sprite: document.getElementById('roleSubscriberSprite').value,
                    customData: localStorage.getItem('roleSubscriberSpriteData') || null
                }
            };
            
            localStorage.setItem('roleSprites', JSON.stringify(roleSprites));
            
            // Sync to widget via IPC
            saveSettings();
            updateFullPreview();
        }
        
        function handleRoleSpriteUpload(role, event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const base64 = e.target.result;
                localStorage.setItem(`role${role.charAt(0).toUpperCase() + role.slice(1)}SpriteData`, base64);
                
                // Update the select to show "Custom Upload"
                const select = document.getElementById(`role${role.charAt(0).toUpperCase() + role.slice(1)}Sprite`);
                
                // Add custom option if not exists
                let customOption = select.querySelector('option[value="custom"]');
                if (!customOption) {
                    customOption = document.createElement('option');
                    customOption.value = 'custom';
                    customOption.textContent = 'üìÅ Custom Upload';
                    select.appendChild(customOption);
                }
                select.value = 'custom';
                
                updateRoleSpriteSettings();
            };
            reader.readAsDataURL(file);
        }
        
        function loadRoleSpriteSettings() {
            // Load enabled state
            const enabled = localStorage.getItem('enableRoleBasedSprites') === 'true';
            document.getElementById('enableRoleBasedSprites').checked = enabled;
            document.getElementById('roleBasedSpritesSection').style.display = enabled ? 'block' : 'none';
            
            // Load role sprite settings
            try {
                const roleSprites = JSON.parse(localStorage.getItem('roleSprites') || '{}');
                
                if (roleSprites.broadcaster) {
                    document.getElementById('roleBroadcasterEnabled').checked = roleSprites.broadcaster.enabled !== false;
                    if (roleSprites.broadcaster.sprite) {
                        const select = document.getElementById('roleBroadcasterSprite');
                        if (roleSprites.broadcaster.sprite === 'custom') {
                            let customOption = select.querySelector('option[value="custom"]');
                            if (!customOption) {
                                customOption = document.createElement('option');
                                customOption.value = 'custom';
                                customOption.textContent = 'üìÅ Custom Upload';
                                select.appendChild(customOption);
                            }
                        }
                        select.value = roleSprites.broadcaster.sprite;
                    }
                }
                
                if (roleSprites.moderator) {
                    document.getElementById('roleModeratorEnabled').checked = roleSprites.moderator.enabled !== false;
                    if (roleSprites.moderator.sprite) {
                        const select = document.getElementById('roleModeratorSprite');
                        if (roleSprites.moderator.sprite === 'custom') {
                            let customOption = select.querySelector('option[value="custom"]');
                            if (!customOption) {
                                customOption = document.createElement('option');
                                customOption.value = 'custom';
                                customOption.textContent = 'üìÅ Custom Upload';
                                select.appendChild(customOption);
                            }
                        }
                        select.value = roleSprites.moderator.sprite;
                    }
                }
                
                if (roleSprites.vip) {
                    document.getElementById('roleVipEnabled').checked = roleSprites.vip.enabled !== false;
                    if (roleSprites.vip.sprite) {
                        const select = document.getElementById('roleVipSprite');
                        if (roleSprites.vip.sprite === 'custom') {
                            let customOption = select.querySelector('option[value="custom"]');
                            if (!customOption) {
                                customOption = document.createElement('option');
                                customOption.value = 'custom';
                                customOption.textContent = 'üìÅ Custom Upload';
                                select.appendChild(customOption);
                            }
                        }
                        select.value = roleSprites.vip.sprite;
                    }
                }
                
                if (roleSprites.subscriber) {
                    document.getElementById('roleSubscriberEnabled').checked = roleSprites.subscriber.enabled !== false;
                    if (roleSprites.subscriber.sprite) {
                        const select = document.getElementById('roleSubscriberSprite');
                        if (roleSprites.subscriber.sprite === 'custom') {
                            let customOption = select.querySelector('option[value="custom"]');
                            if (!customOption) {
                                customOption = document.createElement('option');
                                customOption.value = 'custom';
                                customOption.textContent = 'üìÅ Custom Upload';
                                select.appendChild(customOption);
                            }
                        }
                        select.value = roleSprites.subscriber.sprite;
                    }
                }
            } catch (e) {
                console.warn('Error loading role sprite settings:', e);
            }
        }
        
        function populateRoleSpriteSelects() {
            // Get available sprites from the current sprite mode lists
            const spriteSelects = ['roleBroadcasterSprite', 'roleModeratorSprite', 'roleVipSprite', 'roleSubscriberSprite'];
            
            // Collect sprites from all modes
            const allSprites = [];
            
            // Add Shadow/Circle sprites
            const shadowList = document.getElementById('shadowSpritesList');
            if (shadowList) {
                shadowList.querySelectorAll('.sprite-item').forEach(item => {
                    const name = item.getAttribute('data-sprite-name');
                    const src = item.querySelector('img')?.src;
                    if (name && src) {
                        allSprites.push({ name: `Circle: ${name}`, value: `circle:${name}`, src, category: 'Circles' });
                    }
                });
            }
            
            // Add RPG characters
            const rpgList = document.getElementById('rpgSpritesList');
            if (rpgList) {
                rpgList.querySelectorAll('.sprite-item').forEach(item => {
                    const name = item.getAttribute('data-sprite-name');
                    const src = item.querySelector('img')?.src;
                    if (name && src) {
                        allSprites.push({ name: `Adventurer: ${name}`, value: `rpg:${name}`, src, category: 'Adventurers' });
                    }
                });
            }
            
            // Add Morphs
            const morphList = document.getElementById('morphSpritesList');
            if (morphList) {
                morphList.querySelectorAll('.sprite-item').forEach(item => {
                    const name = item.getAttribute('data-sprite-name');
                    const src = item.querySelector('img')?.src;
                    if (name && src) {
                        allSprites.push({ name: `Morph: ${name}`, value: `morph:${name}`, src, category: 'Morphs' });
                    }
                });
            }
            
            // Add custom sprite if uploaded
            const customPreview = document.getElementById('customSpritePreview');
            if (customPreview) {
                const customImg = customPreview.querySelector('img');
                if (customImg && customImg.src) {
                    allSprites.push({ name: 'Custom: Uploaded Sprite', value: `custom:uploaded`, src: customImg.src, category: 'Custom' });
                }
            }
            
            // Populate selects with optgroups for better organization
            spriteSelects.forEach(selectId => {
                const select = document.getElementById(selectId);
                if (!select) return;
                
                // Keep existing value
                const existingValue = select.value;
                
                // Clear all except first option (Use Default)
                while (select.options.length > 1) {
                    select.remove(1);
                }
                
                // Group sprites by category
                const categories = {};
                allSprites.forEach(sprite => {
                    if (!categories[sprite.category]) {
                        categories[sprite.category] = [];
                    }
                    categories[sprite.category].push(sprite);
                });
                
                // Add optgroups for each category
                Object.keys(categories).forEach(category => {
                    const optgroup = document.createElement('optgroup');
                    optgroup.label = category;
                    
                    categories[category].forEach(sprite => {
                        const option = document.createElement('option');
                        option.value = sprite.value;
                        option.textContent = sprite.name.replace(`${category}: `, '').replace('Circle: ', '').replace('Adventurer: ', '').replace('Morph: ', '').replace('Custom: ', '');
                        optgroup.appendChild(option);
                    });
                    
                    select.appendChild(optgroup);
                });
                
                // Restore value if it exists
                if (existingValue) {
                    select.value = existingValue;
                }
            });
        }

        // ============================================
        // Audio System Functions
        // ============================================
        
        // Selected audio output device ID
        let selectedAudioOutputDeviceId = localStorage.getItem('audioOutputDeviceId') || '';
        
        // Refresh and populate audio output devices
        async function refreshAudioDevices() {
            const select = document.getElementById('audioOutputDevice');
            if (!select) return;
            
            try {
                // Request permission to access audio devices
                await navigator.mediaDevices.getUserMedia({ audio: true });
                
                // Get all media devices
                const devices = await navigator.mediaDevices.enumerateDevices();
                
                // Filter to only audio output devices
                const audioOutputs = devices.filter(device => device.kind === 'audiooutput');
                
                // Clear existing options except default
                select.innerHTML = '<option value="">Default System Output</option>';
                
                // Add each audio output device
                audioOutputs.forEach(device => {
                    const option = document.createElement('option');
                    option.value = device.deviceId;
                    option.textContent = device.label || `Audio Output ${audioOutputs.indexOf(device) + 1}`;
                    select.appendChild(option);
                });
                
                // Restore saved selection
                if (selectedAudioOutputDeviceId) {
                    select.value = selectedAudioOutputDeviceId;
                }
                
                console.log('Audio devices refreshed:', audioOutputs.length, 'output devices found');
            } catch (err) {
                console.error('Error enumerating audio devices:', err);
                // Still show default option
                select.innerHTML = '<option value="">Default System Output</option>';
            }
        }
        
        // Set audio output device
        function setAudioOutputDevice(deviceId) {
            selectedAudioOutputDeviceId = deviceId;
            localStorage.setItem('audioOutputDeviceId', deviceId);
            
            // Update all existing audio elements to use the new device
            Object.values(audioPreviewElements).forEach(audio => {
                if (audio && audio.setSinkId) {
                    audio.setSinkId(deviceId).catch(err => {
                        console.error('Error setting audio output device:', err);
                    });
                }
            });
            
            console.log('Audio output device set to:', deviceId || 'default');
        }
        
        // Initialize audio devices on page load
        document.addEventListener('DOMContentLoaded', () => {
            refreshAudioDevices();
        });
        
        // Store audio file data (base64) for each audio type
        const audioFileData = {
            music: null,
            ambience: null,
            join: null,
            leave: null,
            speak: null
        };
        
        // Audio preview elements
        const audioPreviewElements = {};
        
        // Handle audio file selection and update filename display
        function handleAudioFileSelect(input, labelId) {
            const label = document.getElementById(labelId);
            if (label) {
                if (input.files && input.files[0]) {
                    label.textContent = input.files[0].name;
                    label.title = input.files[0].name; // Show full name on hover
                } else {
                    label.textContent = 'No file';
                    label.title = '';
                }
            }
        }
        
        // Maximum file size for audio - increased to 50MB since we use file storage now
        const MAX_AUDIO_FILE_SIZE = 50 * 1024 * 1024; // 50MB for music/ambience
        const MAX_SOUND_EFFECT_SIZE = 2 * 1024 * 1024; // 2MB for sound effects
        
        function updateAudioSetting(category, property, value) {
            // Get current audio settings from localStorage
            let audioSettings = JSON.parse(localStorage.getItem('audioSettings') || '{}');
            
            // Initialize category if it doesn't exist
            if (!audioSettings[category]) {
                audioSettings[category] = {};
            }
            
            // Handle file uploads for music/ambience - use file-based storage for large files
            if (property === 'file' && value instanceof File && (category === 'music' || category === 'ambience')) {
                // Check file size
                if (value.size > MAX_AUDIO_FILE_SIZE) {
                    const sizeMB = (value.size / (1024 * 1024)).toFixed(2);
                    alert(`Audio file is too large (${sizeMB}MB). Maximum size is 50MB.`);
                    return;
                }
                
                const reader = new FileReader();
                reader.onload = async function(e) {
                    const fileData = e.target.result;
                    audioFileData[category] = fileData;
                    
                    // Save to file system via IPC (for large files)
                    if (window.electronAPI && window.electronAPI.saveAudioFile) {
                        try {
                            const result = await window.electronAPI.saveAudioFile(category, value.name, fileData);
                            if (result.success) {
                                // Store only metadata in localStorage (not the file data)
                                audioSettings[category].fileName = value.name;
                                audioSettings[category].useFileStorage = true;
                                // Remove old fileData from localStorage to save space
                                delete audioSettings[category].fileData;
                                localStorage.setItem('audioSettings', JSON.stringify(audioSettings));
                                saveSettings();
                                console.log(`Audio file saved to disk for ${category}: ${value.name} (${(value.size / 1024 / 1024).toFixed(2)}MB)`);
                            } else {
                                throw new Error(result.error || 'Failed to save file');
                            }
                        } catch (err) {
                            console.error('Failed to save audio file to disk:', err);
                            alert(`Failed to save audio file: ${err.message}`);
                        }
                    } else {
                        // Fallback to localStorage for smaller files or non-Electron environment
                        audioSettings[category].fileData = fileData;
                        audioSettings[category].fileName = value.name;
                        try {
                            localStorage.setItem('audioSettings', JSON.stringify(audioSettings));
                            saveSettings();
                            console.log(`Audio file loaded for ${category}: ${value.name} (${(value.size / 1024).toFixed(1)}KB)`);
                        } catch (err) {
                            console.error('Failed to save audio to localStorage:', err);
                            alert(`Failed to save audio file. The file may be too large.`);
                        }
                    }
                };
                reader.onerror = function(err) {
                    console.error('Failed to read audio file:', err);
                    alert('Failed to read audio file. Please try again.');
                };
                reader.readAsDataURL(value);
                return;
            }
            
            // Handle userSounds category (join, leave, speak)
            if (category === 'userSounds') {
                if (!audioSettings.userSounds) {
                    audioSettings.userSounds = {};
                }
                if (!audioSettings.userSounds[property]) {
                    audioSettings.userSounds[property] = {};
                }
                
                if (typeof value === 'object') {
                    // Handle file input for user sounds
                    const fileInput = document.getElementById(`${property}SoundFile`);
                    if (fileInput && fileInput.files[0]) {
                        const file = fileInput.files[0];
                        // Check file size (user sounds should be small - 1MB max)
                        if (file.size > 1024 * 1024) {
                            const sizeMB = (file.size / (1024 * 1024)).toFixed(2);
                            alert(`Sound effect file is too large (${sizeMB}MB). Maximum size is 1MB.\n\nTip: Use a short sound effect.`);
                            return;
                        }
                        
                        const reader = new FileReader();
                        reader.onload = function(e) {
                            audioFileData[property] = e.target.result;
                            audioSettings.userSounds[property].fileData = e.target.result;
                            audioSettings.userSounds[property].fileName = file.name;
                            audioSettings.userSounds[property].gain = parseInt(value.gain) || 80;
                            try {
                                localStorage.setItem('audioSettings', JSON.stringify(audioSettings));
                                // Send immediate update to widget for real-time volume control
                                if (window.electronAPI?.updateAudioSettings) {
                                    try {
                                        window.electronAPI.updateAudioSettings(audioSettings);
                                    } catch (e) {
                                        console.warn('Failed to send immediate audio settings update:', e);
                                    }
                                }
                                saveSettings();
                                console.log(`Sound effect loaded for ${property}: ${file.name} (${(file.size / 1024).toFixed(1)}KB)`);
                            } catch (err) {
                                console.error('Failed to save sound to localStorage:', err);
                                alert(`Failed to save sound file. Storage may be full.`);
                            }
                        };
                        reader.onerror = function(err) {
                            console.error('Failed to read sound file:', err);
                            alert('Failed to read sound file. Please try again.');
                        };
                        reader.readAsDataURL(file);
                    } else {
                        // Just update gain
                        audioSettings.userSounds[property].gain = parseInt(value.gain) || 80;
                        localStorage.setItem('audioSettings', JSON.stringify(audioSettings));
                        // Send immediate update to widget for real-time volume control
                        if (window.electronAPI?.updateAudioSettings) {
                            try {
                                window.electronAPI.updateAudioSettings(audioSettings);
                            } catch (e) {
                                console.warn('Failed to send immediate audio settings update:', e);
                            }
                        }
                        saveSettings();
                    }
                } else {
                    audioSettings.userSounds[property] = value;
                    localStorage.setItem('audioSettings', JSON.stringify(audioSettings));
                    saveSettings();
                }
                return;
            }
            
            // Update the property
            audioSettings[category][property] = value;
            localStorage.setItem('audioSettings', JSON.stringify(audioSettings));
            saveSettings();
            
            // If volume is being changed for music/ambience and it's currently playing, update widget
            if (property === 'volume' && (category === 'music' || category === 'ambience')) {
                if (audioPlaybackState[category] && window.electronAPI && window.electronAPI.controlAudio) {
                    window.electronAPI.controlAudio('setVolume', category, parseInt(value));
                }
            }
        }
        
        function previewAudio(audioType) {
            // Stop any existing preview
            if (audioPreviewElements[audioType]) {
                audioPreviewElements[audioType].pause();
                audioPreviewElements[audioType].currentTime = 0;
            }
            
            // Get audio settings
            const audioSettings = JSON.parse(localStorage.getItem('audioSettings') || '{}');
            let audioData = null;
            let volume = 0.7;
            
            // Determine audio source based on type
            if (audioType === 'music') {
                audioData = audioSettings.music?.fileData || audioFileData.music;
                volume = (parseInt(document.getElementById('musicVolume')?.value) || 70) / 100;
            } else if (audioType === 'ambience') {
                audioData = audioSettings.ambience?.fileData || audioFileData.ambience;
                volume = (parseInt(document.getElementById('ambienceVolume')?.value) || 50) / 100;
            } else if (audioType === 'join') {
                audioData = audioSettings.userSounds?.join?.fileData || audioFileData.join;
                volume = (parseInt(document.getElementById('joinGain')?.value) || 80) / 100;
            } else if (audioType === 'leave') {
                audioData = audioSettings.userSounds?.leave?.fileData || audioFileData.leave;
                volume = (parseInt(document.getElementById('leaveGain')?.value) || 60) / 100;
            } else if (audioType === 'speak') {
                audioData = audioSettings.userSounds?.speak?.fileData || audioFileData.speak;
                volume = (parseInt(document.getElementById('speakGain')?.value) || 40) / 100;
            } else if (audioType === 'afk') {
                audioData = audioSettings.userSounds?.afk?.fileData || audioFileData.afk;
                volume = (parseInt(document.getElementById('afkGain')?.value) || 50) / 100;
            } else if (audioType === 'lurk') {
                audioData = audioSettings.userSounds?.lurk?.fileData || audioFileData.lurk;
                volume = (parseInt(document.getElementById('lurkGain')?.value) || 50) / 100;
            }
            
            if (!audioData) {
                console.warn(`No audio file loaded for ${audioType}`);
                return;
            }
            
            // Create and play audio
            const audio = new Audio(audioData);
            audio.volume = volume;
            audioPreviewElements[audioType] = audio;
            
            // Set audio output device if selected
            if (selectedAudioOutputDeviceId && audio.setSinkId) {
                audio.setSinkId(selectedAudioOutputDeviceId).then(() => {
                    audio.play().catch(e => {
                        console.error(`Failed to play ${audioType} audio:`, e);
                    });
                }).catch(err => {
                    console.error('Error setting audio output device:', err);
                    // Fall back to default device
                    audio.play().catch(e => {
                        console.error(`Failed to play ${audioType} audio:`, e);
                    });
                });
            } else {
                audio.play().catch(e => {
                    console.error(`Failed to play ${audioType} audio:`, e);
                });
            }
        }
        
        // Track audio playback state (actual audio plays in widget for persistence)
        const audioPlaybackState = {
            music: false,
            ambience: false
        };
        
        // Toggle play/stop for music or ambience (sends commands to widget via IPC)
        async function toggleAudioPlayback(audioType) {
            const btn = document.getElementById(`${audioType}PlayBtn`);
            const audioSettings = JSON.parse(localStorage.getItem('audioSettings') || '{}');
            
            // If already playing, stop it
            if (audioPlaybackState[audioType]) {
                // Send stop command to widget
                if (window.electronAPI && window.electronAPI.controlAudio) {
                    try {
                        await window.electronAPI.controlAudio('stop', audioType);
                        audioPlaybackState[audioType] = false;
                        if (btn) btn.textContent = '‚ñ∂Ô∏è Play';
                    } catch (e) {
                        console.error(`Failed to stop ${audioType}:`, e);
                    }
                }
                return;
            }
            
            // Check if audio file exists
            const hasAudioFile = audioSettings[audioType]?.fileData ||
                                 audioSettings[audioType]?.useFileStorage ||
                                 audioFileData[audioType];
            
            if (!hasAudioFile) {
                console.warn(`No audio file loaded for ${audioType}`);
                return;
            }
            
            // Get volume setting
            let volume = 70;
            if (audioType === 'music') {
                volume = parseInt(document.getElementById('musicVolume')?.value) || 70;
            } else if (audioType === 'ambience') {
                volume = parseInt(document.getElementById('ambienceVolume')?.value) || 50;
            }
            
            // Send play command to widget via IPC
            if (window.electronAPI && window.electronAPI.controlAudio) {
                try {
                    const result = await window.electronAPI.controlAudio('play', audioType, volume);
                    if (result.success) {
                        audioPlaybackState[audioType] = true;
                        if (btn) btn.textContent = '‚èπÔ∏è Stop';
                    } else {
                        console.error(`Failed to play ${audioType}:`, result.error);
                    }
                } catch (e) {
                    console.error(`Failed to play ${audioType}:`, e);
                }
            } else {
                console.warn('electronAPI.controlAudio not available');
            }
        }
        
        // Auto-play music and ambience if enabled
        function autoPlayAudioOnLoad() {
            const audioSettings = JSON.parse(localStorage.getItem('audioSettings') || '{}');
            
            // Auto-play music if enabled (check both fileData and useFileStorage)
            if (audioSettings.music?.autoPlay && (audioSettings.music?.fileData || audioSettings.music?.useFileStorage || audioFileData.music)) {
                setTimeout(() => toggleAudioPlayback('music'), 500);
            }
            
            // Auto-play ambience if enabled (check both fileData and useFileStorage)
            if (audioSettings.ambience?.autoPlay && (audioSettings.ambience?.fileData || audioSettings.ambience?.useFileStorage || audioFileData.ambience)) {
                setTimeout(() => toggleAudioPlayback('ambience'), 700);
            }
        }
        
        // Load audio file from disk storage
        async function loadAudioFromDisk(audioType) {
            if (window.electronAPI && window.electronAPI.loadAudioFile) {
                try {
                    const result = await window.electronAPI.loadAudioFile(audioType);
                    if (result.success) {
                        audioFileData[audioType] = result.fileData;
                        console.log(`Loaded ${audioType} audio from disk: ${result.fileName}`);
                        return true;
                    }
                } catch (err) {
                    console.error(`Failed to load ${audioType} audio from disk:`, err);
                }
            }
            return false;
        }
        
        async function loadAudioSettings() {
            const audioSettings = JSON.parse(localStorage.getItem('audioSettings') || '{}');
            
            // Load music settings
            if (audioSettings.music) {
                if (audioSettings.music.volume !== undefined) {
                    const musicVolume = document.getElementById('musicVolume');
                    const musicVolumeValue = document.getElementById('musicVolumeValue');
                    if (musicVolume) musicVolume.value = audioSettings.music.volume;
                    if (musicVolumeValue) musicVolumeValue.textContent = audioSettings.music.volume + '%';
                }
                if (audioSettings.music.loop !== undefined) {
                    const musicLoop = document.getElementById('musicLoop');
                    if (musicLoop) musicLoop.checked = audioSettings.music.loop;
                }
                if (audioSettings.music.autoPlay !== undefined) {
                    const musicAutoPlay = document.getElementById('musicAutoPlay');
                    if (musicAutoPlay) musicAutoPlay.checked = audioSettings.music.autoPlay;
                }
                // Load from file storage if useFileStorage is set
                if (audioSettings.music.useFileStorage) {
                    await loadAudioFromDisk('music');
                } else if (audioSettings.music.fileData) {
                    audioFileData.music = audioSettings.music.fileData;
                }
                // Restore music file name display
                if (audioSettings.music.fileName) {
                    const musicFileName = document.getElementById('musicFileName');
                    if (musicFileName) musicFileName.textContent = audioSettings.music.fileName;
                }
            }
            
            // Load ambience settings
            if (audioSettings.ambience) {
                if (audioSettings.ambience.volume !== undefined) {
                    const ambienceVolume = document.getElementById('ambienceVolume');
                    const ambienceVolumeValue = document.getElementById('ambienceVolumeValue');
                    if (ambienceVolume) ambienceVolume.value = audioSettings.ambience.volume;
                    if (ambienceVolumeValue) ambienceVolumeValue.textContent = audioSettings.ambience.volume + '%';
                }
                if (audioSettings.ambience.loop !== undefined) {
                    const ambienceLoop = document.getElementById('ambienceLoop');
                    if (ambienceLoop) ambienceLoop.checked = audioSettings.ambience.loop;
                }
                if (audioSettings.ambience.autoPlay !== undefined) {
                    const ambienceAutoPlay = document.getElementById('ambienceAutoPlay');
                    if (ambienceAutoPlay) ambienceAutoPlay.checked = audioSettings.ambience.autoPlay;
                }
                // Load from file storage if useFileStorage is set
                if (audioSettings.ambience.useFileStorage) {
                    await loadAudioFromDisk('ambience');
                } else if (audioSettings.ambience.fileData) {
                    audioFileData.ambience = audioSettings.ambience.fileData;
                }
                // Restore ambience file name display
                if (audioSettings.ambience.fileName) {
                    const ambienceFileName = document.getElementById('ambienceFileName');
                    if (ambienceFileName) ambienceFileName.textContent = audioSettings.ambience.fileName;
                }
            }
            
            // Note: Auto-play is now handled by the widget window for persistence
            // The widget will auto-play music/ambience when it loads if enabled
            
            // Load user sounds settings (including afk and lurk)
            if (audioSettings.userSounds) {
                ['join', 'leave', 'speak', 'afk', 'lurk'].forEach(soundType => {
                    if (audioSettings.userSounds[soundType]) {
                        const gainInput = document.getElementById(`${soundType}Gain`);
                        const gainValue = document.getElementById(`${soundType}GainValue`);
                        if (gainInput && audioSettings.userSounds[soundType].gain !== undefined) {
                            gainInput.value = audioSettings.userSounds[soundType].gain;
                        }
                        if (gainValue && audioSettings.userSounds[soundType].gain !== undefined) {
                            gainValue.textContent = audioSettings.userSounds[soundType].gain + '%';
                        }
                        if (audioSettings.userSounds[soundType].fileData) {
                            audioFileData[soundType] = audioSettings.userSounds[soundType].fileData;
                        }
                        // Restore user sound file name display
                        if (audioSettings.userSounds[soundType].fileName) {
                            const fileNameElement = document.getElementById(`${soundType}FileName`);
                            if (fileNameElement) fileNameElement.textContent = audioSettings.userSounds[soundType].fileName;
                        }
                    }
                });
            }
            
            // Sync play button states with widget's audio status
            syncAudioPlaybackState();
        }
        
        // Sync dashboard play buttons with widget's actual audio state
        async function syncAudioPlaybackState() {
            if (window.electronAPI && window.electronAPI.getAudioStatus) {
                try {
                    const status = await window.electronAPI.getAudioStatus();
                    if (status) {
                        // Update music button
                        if (status.music) {
                            audioPlaybackState.music = status.music.playing;
                            const musicBtn = document.getElementById('musicPlayBtn');
                            if (musicBtn) {
                                musicBtn.textContent = status.music.playing ? '‚èπÔ∏è Stop' : '‚ñ∂Ô∏è Play';
                            }
                        }
                        // Update ambience button
                        if (status.ambience) {
                            audioPlaybackState.ambience = status.ambience.playing;
                            const ambienceBtn = document.getElementById('ambiencePlayBtn');
                            if (ambienceBtn) {
                                ambienceBtn.textContent = status.ambience.playing ? '‚èπÔ∏è Stop' : '‚ñ∂Ô∏è Play';
                            }
                        }
                    }
                } catch (e) {
                    console.warn('Could not sync audio playback state:', e);
                }
            }
        }
        
        // ============================================
        // User States System Functions
        // ============================================
        
        function updateUserStateSetting(property, value) {
            // Get current user state settings from localStorage
            let userStates = JSON.parse(localStorage.getItem('userStates') || '{}');
            
            // Update the property
            userStates[property] = value;
            localStorage.setItem('userStates', JSON.stringify(userStates));
            saveSettings();
        }
        
        function loadUserStateSettings() {
            const userStates = JSON.parse(localStorage.getItem('userStates') || '{}');
            
            // Load enabled state
            const enabledCheckbox = document.getElementById('userStatesEnabled');
            if (enabledCheckbox) {
                enabledCheckbox.checked = userStates.enabled || false;
            }
            
            // Load sleepy threshold
            const sleepyMinutes = document.getElementById('sleepyMinutes');
            const sleepyMinutesValue = document.getElementById('sleepyMinutesValue');
            if (sleepyMinutes) {
                sleepyMinutes.value = userStates.sleepyMinutes || 5;
            }
            if (sleepyMinutesValue) {
                sleepyMinutesValue.textContent = (userStates.sleepyMinutes || 5) + ' min';
            }
            
            // Load AFK threshold
            const afkMinutes = document.getElementById('afkMinutes');
            const afkMinutesValue = document.getElementById('afkMinutesValue');
            if (afkMinutes) {
                afkMinutes.value = userStates.afkMinutes || 15;
            }
            if (afkMinutesValue) {
                afkMinutesValue.textContent = (userStates.afkMinutes || 15) + ' min';
            }
            
            // Load Auto Leave threshold
            const autoLeaveMinutes = document.getElementById('autoLeaveMinutes');
            if (autoLeaveMinutes) {
                autoLeaveMinutes.value = userStates.autoLeaveMinutes || 0;
            }
        }

        function setSpriteDirection(direction, updatePreview = true) {
            const leftBtn = document.getElementById('spriteDirectionLeft');
            const rightBtn = document.getElementById('spriteDirectionRight');
            const display = document.getElementById('spriteDirectionDisplay');
            
            // Remove active class from both buttons
            leftBtn.classList.remove('active');
            rightBtn.classList.remove('active');
            
            // Add active class to selected button
            if (direction === 'left') {
                leftBtn.classList.add('active');
                display.textContent = 'Default: Left';
            } else {
                rightBtn.classList.add('active');
                display.textContent = 'Default: Right';
            }
            
            if (updatePreview) {
                // Save spriteDefaultDirection per sprite mode
                const currentSettings = JSON.parse(localStorage.getItem('campfireWidgetSettings') || '{}');
                const currentMode = document.getElementById('spriteMode')?.value || 'circles';
                
                // Initialize spriteDefaultDirections if it doesn't exist
                if (!currentSettings.spriteDefaultDirections) {
                    currentSettings.spriteDefaultDirections = {
                        'circles': currentSettings.spriteDefaultDirection || 'left',
                        'circle': currentSettings.spriteDefaultDirection || 'left',
                        'rpg-characters': currentSettings.spriteDefaultDirection || 'left',
                        'pixel-morphs': currentSettings.spriteDefaultDirection || 'left',
                        'custom': currentSettings.spriteDefaultDirection || 'left'
                    };
                }
                
                // Save direction for current mode
                currentSettings.spriteDefaultDirections[currentMode] = direction;
                
                // Also update legacy spriteDefaultDirection for backward compatibility
                currentSettings.spriteDefaultDirection = direction;
                
                localStorage.setItem('campfireWidgetSettings', JSON.stringify(currentSettings));
                // Dispatch event to update widget
                window.dispatchEvent(new CustomEvent('campfireSettingsUpdate', { detail: { 
                    spriteDefaultDirection: direction,
                    spriteDefaultDirections: currentSettings.spriteDefaultDirections
                } }));
            }
        }

        // Status Icon Placement Functions
        function updateStatusIconPreview() {
            const topValue = parseInt(document.getElementById('statusIconTop').value);
            const rightValue = parseInt(document.getElementById('statusIconRight').value);
            
            // Update value displays
            document.getElementById('statusIconTopValue').textContent = topValue + 'px';
            document.getElementById('statusIconRightValue').textContent = rightValue + 'px';
            
            // Update preview icon position
            const previewIcon = document.getElementById('statusIconPreviewIcon');
            if (previewIcon) {
                previewIcon.style.top = topValue + 'px';
                previewIcon.style.right = rightValue + 'px';
            }
        }
        
        function resetStatusIconPosition() {
            document.getElementById('statusIconTop').value = 0;
            document.getElementById('statusIconRight').value = 0;
            updateStatusIconPreview();
        }
        
        function saveStatusIconPosition() {
            const topValue = parseInt(document.getElementById('statusIconTop').value);
            const rightValue = parseInt(document.getElementById('statusIconRight').value);
            
            // Save to settings
            const currentSettings = JSON.parse(localStorage.getItem('campfireWidgetSettings') || '{}');
            currentSettings.statusIconTop = topValue;
            currentSettings.statusIconRight = rightValue;
            localStorage.setItem('campfireWidgetSettings', JSON.stringify(currentSettings));
            
            // Dispatch event to update widget
            window.dispatchEvent(new CustomEvent('campfireSettingsUpdate', { detail: {
                statusIconTop: topValue,
                statusIconRight: rightValue
            } }));
            
            // Show confirmation
            alert('‚úÖ Status icon position saved!');
        }
        
        function loadStatusIconPosition() {
            const currentSettings = JSON.parse(localStorage.getItem('campfireWidgetSettings') || '{}');
            const topValue = currentSettings.statusIconTop || 0;
            const rightValue = currentSettings.statusIconRight || 0;
            
            const topInput = document.getElementById('statusIconTop');
            const rightInput = document.getElementById('statusIconRight');
            
            if (topInput) topInput.value = topValue;
            if (rightInput) rightInput.value = rightValue;
            
            updateStatusIconPreview();
        }

        function copyViewerLink() {
            // Get the viewer dashboard link
            let link;
            if (window.location.protocol === 'file:') {
                // If opened as file://, use localhost
                link = 'http://localhost:3000/viewer-dashboard.html';
            } else {
                link = window.location.origin + window.location.pathname.replace('dashboard.html', 'viewer-dashboard.html');
            }
            // Update the input field
            const input = document.getElementById('viewerDashboardLink');
            if (input) input.value = link;
            
            navigator.clipboard.writeText(link).then(() => {
                alert('‚úÖ Viewer dashboard link copied!');
            }).catch(() => {
                if (input) {
                    input.select();
                    document.execCommand('copy');
                }
                alert('‚úÖ Viewer dashboard link copied!');
            });
        }

        // ============================================
        // Widget Background (Swatches)
        // ============================================
        function setWidgetBackground(value, shouldUpdate = true) {
            const v = String(value || 'transparent').toLowerCase();
            const input = document.getElementById('widgetBackground');
            if (input) input.value = v;

            // Highlight selection
            document.querySelectorAll('.bg-swatch').forEach(btn => {
                const bg = (btn.getAttribute('data-bg') || '').toLowerCase();
                btn.classList.toggle('selected', bg === v);
            });

            // On Windows, transparent + native frame is unreliable.
            // If the user chooses Transparent, force frameless for stability.
            const isWindows = /Windows/i.test(navigator.userAgent || '');
            if (isWindows) {
                const frameEl = document.getElementById('useNativeFrame');
                const hintEl = document.getElementById('useNativeFrameHint');
                if (v === 'transparent') {
                    if (frameEl) {
                        frameEl.checked = false;
                        frameEl.disabled = true;
                    }
                    if (hintEl) {
                        hintEl.textContent = 'On Windows, Transparent forces frameless mode for stability (prevents blank/click-through windows).';
                    }
                } else {
                    if (frameEl) {
                        frameEl.disabled = false;
                    }
                    if (hintEl) {
                        hintEl.textContent = 'Tip: Turning this off makes the widget window frameless, and the in-widget menu bar becomes the draggable area.';
                    }
                }
            }

            if (shouldUpdate) updateFullPreview();
        }
        
        // Update viewer dashboard link on page load
        function updateViewerDashboardLink() {
            const input = document.getElementById('viewerDashboardLink');
            if (input) {
                if (window.location.protocol === 'file:') {
                    input.value = 'http://localhost:3000/viewer-dashboard.html';
                } else {
                    input.value = window.location.origin + window.location.pathname.replace('dashboard.html', 'viewer-dashboard.html');
                }
            }
        }

        function getSettings() {
            const joinMethodValue = document.getElementById('joinMethod')?.value || 'command';
            return {
                hideCampfireGraphic: document.getElementById('hideCampfireGraphic')?.checked || false,
                campfireMethod: document.getElementById('campfireMethod')?.value || 'url',
                campfireGraphicUrl: document.getElementById('campfireUrl')?.value || '',
                campfireGraphicData: localStorage.getItem('campfireGraphicData') || '',
                circleAngle: parseInt(document.getElementById('circleAngle')?.value || 64),
                campfireYOffset: parseInt(document.getElementById('campfireYOffset')?.value || 50),
                nameBubbleOffset: parseInt(document.getElementById('nameBubbleOffset')?.value || -25),
                widgetBackground: document.getElementById('widgetBackground')?.value || 'black',
                useNativeFrame: document.getElementById('useNativeFrame')?.checked !== false,
                showTestUsers: false, // Using buttons instead of checkbox
                joinMethod: joinMethodValue,
                commands: (document.getElementById('command')?.value || '!join').split(',').map(c => c.trim()).filter(c => c),
                afkCommands: (document.getElementById('afkCommand')?.value || '!afk').split(',').map(c => c.trim()).filter(c => c),
                lurkCommands: (document.getElementById('lurkCommand')?.value || '!lurk').split(',').map(c => c.trim()).filter(c => c),
                emoteName: document.getElementById('emoteName')?.value || '',
                maxUsers: parseInt(document.getElementById('maxUsers')?.value || 20),
                subscriberOnly: document.getElementById('subscriberOnly')?.checked || false,
                subTier2Only: document.getElementById('subTier2Only')?.checked || false,
                subTier3Only: document.getElementById('subTier3Only')?.checked || false,
                vipOnly: document.getElementById('vipOnly')?.checked || false,
                primeOnly: document.getElementById('primeOnly')?.checked || false,
                followersOnly: document.getElementById('followersOnly')?.checked || false,
                cheerMethod: joinMethodValue === 'cheer' ? (document.getElementById('cheerMethod')?.value || 'bits') : null,
                cheerAmount: joinMethodValue === 'cheer' ? parseInt(document.getElementById('cheerAmount')?.value || 100) : 0,
                spriteMode: document.getElementById('spriteMode')?.value || 'circles',
                glowSize: parseInt(document.getElementById('glowSize')?.value || 500),
                glowIntensity: parseInt(document.getElementById('glowIntensity')?.value || 77),
                shadowIntensity: parseInt(document.getElementById('shadowIntensity')?.value || 91),
                glowSpread: parseInt(document.getElementById('glowSpread')?.value || 64),
                animatedGlow: document.getElementById('animatedGlow')?.checked !== false,
                flickerOpacity: parseInt(document.getElementById('flickerOpacity')?.value || 25),
                flickerSpread: parseInt(document.getElementById('flickerSpread')?.value || 55),
                // Legacy support (for backward compatibility)
                defaultSpriteData: localStorage.getItem('defaultSpriteData') || '',
                customSpriteData: localStorage.getItem('customSpriteData') || '',
                // New sprite collections
                shadowSprites: JSON.parse(localStorage.getItem('shadowSprites') || '[]'),
                rpgSprites: JSON.parse(localStorage.getItem('rpgSprites') || '[]'),
                morphSprites: JSON.parse(localStorage.getItem('morphSprites') || '[]'),
                // Role-based sprites
                roleSprites: JSON.parse(localStorage.getItem('roleSprites') || '{}'),
                // Audio settings
                audioSettings: JSON.parse(localStorage.getItem('audioSettings') || '{}'),
                // User state settings
                userStates: JSON.parse(localStorage.getItem('userStates') || '{}'),
                // Per-sprite-mode View settings will be populated below
                // Legacy global values (for backward compatibility)
                fireSize: parseInt(document.getElementById('fireSize')?.value || 48),
                spriteSize: parseInt(document.getElementById('spriteSize')?.value || 40),
                chatBubbleSize: parseInt(document.getElementById('chatBubbleSize')?.value || 11),
                chatBubbleDuration: parseInt(document.getElementById('chatBubbleDuration')?.value || 3),
                spriteDefaultDirection: document.getElementById('spriteDirectionLeft')?.classList.contains('active') ? 'left' : 'right', // Legacy
                spriteDefaultDirections: (() => {
                    // Get direction for current mode
                    const currentMode = document.getElementById('spriteMode')?.value || 'circles';
                    const currentDirection = document.getElementById('spriteDirectionLeft')?.classList.contains('active') ? 'left' : 'right';
                    
                    // Load existing directions or initialize
                    const saved = JSON.parse(localStorage.getItem('campfireWidgetSettings') || '{}');
                    const directions = saved.spriteDefaultDirections || {
                        'circles': 'left',
                        'circle': 'left',
                        'rpg-characters': 'left',
                        'pixel-morphs': 'left',
                        'custom': 'left'
                    };
                    
                    // Update current mode's direction
                    directions[currentMode] = currentDirection;
                    return directions;
                })()
            };
        }

        async function loadSettings() {
            let settings = {};

            // Load from main process (single source of truth for all windows)
            if (window.electronAPI?.getSettings) {
                try {
                    settings = await window.electronAPI.getSettings() || {};
                } catch (e) {
                    console.warn('Failed to load settings from main process:', e);
                }
            } else {
                // Fallback to localStorage for web version
                const saved = localStorage.getItem('campfireWidgetSettings');
                if (saved) {
                    try {
                        settings = JSON.parse(saved);
                    } catch (e) {
                        console.error('Failed to load settings from localStorage:', e);
                    }
                }
            }

            if (Object.keys(settings).length > 0) {
                try {
                    // Handle campfire method - if there's uploaded data, default to upload method
                    const campfireData = localStorage.getItem('campfireGraphicData');
                    const hasUploadedData = campfireData && campfireData.length > 0;
                    const campfireMethod = hasUploadedData ? 'upload' : (settings.campfireMethod || 'url');

                    const campfireMethodEl = document.getElementById('campfireMethod');
                    if (campfireMethodEl) campfireMethodEl.value = campfireMethod;

                    const campfireUrlEl = document.getElementById('campfireUrl');
                    if (campfireUrlEl) campfireUrlEl.value = settings.campfireGraphicUrl || '';

                    // Set the campfire method (this shows/hides the right sections)
                    if (typeof setCampfireMethod === 'function') {
                        setCampfireMethod(campfireMethod);
                    }

                    // Update preview if there's uploaded data (always show it if it exists)
                    // campfireData already declared above, reuse it
                    if (campfireData && campfireData.length > 0) {
                        const preview = document.getElementById('campfirePreview');
                        if (preview) {
                            const isVideo = campfireData.startsWith('data:video/');
                            if (isVideo) {
                                preview.innerHTML = `<video src="${campfireData}" style="max-width: 100%; max-height: 100px; border-radius: 4px;" controls autoplay loop muted></video>`;
                            } else {
                                preview.innerHTML = `<img src="${campfireData}" style="max-width: 100%; max-height: 100px; border-radius: 4px;" alt="Campfire Graphic">`;
                            }
                        }
                    }
                    // Load hide campfire graphic setting
                    const hideCampfireGraphicEl = document.getElementById('hideCampfireGraphic');
                    if (hideCampfireGraphicEl) hideCampfireGraphicEl.checked = settings.hideCampfireGraphic || false;
                    
                    const circleAngleEl = document.getElementById('circleAngle');
                    if (circleAngleEl) circleAngleEl.value = settings.circleAngle !== undefined ? settings.circleAngle : 64;

                    const widgetBackgroundEl = document.getElementById('widgetBackground');
                    if (widgetBackgroundEl) widgetBackgroundEl.value = settings.widgetBackground || 'black';

                    if (typeof setWidgetBackground === 'function') {
                        setWidgetBackground(settings.widgetBackground || 'black', false);
                    }

                    const useNativeFrameEl = document.getElementById('useNativeFrame');
                    if (useNativeFrameEl) useNativeFrameEl.checked = settings.useNativeFrame !== false;

                    // Default to false (unchecked) if not explicitly set to true
                    // Test users checkbox removed - using buttons instead
                    const joinMethodEl = document.getElementById('joinMethod');
                    if (joinMethodEl) joinMethodEl.value = settings.joinMethod || 'command';

                    const commandEl = document.getElementById('command');
                    if (commandEl) commandEl.value = Array.isArray(settings.commands) ? settings.commands.join(', ') : (settings.command || '!join');

                    const afkCommandEl = document.getElementById('afkCommand');
                    if (afkCommandEl) afkCommandEl.value = Array.isArray(settings.afkCommands) ? settings.afkCommands.join(', ') : '!afk';

                    const lurkCommandEl = document.getElementById('lurkCommand');
                    if (lurkCommandEl) lurkCommandEl.value = Array.isArray(settings.lurkCommands) ? settings.lurkCommands.join(', ') : '!lurk';

                    const emoteNameEl = document.getElementById('emoteName');
                    if (emoteNameEl) emoteNameEl.value = settings.emoteName || '';

                    const maxUsersEl = document.getElementById('maxUsers');
                    if (maxUsersEl) maxUsersEl.value = settings.maxUsers || 20;

                    const subscriberOnlyEl = document.getElementById('subscriberOnly');
                    if (subscriberOnlyEl) subscriberOnlyEl.checked = settings.subscriberOnly || false;

                    const subTier2OnlyEl = document.getElementById('subTier2Only');
                    if (subTier2OnlyEl) subTier2OnlyEl.checked = settings.subTier2Only || false;

                    const subTier3OnlyEl = document.getElementById('subTier3Only');
                    if (subTier3OnlyEl) subTier3OnlyEl.checked = settings.subTier3Only || false;

                    const vipOnlyEl = document.getElementById('vipOnly');
                    if (vipOnlyEl) vipOnlyEl.checked = settings.vipOnly || false;

                    const primeOnlyEl = document.getElementById('primeOnly');
                    if (primeOnlyEl) primeOnlyEl.checked = settings.primeOnly || false;

                    const followersOnlyEl = document.getElementById('followersOnly');
                    if (followersOnlyEl) followersOnlyEl.checked = settings.followersOnly || false;

                    // Handle cheer settings (backward compatible with bitsRequired)
                    if (settings.cheerMethod || settings.joinMethod === 'cheer') {
                        if (joinMethodEl) joinMethodEl.value = 'cheer';
                        const cheerMethodEl = document.getElementById('cheerMethod');
                        if (cheerMethodEl) cheerMethodEl.value = settings.cheerMethod || 'bits';
                        const cheerAmountEl = document.getElementById('cheerAmount');
                        if (cheerAmountEl) cheerAmountEl.value = settings.cheerAmount || 100;
                    } else if (settings.bitsRequired && settings.bitsRequired > 0) {
                        // Legacy: convert old bitsRequired to new cheer system
                        if (joinMethodEl) joinMethodEl.value = 'cheer';
                        const cheerMethodEl = document.getElementById('cheerMethod');
                        if (cheerMethodEl) cheerMethodEl.value = 'bits';
                        const cheerAmountEl = document.getElementById('cheerAmount');
                        if (cheerAmountEl) cheerAmountEl.value = settings.bitsRequired;
                    }
                    if (typeof updateJoinMethod === 'function') updateJoinMethod();

                    const glowSizeEl = document.getElementById('glowSize');
                    if (glowSizeEl) glowSizeEl.value = settings.glowSize || 500;

                    const glowIntensityEl = document.getElementById('glowIntensity');
                    if (glowIntensityEl) glowIntensityEl.value = settings.glowIntensity || 77;

                    const shadowIntensityEl = document.getElementById('shadowIntensity');
                    if (shadowIntensityEl) shadowIntensityEl.value = settings.shadowIntensity || 91;

                    const glowSpreadEl = document.getElementById('glowSpread');
                    if (glowSpreadEl) glowSpreadEl.value = settings.glowSpread || 64;

                    const animatedGlowEl = document.getElementById('animatedGlow');
                    if (animatedGlowEl) animatedGlowEl.checked = settings.animatedGlow !== undefined ? settings.animatedGlow : true;

                    const flickerOpacityEl = document.getElementById('flickerOpacity');
                    if (flickerOpacityEl) flickerOpacityEl.value = settings.flickerOpacity !== undefined ? settings.flickerOpacity : 25;

                    const flickerSpreadEl = document.getElementById('flickerSpread');
                    if (flickerSpreadEl) flickerSpreadEl.value = settings.flickerSpread !== undefined ? settings.flickerSpread : 55;

                    if (typeof updateFlickerOpacityDisplay === 'function') updateFlickerOpacityDisplay();
                    if (typeof updateFlickerSpreadDisplay === 'function') updateFlickerSpreadDisplay();

                    const spriteModeEl = document.getElementById('spriteMode');
                    if (spriteModeEl) spriteModeEl.value = settings.spriteMode || 'circles';

                    // Load View settings (temporarily disabled per-sprite-mode to fix dashboard)
                    const fireSizeEl = document.getElementById('fireSize');
                    if (fireSizeEl) fireSizeEl.value = settings.fireSize || 48;

                    const spriteSizeEl = document.getElementById('spriteSize');
                    if (spriteSizeEl) spriteSizeEl.value = settings.spriteSize || 40;

                    const chatBubbleSizeEl = document.getElementById('chatBubbleSize');
                    if (chatBubbleSizeEl) chatBubbleSizeEl.value = settings.chatBubbleSize || 11;

                    const chatBubbleDurationEl = document.getElementById('chatBubbleDuration');
                    if (chatBubbleDurationEl) chatBubbleDurationEl.value = settings.chatBubbleDuration || 3;

                    let campfireYOffsetEl = document.getElementById('campfireYOffset');
                    if (campfireYOffsetEl) campfireYOffsetEl.value = settings.campfireYOffset !== undefined ? settings.campfireYOffset : 50;

                    let nameBubbleOffsetEl = document.getElementById('nameBubbleOffset');
                    if (nameBubbleOffsetEl) nameBubbleOffsetEl.value = settings.nameBubbleOffset !== undefined ? settings.nameBubbleOffset : 25;

                    // Load sprite collections
                    if (settings.shadowSprites && settings.shadowSprites.length > 0) {
                        localStorage.setItem('shadowSprites', JSON.stringify(settings.shadowSprites));
                    }
                    if (settings.rpgSprites && settings.rpgSprites.length > 0) {
                        localStorage.setItem('rpgSprites', JSON.stringify(settings.rpgSprites));
                    }
                    if (settings.morphSprites && settings.morphSprites.length > 0) {
                        localStorage.setItem('morphSprites', JSON.stringify(settings.morphSprites));
                    }

                    // Legacy support
                    const defaultSpritePreview = document.getElementById('defaultSpritePreview');
                    if (settings.defaultSpriteData && defaultSpritePreview) {
                        defaultSpritePreview.innerHTML = `<img src="${settings.defaultSpriteData}" style="max-width: 100%; max-height: 60px; border-radius: 4px;">`;
                    }
                    const customSpritePreview = document.getElementById('customSpritePreview');
                    if (settings.customSpriteData && customSpritePreview) {
                        customSpritePreview.innerHTML = `<img src="${settings.customSpriteData}" style="max-width: 100%; max-height: 60px; border-radius: 4px;">`;
                    }

                    // Set sprite default direction for current mode
                    const currentMode = settings.spriteMode || 'circles';
                    const directions = settings.spriteDefaultDirections || {};
                    const spriteDirection = directions[currentMode] || settings.spriteDefaultDirection || 'left';
                    if (typeof setSpriteDirection === 'function') setSpriteDirection(spriteDirection, false);

                    if (typeof updateSpriteMode === 'function') updateSpriteMode(true); // skipSave during load
                    if (typeof updateAngleDisplay === 'function') updateAngleDisplay();
                    if (typeof updateCampfireYOffsetDisplay === 'function') updateCampfireYOffsetDisplay();
                    if (typeof updateNameBubbleOffsetDisplay === 'function') updateNameBubbleOffsetDisplay();
                    if (typeof updateGlowSizeDisplay === 'function') updateGlowSizeDisplay();
                    if (typeof updateGlowIntensityDisplay === 'function') updateGlowIntensityDisplay();
                    if (typeof updateShadowIntensityDisplay === 'function') updateShadowIntensityDisplay();
                    if (typeof updateGlowSpreadDisplay === 'function') updateGlowSpreadDisplay();
                    if (typeof updateFireSizeDisplay === 'function') updateFireSizeDisplay();
                    if (typeof updateSpriteSizeDisplay === 'function') updateSpriteSizeDisplay();
                    if (typeof updateChatBubbleSizeDisplay === 'function') updateChatBubbleSizeDisplay();
                    if (typeof loadStatusIconPosition === 'function') loadStatusIconPosition();
                    if (typeof updateFullPreview === 'function') updateFullPreview();
                } catch (e) {
                    console.error('Error loading settings:', e);
                }
            } else {
                if (typeof updateGlowSizeDisplay === 'function') updateGlowSizeDisplay();
                if (typeof updateGlowIntensityDisplay === 'function') updateGlowIntensityDisplay();
                if (typeof updateShadowIntensityDisplay === 'function') updateShadowIntensityDisplay();
                if (typeof updateGlowSpreadDisplay === 'function') updateGlowSpreadDisplay();
                if (typeof updateFireSizeDisplay === 'function') updateFireSizeDisplay();
                if (typeof updateSpriteSizeDisplay === 'function') updateSpriteSizeDisplay();
                if (typeof updateChatBubbleSizeDisplay === 'function') updateChatBubbleSizeDisplay();
                if (typeof updateAngleDisplay === 'function') updateAngleDisplay();
                if (typeof updateCampfireYOffsetDisplay === 'function') updateCampfireYOffsetDisplay();
                if (typeof updateNameBubbleOffsetDisplay === 'function') updateNameBubbleOffsetDisplay();
                if (typeof updateFullPreview === 'function') updateFullPreview();
            }
        }

        function saveSettings() {
            const settings = getSettings();
            localStorage.setItem('campfireWidgetSettings', JSON.stringify(settings));
            if (window.electronAPI?.saveSettings) {
                try { window.electronAPI.saveSettings(settings); } catch (e) { console.warn('saveSettings to main failed:', e); }
            }
            window.dispatchEvent(new CustomEvent('campfireSettingsUpdate', { detail: settings }));
            updateFullPreview();
            
            const codeTab = document.getElementById('codeTab');
            if (codeTab && codeTab.classList.contains('active')) {
                generateCode();
            }
            
            showNotification('‚úÖ Settings saved!');
        }

        function saveSettingsWithNotification() {
            saveSettings(); // This already shows the notification
        }

        function resetSettings() {
            showConfirmation(
                'Reset Settings',
                'Are you sure you want to reset all settings to defaults?',
                () => {
                    localStorage.removeItem('campfireWidgetSettings');
                    showNotification('‚úÖ Settings reset! Reloading...');
                    setTimeout(() => {
                        location.reload();
                    }, 1000);
                }
            );
        }
        
        // Toggle campfire graphic and glow visibility
        function toggleCampfireVisibility(hide) {
            // Save to localStorage
            const settings = JSON.parse(localStorage.getItem('campfireWidgetSettings') || '{}');
            settings.hideCampfireGraphic = hide;
            localStorage.setItem('campfireWidgetSettings', JSON.stringify(settings));
            
            // Update preview
            updateFullPreview();
            
            // Save settings to sync with widget
            saveSettings();
        }

        function testWidget() {
            window.open('widget.html', '_blank');
        }

        async function generateCode() {
            // Wrap entire function in try-catch to prevent breaking the page
            try {
                const codeArea = document.getElementById('widgetCode');
                if (!codeArea) {
                    console.error('Code area not found');
                    return;
                }
                
                // Show loading message
                codeArea.textContent = '<!-- Generating code... -->';
                
                const settings = getSettings();
                
                let widgetCode = '';
                try {
                    const response = await fetch('widget.html');
                    widgetCode = await response.text();
                } catch (e) {
                    console.error('Could not fetch widget.html:', e);
                    codeArea.textContent = '<!-- Error: Could not load widget.html. Please ensure the file exists. -->';
                    return;
                }
                
                const baseUrl = window.location.origin + window.location.pathname.replace('dashboard.html', 'widget.html');
                const params = new URLSearchParams();
                if (settings.campfireGraphicUrl) params.append('graphic', settings.campfireGraphicUrl);
                params.append('angle', settings.circleAngle);
                params.append('joinMethod', settings.joinMethod || 'command');
                params.append('command', settings.command);
                params.append('emoteName', settings.emoteName || '');
                params.append('maxUsers', settings.maxUsers);
                if (settings.subscriberOnly) params.append('subOnly', 'true');
                if (settings.subTier2Only) params.append('subTier2', 'true');
                if (settings.subTier3Only) params.append('subTier3', 'true');
                if (settings.vipOnly) params.append('vipOnly', 'true');
                if (settings.primeOnly) params.append('primeOnly', 'true');
                // Handle cheer/payment method
                if (settings.joinMethod === 'cheer' && settings.cheerMethod) {
                    params.append('joinMethod', 'cheer');
                    params.append('cheerMethod', settings.cheerMethod);
                    params.append('cheerAmount', settings.cheerAmount || 100);
                }
                params.append('glowSize', settings.glowSize || 500);
                params.append('glowIntensity', settings.glowIntensity || 77);
                params.append('shadowIntensity', settings.shadowIntensity || 91);
                params.append('glowSpread', settings.glowSpread || 64);
                if (settings.animatedGlow !== false) params.append('animatedGlow', 'true');
                params.append('flickerOpacity', settings.flickerOpacity ?? 25);
                params.append('flickerSpread', settings.flickerSpread ?? 55);
                params.append('spriteMode', settings.spriteMode || 'default');
                params.append('fireSize', settings.fireSize || 48);
                params.append('spriteSize', settings.spriteSize || 40);
                params.append('spriteDefaultDirection', settings.spriteDefaultDirection || 'left');
                
                // Embed base64 graphics and settings directly into widget code
                // Skip embedding for now to prevent syntax errors - graphics will be loaded from localStorage
                // This prevents the script from breaking with large base64 strings
                let embeddedDataScript = '';
                
                // Only embed if data is small enough and won't break the script
                try {
                    const hasSmallCampfire = settings.campfireGraphicData && settings.campfireGraphicData.length > 0 && settings.campfireGraphicData.length < 100000;
                    const hasSmallDefault = settings.defaultSpriteData && settings.defaultSpriteData.length > 0 && settings.defaultSpriteData.length < 100000;
                    const hasSmallCustom = settings.customSpriteData && settings.customSpriteData.length > 0 && settings.customSpriteData.length < 100000;
                    
                    // Check sprite collections - calculate total size
                    const hasShadowSprites = settings.shadowSprites && settings.shadowSprites.length > 0;
                    const hasRpgSprites = settings.rpgSprites && settings.rpgSprites.length > 0;
                    const hasMorphSprites = settings.morphSprites && settings.morphSprites.length > 0;
                    
                    // Calculate total size of sprite collections
                    let spriteCollectionsSize = 0;
                    if (hasShadowSprites) {
                        const shadowJson = JSON.stringify(settings.shadowSprites);
                        spriteCollectionsSize += shadowJson.length;
                    }
                    if (hasRpgSprites) {
                        const rpgJson = JSON.stringify(settings.rpgSprites);
                        spriteCollectionsSize += rpgJson.length;
                    }
                    if (hasMorphSprites) {
                        const morphJson = JSON.stringify(settings.morphSprites);
                        spriteCollectionsSize += morphJson.length;
                    }
                    
                    // Allow sprite collections to be larger (up to 5MB total) since they're essential
                    const hasSpriteCollections = (hasShadowSprites || hasRpgSprites || hasMorphSprites) && spriteCollectionsSize < 5000000;
                    
                    if (hasSmallCampfire || hasSmallDefault || hasSmallCustom || hasSpriteCollections) {
                        embeddedDataScript = '\n<' + 'script>\n';
                        embeddedDataScript += '(function() {\n';
                        
                        if (hasSmallCampfire) {
                            try {
                                const campfireJson = JSON.stringify(settings.campfireGraphicData);
                                embeddedDataScript += 'localStorage.setItem(\'campfireGraphicData\', ' + campfireJson + ');\n';
                            } catch (e) {
                                console.warn('Could not embed campfire graphic:', e);
                            }
                        }
                        if (hasSmallDefault) {
                            try {
                                const defaultSpriteJson = JSON.stringify(settings.defaultSpriteData);
                                embeddedDataScript += 'localStorage.setItem(\'defaultSpriteData\', ' + defaultSpriteJson + ');\n';
                            } catch (e) {
                                console.warn('Could not embed default sprite:', e);
                            }
                        }
                        if (hasSmallCustom) {
                            try {
                                const customSpriteJson = JSON.stringify(settings.customSpriteData);
                                embeddedDataScript += 'localStorage.setItem(\'customSpriteData\', ' + customSpriteJson + ');\n';
                            } catch (e) {
                                console.warn('Could not embed custom sprite:', e);
                            }
                        }
                        
                        // Embed sprite collections
                        if (hasShadowSprites && spriteCollectionsSize < 5000000) {
                            try {
                                const shadowJson = JSON.stringify(settings.shadowSprites);
                                embeddedDataScript += 'localStorage.setItem(\'shadowSprites\', ' + shadowJson + ');\n';
                            } catch (e) {
                                console.warn('Could not embed shadow sprites:', e);
                            }
                        }
                        if (hasRpgSprites && spriteCollectionsSize < 5000000) {
                            try {
                                const rpgJson = JSON.stringify(settings.rpgSprites);
                                embeddedDataScript += 'localStorage.setItem(\'rpgSprites\', ' + rpgJson + ');\n';
                            } catch (e) {
                                console.warn('Could not embed RPG sprites:', e);
                            }
                        }
                        if (hasMorphSprites && spriteCollectionsSize < 5000000) {
                            try {
                                const morphJson = JSON.stringify(settings.morphSprites);
                                embeddedDataScript += 'localStorage.setItem(\'morphSprites\', ' + morphJson + ');\n';
                            } catch (e) {
                                console.warn('Could not embed morph sprites:', e);
                            }
                        }
                        
                        embeddedDataScript += '})();\n';
                        embeddedDataScript += '<' + '/script>\n';
                    }
                } catch (e) {
                    console.warn('Could not create embedded script:', e);
                    embeddedDataScript = '';
                }
                
                // Insert before closing body tag, or at end if no body tag
                // Skip embedding if it might cause issues
                try {
                    // Allow larger scripts for sprite collections (up to 10MB)
                    if (embeddedDataScript.length < 10000000) { // 10MB limit for embedded script (to accommodate sprite collections)
                        if (widgetCode.includes('</body>')) {
                            widgetCode = widgetCode.replace('</body>', embeddedDataScript + '</body>');
                        } else {
                            widgetCode += embeddedDataScript;
                        }
                    } else {
                        console.warn('Embedded script too large (' + (embeddedDataScript.length / 1000000).toFixed(2) + 'MB), skipping embedding');
                    }
                } catch (e) {
                    console.warn('Could not embed script, continuing without embedded data:', e);
                }
                
                // Build the code string safely using string concatenation
                const header = '<!-- \n' +
                    'OBS CAMPFIRE WIDGET\n' +
                    '==========================================\n\n' +
                    'INSTRUCTIONS:\n' +
                    '1. Copy the ENTIRE code below (everything between the comment markers)\n' +
                    '2. In OBS, add a Browser Source\n' +
                    '3. Set the URL to a local file path or hosted URL, OR paste this code into your streaming software\'s custom widget feature\n' +
                    '4. Save and add to your scene\n\n' +
                    'NOTE: Custom graphics (campfire and sprites) are embedded in this code.\n\n' +
                    '==========================================\n' +
                    '-->\n\n';
                
                const footer = '\n\n<!-- \n' +
                    'END OF WIDGET CODE\n' +
                    'Copy everything above this line into OBS Browser Source or your streaming software\'s custom widget feature\n\n' +
                    'NOTE: Custom graphics (campfire and sprites) are embedded in this code as base64 data.\n' +
                    '-->';
                
                // Use string concatenation to avoid issues with large strings
                // Only set textContent if codeArea exists and is visible
                if (codeArea) {
                    try {
                        codeArea.textContent = header + widgetCode + footer;
                    } catch (e) {
                        console.error('Error setting code text:', e);
                        codeArea.textContent = '<!-- Error: Code too large to display. Please use smaller graphics or refresh the page. -->';
                    }
                }
            } catch (e) {
                console.error('Error generating code:', e);
                const codeArea = document.getElementById('widgetCode');
                if (codeArea) {
                    codeArea.textContent = '<!-- \n' +
                        'ERROR: Could not generate widget code.\n\n' +
                        'Error: ' + (e.message || 'Unknown error') + '\n\n' +
                        'Please try:\n' +
                        '1. Refresh the page\n' +
                        '2. Clear your browser cache\n' +
                        '3. Try again\n\n' +
                        'If the problem persists, check the browser console for details.\n' +
                        '-->';
                }
            }
        }

        function copyCode() {
            const code = document.getElementById('widgetCode').textContent;
            navigator.clipboard.writeText(code).then(() => {
                alert('‚úÖ Code copied to clipboard!');
            }).catch(() => {
                const textarea = document.createElement('textarea');
                textarea.value = code;
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand('copy');
                document.body.removeChild(textarea);
                alert('‚úÖ Code copied to clipboard!');
            });
        }

        // Initialize - wrap in try-catch to prevent page breakage
        async function initializeDashboard() {
            try {
                console.log('[Dashboard] initializeDashboard called');
                console.log('[Dashboard] Window title:', document.title);
                console.log('[Dashboard] Is desktop app:', isDesktopApp());
                
                // ONLY enter widget-mode if this is NOT a separate dashboard window
                // Check if this is the separate settings/dashboard window by looking at the title
                const isSeparateDashboard = document.title.includes('Dashboard');
                console.log('[Dashboard] Is separate dashboard:', isSeparateDashboard);
                
                if (isSeparateDashboard) {
                    console.log('[Dashboard] This is separate dashboard window - showing normal dashboard UI');
                    
                    // Add dashboard-window class to prevent widget-mode CSS from hiding content
                    document.body.classList.add('dashboard-window');
                    document.body.classList.remove('widget-mode');
                    console.log('[Dashboard] Added dashboard-window class, removed widget-mode');
                    
                    // Force show the overlayCard and backdrop with dashboard content
                    const overlayCard = document.getElementById('overlayCard');
                    const overlayBackdrop = document.getElementById('overlayBackdrop');
                    if (overlayCard) {
                        overlayCard.style.display = 'flex';
                        overlayCard.style.visibility = 'visible';
                        overlayCard.style.opacity = '1';
                        console.log('[Dashboard] overlayCard forced visible');
                    } else {
                        console.error('[Dashboard] overlayCard not found!');
                    }
                    if (overlayBackdrop) {
                        overlayBackdrop.style.display = 'block';
                        overlayBackdrop.style.visibility = 'visible';
                        overlayBackdrop.style.opacity = '1';
                        console.log('[Dashboard] overlayBackdrop forced visible');
                    }
                }
                
                if (isDesktopApp() && !isSeparateDashboard) {
                    console.log('[Dashboard] This is the widget window, enabling widget-mode');
                    // FORCE PREVIEW AND MENU VISIBLE FIRST, before adding widget-mode
                    const panel = document.getElementById('previewPanel');
                    const iframe = document.getElementById('fullWidgetPreview');
                    const menuBar = document.getElementById('desktopMenuBar');
                    
                    if (panel) {
                        panel.classList.remove('collapsed');
                        panel.style.cssText = 'position: fixed !important; top: 0 !important; left: 0 !important; width: 100vw !important; height: 100vh !important; padding: 0 !important; border: none !important; background: #000000 !important; z-index: 1000 !important; display: flex !important; flex-direction: column !important; visibility: visible !important; opacity: 1 !important;';
                        console.log('[Dashboard] Preview panel forced visible BEFORE widget-mode');
                    }
                    
                    if (iframe) {
                        if (!iframe.src || iframe.src === '' || iframe.src === 'about:blank') {
                            iframe.src = iframe.getAttribute('data-src') || 'widget.html';
                        }
                        iframe.style.cssText = 'width: 100% !important; height: 100% !important; border: none !important; display: block !important; visibility: visible !important; opacity: 1 !important;';
                        console.log('[Dashboard] Iframe forced visible, src:', iframe.src);
                    }
                    
                    if (menuBar) {
                        menuBar.classList.add('desktop-app');
                        menuBar.style.cssText = 'position: fixed !important; top: 10px !important; left: 50% !important; transform: translateX(-50%) !important; display: flex !important; z-index: 999999 !important; opacity: 1 !important; visibility: visible !important; flex-direction: row !important; align-items: center !important; gap: 8px !important;';
                        console.log('[Dashboard] Menu bar forced visible BEFORE widget-mode');
                    }
                    
                    // NOW add widget-mode
                    document.body.classList.add('widget-mode');
                    console.log('[Dashboard] Added widget-mode class to body');
                    
                    // RE-ENFORCE visibility after widget-mode is applied AND keep enforcing
                    const enforceVisibility = () => {
                        if (panel) {
                            panel.style.cssText = 'position: fixed !important; top: 0 !important; left: 0 !important; width: 100vw !important; height: 100vh !important; padding: 0 !important; border: none !important; background: #000000 !important; z-index: 1000 !important; display: flex !important; flex-direction: column !important; visibility: visible !important; opacity: 1 !important;';
                            panel.classList.remove('collapsed');
                        }
                        if (menuBar) {
                            menuBar.style.cssText = 'position: fixed !important; top: 10px !important; left: 50% !important; transform: translateX(-50%) !important; display: flex !important; z-index: 999999 !important; opacity: 1 !important; visibility: visible !important; flex-direction: row !important; align-items: center !important; gap: 8px !important;';
                            menuBar.classList.remove('hidden');
                        }
                    };
                    
                    requestAnimationFrame(enforceVisibility);
                    // Keep enforcing every 100ms for the first 2 seconds to prevent anything from hiding it
                    let enforceCount = 0;
                    const enforceInterval = setInterval(() => {
                        enforceVisibility();
                        enforceCount++;
                        if (enforceCount >= 20) { // 20 * 100ms = 2 seconds
                            clearInterval(enforceInterval);
                        }
                    }, 100);
                }
                // Only reset graphics if there's an issue (don't auto-reset every time)
                // Check if we need to reset by looking for very large localStorage items
                try {
                    const campfireData = localStorage.getItem('campfireGraphicData');
                    if (campfireData && campfireData.length > 10000000) { // 10MB limit
                        console.log('Large graphic detected, clearing to prevent issues...');
                        localStorage.removeItem('campfireGraphicData');
                    }
                } catch (e) {
                    console.warn('Could not check campfire data:', e);
                }
                
                // Load widget code (non-blocking)
                try {
                    loadWidgetCode();
                } catch (e) {
                    console.warn('Could not load widget code:', e);
                }
                
                // Initialize live preview toggle - FORCE ON in desktop app widget-mode ONLY
                try {
                    const isSeparateDashboard = document.title.includes('Dashboard');
                    
                    if (isDesktopApp() && !isSeparateDashboard) {
                        // This is widget window - enable preview
                        livePreviewEnabled = true;
                        
                        // Force preview panel to be visible immediately and KEEP IT VISIBLE
                        const panel = document.getElementById('previewPanel');
                        const iframe = document.getElementById('fullWidgetPreview');
                        if (panel) {
                            panel.classList.remove('collapsed');
                            panel.style.cssText = 'position: fixed !important; top: 0 !important; left: 0 !important; width: 100vw !important; height: 100vh !important; padding: 0 !important; border: none !important; background: #000000 !important; z-index: 1000 !important; display: flex !important; flex-direction: column !important; visibility: visible !important; opacity: 1 !important;';
                            console.log('[Dashboard] Preview panel forced visible and locked');
                        }
                        if (iframe) {
                            if (!iframe.src || iframe.src === '' || iframe.src === 'about:blank') {
                                iframe.src = iframe.getAttribute('data-src') || 'widget.html';
                            }
                            iframe.style.cssText = 'width: 100% !important; height: 100% !important; border: none !important; display: block !important; visibility: visible !important; opacity: 1 !important;';
                        }
                    } else if (isDesktopApp() && isSeparateDashboard) {
                        // This is separate dashboard window - just load settings normally
                        console.log('[Dashboard] Separate dashboard window - loading normally');
                        livePreviewEnabled = false; // No preview in separate dashboard
                    } else {
                        livePreviewEnabled = loadLivePreviewSetting();
                        updateLivePreviewUI();
                    }
                    console.log('[Dashboard] Preview enabled:', livePreviewEnabled);
                } catch (e) {
                    console.warn('Could not initialize live preview toggle:', e);
                }
                
                enableHoverControls();

                // Always listen for full-state sync from main process
                if (window.electronAPI && window.electronAPI.onSyncFullState && !window.syncFullStateListenerSet) {
                    window.electronAPI.onSyncFullState((users) => {
                        if (!livePreviewEnabled) return;
                        const iframe = document.getElementById('fullWidgetPreview');
                        if (iframe && iframe.contentWindow) {
                            iframe.contentWindow.postMessage({
                                type: 'syncFullState',
                                users: Array.isArray(users) ? users : []
                            }, '*');
                        }
                    });
                    window.syncFullStateListenerSet = true;
                }
                
                // Initialize sprite direction to default (left) if not set
                try {
                    const saved = localStorage.getItem('campfireWidgetSettings');
                    if (!saved) {
                        setSpriteDirection('left', false);
                    }
                } catch (e) {
                    console.warn('Could not set sprite direction:', e);
                }
                
                // Load RPG sprites from folder if not already loaded
                try {
                    await loadRpgSpritesFromFolder();
                } catch (e) {
                    console.error('‚ùå Error loading RPG sprites from folder:', e);
                }
                
                // Load shadow sprites from folder if not already loaded
                try {
                    await loadShadowSpritesFromFolder();
                } catch (e) {
                    console.error('‚ùå Error loading shadow sprites from folder:', e);
                }
                
                // Load pixel morph sprites from folder if not already loaded
                try {
                    await loadMorphSpritesFromFolder();
                } catch (e) {
                    console.error('‚ùå Error loading pixel morph sprites from folder:', e);
                }
                
                // Load settings
                try {
                    await loadSettings();
                } catch (e) {
                    console.error('Error loading settings:', e);
                }
                
                // Load role-based sprite settings
                try {
                    populateRoleSpriteSelects();
                    loadRoleSpriteSettings();
                } catch (e) {
                    console.error('Error loading role sprite settings:', e);
                }
                
                // Load audio settings
                try {
                    loadAudioSettings();
                } catch (e) {
                    console.error('Error loading audio settings:', e);
                }
                
                // Load user state settings
                try {
                    loadUserStateSettings();
                } catch (e) {
                    console.error('Error loading user state settings:', e);
                }
                
                // Allow updates now that settings are loaded
                dashboardInitializing = false;
                
                // Load Twitch config if in Electron
                try {
                    if (window.electronAPI) {
                        loadTwitchConfig();
                        loadAppVersion();
                        setupUpdateChecker();
                        setupTwitchStatusListeners();
                        setupBottomConnectionIndicator();
                        window.electronAPI.onTwitchConnected(() => updateOverlayStatus(true));
                        window.electronAPI.onTwitchDisconnected(() => updateOverlayStatus(false));
                        window.electronAPI.getTwitchStatus().then(status => {
                            updateOverlayStatus(!!status?.connected);
                        }).catch(() => {
                            updateOverlayStatus(false);
                        });
                    } else {
                        // Set version for localhost/web version
                        const versionEl = document.getElementById('versionNumber');
                        if (versionEl) {
                            versionEl.textContent = 'Localhost/Web';
                        }
                    }
                } catch (e) {
                    console.warn('Could not load Twitch config:', e);
                }
                
                // Update preview when settings change
                try {
                    const circleAngleEl = document.getElementById('circleAngle');
                    const campfireUrlEl = document.getElementById('campfireUrl');
                    const commandEl = document.getElementById('command');
                    if (circleAngleEl) {
                        circleAngleEl.addEventListener('input', updateFullPreview);
                    }
                    if (campfireUrlEl) {
                        campfireUrlEl.addEventListener('input', updateFullPreview);
                    }
                    if (commandEl) {
                        commandEl.addEventListener('input', updateCurrentCommandDisplay);
                    }
                } catch (e) {
                    console.warn('Could not attach event listeners:', e);
                }
                
                console.log('‚úÖ Dashboard initialized');
            } catch (error) {
                console.error('Critical error during initialization:', error);
                // Don't show alert - just log it so page can still load
            }
        }

        // Wait for DOM to be ready before initializing
        try {
            if (document.readyState === 'loading') {
                // Listen for tab switch messages from main process
                if (window.electronAPI && window.electronAPI.onSwitchTab) {
                    window.electronAPI.onSwitchTab((tabName) => {
                        console.log('[Dashboard] Received switch-tab message:', tabName);
                        if (tabName === 'settings') {
                            // Switch to first settings tab (campfire)
                            const campfireTab = document.querySelector('.tab[onclick*="campfire"]');
                            if (campfireTab) {
                                switchSettingsTab('campfire', campfireTab);
                            }
                        } else if (tabName === 'members') {
                            // Switch to members tab
                            const membersTab = document.querySelector('.tab[onclick*="members"]');
                            if (membersTab) {
                                switchTab('members', membersTab);
                            } else {
                                switchTab('members');
                            }
                        } else {
                            // Try to switch to the tab
                            switchTab(tabName);
                        }
                    });
                }
                
                // Listen for open-settings-modal message (from main process)
                if (window.electronAPI && window.electronAPI.onOpenSettingsModal) {
                    window.electronAPI.onOpenSettingsModal(() => {
                        openSettings();
                    });
                }
                
                document.addEventListener('DOMContentLoaded', async () => {
                    await initializeDashboard();
                    updateViewerDashboardLink();
                    
                    // Load members list on startup (ensures TestUsers appear immediately, toggled off)
                    if (typeof loadDashboardMembers === 'function') {
                        await loadDashboardMembers();
                    }
                    
                    // Initialize all sliders with background fill
                    initializeAllSliders();
                    
                    // Listen for storage events to sync sprite mode dropdown when Quick Settings changes it (cross-window)
                    window.addEventListener('storage', (e) => {
                        if (e.key === 'campfireWidgetSettings') {
                            try {
                                const newSettings = JSON.parse(e.newValue);
                                if (newSettings.spriteMode !== undefined) {
                                    const dashboardSpriteModeSelect = document.getElementById('spriteMode');
                                    if (dashboardSpriteModeSelect && dashboardSpriteModeSelect.value !== newSettings.spriteMode) {
                                        // Prevent triggering onchange event by temporarily removing listener
                                        const oldOnchange = dashboardSpriteModeSelect.onchange;
                                        dashboardSpriteModeSelect.onchange = null;
                                        dashboardSpriteModeSelect.value = newSettings.spriteMode;
                                        dashboardSpriteModeSelect.onchange = oldOnchange;
                                        // Trigger UI update (show/hide sections) but don't save again
                                        if (typeof updateSpriteMode === 'function') {
                                            // Pass skipSave=true to prevent saving and triggering another event
                                            updateSpriteMode(true);
                                        }
                                    }
                                }
                            } catch (err) {
                                console.error('Error syncing sprite mode from storage:', err);
                            }
                        }
                    });
                    
                    // Enable widget-mode by default in desktop app (after initialization)
                    // BUT NOT if this is a separate dashboard window
                    const isSeparateDashboard = (window.electronAPI || navigator.userAgent.includes('Electron')) && window.location.pathname.includes('dashboard.html');
                    if ((window.electronAPI || navigator.userAgent.includes('Electron')) && !isSeparateDashboard) {
                        document.body.classList.add('widget-mode');
                        
                        // Ensure preview is enabled and loaded
                        setLivePreviewEnabled(true);
                        updateLivePreviewUI();
                        
                        // Initialize menu bar
                        setTimeout(() => initDesktopMenuBar(), 200);
                    }
                });
            } else {
                // DOM already loaded, initialize immediately
                initializeDashboard();
                updateViewerDashboardLink();
            }
        } catch (e) {
            console.error('Failed to set up initialization:', e);
            // Try to initialize anyway after a short delay
            setTimeout(initializeDashboard, 100);
        }

        // Twitch OAuth Functions
        async function loadTwitchConfig() {
            if (!window.electronAPI) {
                console.log('Not running in Electron - Twitch config unavailable');
                return;
            }
            
            try {
                const config = await window.electronAPI.getTwitchConfig();
                if (config) {
                    document.getElementById('twitchBotUsername').value = config.botUsername || '';
                    document.getElementById('twitchChannelName').value = config.channelName || '';
                    document.getElementById('twitchAccessToken').value = config.accessToken || '';
                    document.getElementById('twitchRefreshToken').value = config.refreshToken || '';
                    document.getElementById('twitchClientId').value = config.clientId || '';
                    
                    // Check if chat bot credentials are different from main (indicating separate bot was used)
                    const useSeparateBot = config.chatBotUsername && 
                                          (config.chatBotUsername !== config.botUsername || 
                                           config.chatBotAccessToken !== config.accessToken);
                    
                    document.getElementById('useSeparateChatBot').checked = useSeparateBot;
                    
                    document.getElementById('twitchChatBotUsername').value = config.chatBotUsername || '';
                    document.getElementById('twitchChatBotAccessToken').value = config.chatBotAccessToken || '';
                    document.getElementById('twitchChatBotRefreshToken').value = config.chatBotRefreshToken || '';
                    document.getElementById('twitchChatBotClientId').value = config.chatBotClientId || '';
                    
                    // Initialize chat bot inputs state (ensure it runs after DOM is ready)
                    // Pass false to indicate this is initialization, not user action
                    setTimeout(() => {
                        toggleChatBotInputs(false);
                    }, 100);
                    
                    // Update status with real-time connection check
                    setTimeout(async () => {
                        await updateTwitchStatus(config);
                    }, 500);
                }
            } catch (e) {
                console.error('Error loading Twitch config:', e);
            }
        }

        async function generateTwitchToken(accountType = 'main') {
            if (!window.electronAPI) {
                alert('This feature is only available in the desktop app. Please use the desktop application.');
                return;
            }
            
            const button = accountType === 'main' 
                ? document.getElementById('generateTwitchToken')
                : document.getElementById('generateChatBotToken');
            const tokenInput = accountType === 'main'
                ? document.getElementById('twitchAccessToken')
                : document.getElementById('twitchChatBotAccessToken');
            
            if (!button) return;
            
            button.disabled = true;
            button.textContent = '‚è≥ Opening Twitch...';
            
            try {
                const result = await window.electronAPI.generateTwitchToken(accountType);
                if (result && result.token) {
                    if (tokenInput) tokenInput.value = result.token;
                    button.textContent = accountType === 'main' ? 'üîë Generate Twitch Token' : 'üîë Generate Chat Bot Token';
                    button.disabled = false;
                    alert('Token received. Enter your Username and Channel, then click Save Configuration to connect.');
                } else {
                    button.textContent = accountType === 'main' ? 'üîë Generate Twitch Token' : 'üîë Generate Chat Bot Token';
                    button.disabled = false;
                }
            } catch (e) {
                console.error('Error generating token:', e);
                
                if (e.message === 'MANUAL_ENTRY_REQUIRED') {
                    button.textContent = accountType === 'main' ? 'üîë Generate Twitch Token' : 'üîë Generate Chat Bot Token';
                    button.disabled = false;
                    return;
                }
                
                alert('Error generating token: ' + e.message);
                button.textContent = accountType === 'main' ? 'üîë Generate Twitch Token' : 'üîë Generate Chat Bot Token';
                button.disabled = false;
            }
        }

        function toggleTokenVisibility() {
            const tokenInput = document.getElementById('twitchOAuthToken');
            const button = event.target;
            if (tokenInput.type === 'password') {
                tokenInput.type = 'text';
                button.textContent = 'üôà Hide';
            } else {
                tokenInput.type = 'password';
                button.textContent = 'üëÅÔ∏è Show';
            }
        }
        
        function toggleAccessTokenVisibility() {
            const tokenInput = document.getElementById('twitchAccessToken');
            const button = event.target;
            if (!tokenInput || !button) return;
            
            if (tokenInput.type === 'password') {
                tokenInput.type = 'text';
                button.textContent = 'üôà';
            } else {
                tokenInput.type = 'password';
                button.textContent = 'üëÅÔ∏è';
            }
        }
        
        function toggleRefreshTokenVisibility() {
            const tokenInput = document.getElementById('twitchRefreshToken');
            const button = event.target;
            if (!tokenInput || !button) return;
            
            if (tokenInput.type === 'password') {
                tokenInput.type = 'text';
                button.textContent = 'üôà';
            } else {
                tokenInput.type = 'password';
                button.textContent = 'üëÅÔ∏è';
            }
        }
        
        function toggleChatBotAccessTokenVisibility() {
            const tokenInput = document.getElementById('twitchChatBotAccessToken');
            const button = event.target;
            if (!tokenInput || !button) return;
            
            if (tokenInput.type === 'password') {
                tokenInput.type = 'text';
                button.textContent = 'üôà';
            } else {
                tokenInput.type = 'password';
                button.textContent = 'üëÅÔ∏è';
            }
        }
        
        function toggleChatBotRefreshTokenVisibility() {
            const tokenInput = document.getElementById('twitchChatBotRefreshToken');
            const button = event.target;
            if (!tokenInput || !button) return;
            
            if (tokenInput.type === 'password') {
                tokenInput.type = 'text';
                button.textContent = 'üôà';
            } else {
                tokenInput.type = 'password';
                button.textContent = 'üëÅÔ∏è';
            }
        }

        function autoFillUsernameFromChannel() {
            // Auto-fill username from channel name if username is empty or readonly
            const channelName = document.getElementById('twitchChannelName').value.trim();
            const usernameInput = document.getElementById('twitchBotUsername');
            
            // Only auto-fill if username is readonly (meaning user hasn't clicked into it)
            if (channelName && usernameInput.hasAttribute('readonly') && !usernameInput.value.trim()) {
                usernameInput.value = channelName;
            } else if (channelName && usernameInput.hasAttribute('readonly')) {
                // If username already has value, only update if it matches old channel name
                // This prevents overwriting user edits
            }
        }
        
        // Update the main account status indicator based on current state
        async function updateMainAccountStatusIndicator() {
            const statusIcon = document.getElementById('mainAccountStatusIcon');
            const statusText = document.getElementById('mainAccountStatusText');
            if (!statusIcon || !statusText) return;
            
            const username = document.getElementById('twitchBotUsername')?.value;
            const token = document.getElementById('twitchAccessToken')?.value;
            
            // Get main connection status
            let mainConnected = false;
            if (window.electronAPI) {
                try {
                    const status = await window.electronAPI.getTwitchStatus();
                    mainConnected = status && status.connected;
                } catch (e) {
                    console.error('Error getting Twitch status:', e);
                }
            }
            
            if (mainConnected && username) {
                statusIcon.textContent = 'üü¢';
                statusText.textContent = `${username} (Connected)`;
                statusText.style.color = '#4caf50';
            } else if (username && token) {
                statusIcon.textContent = 'üü°';
                statusText.textContent = `${username} (Credentials saved)`;
                statusText.style.color = '#ffc107';
            } else if (username) {
                statusIcon.textContent = 'üü†';
                statusText.textContent = `${username} (Missing token)`;
                statusText.style.color = '#ff9800';
            } else {
                statusIcon.textContent = '‚ö™';
                statusText.textContent = 'Not configured';
                statusText.style.color = '#888';
            }
        }
        
        // Update the bot status indicator based on current state
        async function updateChatBotStatusIndicator() {
            const statusIcon = document.getElementById('chatBotStatusIcon');
            const statusText = document.getElementById('chatBotStatusText');
            if (!statusIcon || !statusText) return;
            
            const checkbox = document.getElementById('useSeparateChatBot');
            const useSeparateBot = checkbox && checkbox.checked;
            
            const botUsername = document.getElementById('twitchChatBotUsername')?.value;
            const botToken = document.getElementById('twitchChatBotAccessToken')?.value;
            
            // Get main connection status
            let mainConnected = false;
            if (window.electronAPI) {
                try {
                    const status = await window.electronAPI.getTwitchStatus();
                    mainConnected = status && status.connected;
                } catch (e) {
                    console.error('Error getting Twitch status:', e);
                }
            }
            
            if (!useSeparateBot) {
                // Using main account as bot
                if (mainConnected) {
                    statusIcon.textContent = 'üü¢';
                    statusText.textContent = 'Using Main Account (Connected)';
                    statusText.style.color = '#4caf50';
                } else {
                    statusIcon.textContent = 'üîµ';
                    statusText.textContent = 'Using Main Account';
                    statusText.style.color = '#888';
                }
            } else if (botUsername && botToken) {
                // Separate bot with credentials
                if (mainConnected) {
                    statusIcon.textContent = 'üü¢';
                    statusText.textContent = `${botUsername} (Connected)`;
                    statusText.style.color = '#4caf50';
                } else {
                    statusIcon.textContent = 'üü°';
                    statusText.textContent = `${botUsername} (Credentials saved)`;
                    statusText.style.color = '#ffc107';
                }
            } else if (botUsername) {
                // Has username but no token
                statusIcon.textContent = 'üü†';
                statusText.textContent = `${botUsername} (Missing token)`;
                statusText.style.color = '#ff9800';
            } else {
                // Not configured
                statusIcon.textContent = '‚ö™';
                statusText.textContent = 'Not configured';
                statusText.style.color = '#888';
            }
        }
        
        // isUserAction: true when user clicks checkbox, false when initializing from saved config
        function toggleChatBotInputs(isUserAction = true) {
            const checkbox = document.getElementById('useSeparateChatBot');
            if (!checkbox) return;
            
            const enabled = checkbox.checked;
            
            // Get all chat bot inputs and buttons
            const inputs = [
                document.getElementById('twitchChatBotUsername'),
                document.getElementById('twitchChatBotAccessToken'),
                document.getElementById('twitchChatBotRefreshToken'),
                document.getElementById('twitchChatBotClientId'),
                document.getElementById('generateChatBotToken'),
                document.getElementById('connectChatBotBtn')
            ];
            
            // Get all chat bot visibility toggle buttons
            const buttons = [
                ...document.querySelectorAll('button[onclick="toggleChatBotAccessTokenVisibility()"]'),
                ...document.querySelectorAll('button[onclick="toggleChatBotRefreshTokenVisibility()"]')
            ];
            
            inputs.forEach(input => {
                if (input) {
                    input.disabled = !enabled;
                    if (input.tagName === 'INPUT') {
                        input.style.opacity = enabled ? '1' : '0.5';
                        input.style.cursor = enabled ? 'text' : 'not-allowed';
                    } else if (input.tagName === 'BUTTON') {
                        input.style.opacity = enabled ? '1' : '0.5';
                        input.style.cursor = enabled ? 'pointer' : 'not-allowed';
                    }
                }
            });
            
            buttons.forEach(button => {
                if (button) {
                    button.disabled = !enabled;
                    button.style.opacity = enabled ? '1' : '0.5';
                    button.style.cursor = enabled ? 'pointer' : 'not-allowed';
                }
            });
            
            // If disabled, mirror main account values
            // If enabled by user action, clear values so they can enter new bot credentials
            // If enabled during initialization (loading saved config), don't clear - values are already loaded
            if (!enabled) {
                mirrorMainAccountToChatBot();
            } else if (isUserAction) {
                // Only clear chat bot values when user manually enables the checkbox
                document.getElementById('twitchChatBotUsername').value = '';
                document.getElementById('twitchChatBotAccessToken').value = '';
                document.getElementById('twitchChatBotRefreshToken').value = '';
                document.getElementById('twitchChatBotClientId').value = '';
            }
            // When !isUserAction (initialization), keep the loaded values
            
            // Update the status indicators
            updateMainAccountStatusIndicator();
            updateChatBotStatusIndicator();
        }
        
        function mirrorMainAccountToChatBot() {
            // Mirror main account credentials to chat bot (when checkbox is unchecked)
            const mainUsername = document.getElementById('twitchBotUsername').value;
            const mainAccessToken = document.getElementById('twitchAccessToken').value;
            const mainRefreshToken = document.getElementById('twitchRefreshToken').value;
            const mainClientId = document.getElementById('twitchClientId').value;
            
            document.getElementById('twitchChatBotUsername').value = mainUsername;
            document.getElementById('twitchChatBotAccessToken').value = mainAccessToken;
            document.getElementById('twitchChatBotRefreshToken').value = mainRefreshToken;
            document.getElementById('twitchChatBotClientId').value = mainClientId;
        }
        
        async function disconnectTwitchAccount(accountType) {
            if (!window.electronAPI) return;
            
            try {
                await window.electronAPI.disconnectTwitch();
                
                // Update UI
                const statusIcon = document.getElementById('twitchStatusIcon');
                const statusText = document.getElementById('twitchStatusText');
                if (statusIcon && statusText) {
                    statusIcon.textContent = '‚ö™';
                    statusText.textContent = 'Not Connected';
                }
                
                // Hide disconnect buttons, show connect buttons
                const disconnectMainBtn = document.getElementById('disconnectMainBtn');
                const disconnectChatBotBtn = document.getElementById('disconnectChatBotBtn');
                const connectMainBtn = document.querySelector('button[onclick="connectTwitchAccount(\'main\')"]');
                const connectChatBotBtn = document.getElementById('connectChatBotBtn');
                
                if (disconnectMainBtn) disconnectMainBtn.style.display = 'none';
                if (disconnectChatBotBtn) disconnectChatBotBtn.style.display = 'none';
                if (connectMainBtn) connectMainBtn.style.display = 'block';
                if (connectChatBotBtn) connectChatBotBtn.style.display = 'block';
                
                alert('‚úÖ Disconnected from Twitch');
            } catch (e) {
                console.error('Error disconnecting:', e);
                alert('‚ùå Error disconnecting: ' + e.message);
            }
        }
        
        async function connectTwitchAccount(accountType) {
            const button = accountType === 'main' 
                ? document.querySelector('button[onclick="connectTwitchAccount(\'main\')"]')
                : document.getElementById('connectChatBotBtn');
            
            const originalText = button ? button.textContent : '';
            if (button) {
                button.disabled = true;
                button.textContent = '‚è≥ Connecting...';
            }
            
            try {
                // Track connection attempt time
                window.lastConnectAttempt = Date.now();
                
                // Save and connect (this triggers immediate reconnection in main process)
                await saveTwitchConfig();
                
                // Poll for connection status with timeout
                let attempts = 0;
                const maxAttempts = 30; // 15 seconds max (increased for slower connections)
                let connectionError = null;
                
                // Set up error listener for this connection attempt
                const errorListener = (data) => {
                    connectionError = data;
                };
                window.electronAPI.onTwitchError(errorListener);
                
                const checkConnection = async () => {
                    attempts++;
                    const status = await window.electronAPI.getTwitchStatus();
                    
                    if (status.connected) {
                        // Remove error listener
                        window.electronAPI.onTwitchError(() => {}); // Clear listener
                        if (button) {
                            button.disabled = false;
                            button.textContent = originalText;
                        }
                        updateTwitchStatusFromMain();
                        return; // Success!
                    }
                    
                    // Check if we got an error
                    if (connectionError) {
                        window.electronAPI.onTwitchError(() => {}); // Clear listener
                        if (button) {
                            button.disabled = false;
                            button.textContent = originalText;
                        }
                        updateTwitchStatusFromMain();
                        
                        let errorMsg = '‚ùå Connection failed. ';
                        if (connectionError.error && connectionError.error.toLowerCase().includes('authentication')) {
                            errorMsg = '‚ùå Authentication failed. Please check your Access Token and Client ID are correct and try again.';
                        } else if (connectionError.error) {
                            errorMsg += connectionError.error;
                        } else {
                            errorMsg += 'Please check your credentials.';
                        }
                        
                        alert(errorMsg);
                        connectionError = null; // Reset
                        return;
                    }
                    
                    if (attempts < maxAttempts) {
                        setTimeout(checkConnection, 500);
                    } else {
                        // Timeout - connection might have failed
                        window.electronAPI.onTwitchError(() => {}); // Clear listener
                        if (button) {
                            button.disabled = false;
                            button.textContent = originalText;
                        }
                        updateTwitchStatusFromMain();
                        
                        // Show helpful timeout message
                        alert('‚ö†Ô∏è Connection attempt timed out.\n\nThis usually means:\n‚Ä¢ Invalid Access Token\n‚Ä¢ Invalid Client ID\n‚Ä¢ Network connectivity issues\n\nPlease verify your credentials from the token generator and try again.');
                    }
                };
                
                // Start checking after a brief delay
                setTimeout(checkConnection, 1500);
                
            } catch (e) {
                console.error('Error connecting:', e);
                if (button) {
                    button.disabled = false;
                    button.textContent = originalText;
                }
                alert('‚ùå Error connecting: ' + e.message);
            }
        }
        
        function updateTwitchConfig() {
            // If chat bot checkbox is unchecked, mirror main account values
            const checkbox = document.getElementById('useSeparateChatBot');
            if (checkbox && !checkbox.checked) {
                mirrorMainAccountToChatBot();
            }
        }

        async function saveTwitchConfig() {
            if (!window.electronAPI) {
                alert('This feature is only available in the desktop app.');
                return;
            }
            
            const useSeparateBot = document.getElementById('useSeparateChatBot').checked;
            
            const config = {
                botUsername: document.getElementById('twitchBotUsername').value.trim(),
                channelName: document.getElementById('twitchChannelName').value.trim(),
                accessToken: document.getElementById('twitchAccessToken').value.trim(),
                refreshToken: document.getElementById('twitchRefreshToken').value.trim(),
                clientId: document.getElementById('twitchClientId').value.trim(),
                chatBotUsername: useSeparateBot ? document.getElementById('twitchChatBotUsername').value.trim() : '',
                chatBotAccessToken: useSeparateBot ? document.getElementById('twitchChatBotAccessToken').value.trim() : '',
                chatBotRefreshToken: useSeparateBot ? document.getElementById('twitchChatBotRefreshToken').value.trim() : '',
                chatBotClientId: useSeparateBot ? document.getElementById('twitchChatBotClientId').value.trim() : ''
            };
            
            // If not using separate bot, use main account credentials for chat bot
            if (!useSeparateBot) {
                config.chatBotUsername = config.botUsername;
                config.chatBotAccessToken = config.accessToken;
                config.chatBotRefreshToken = config.refreshToken;
                config.chatBotClientId = config.clientId;
            }
            
            if (!config.botUsername || !config.accessToken || !config.channelName) {
                alert('Please fill in all required fields: Username, Access Token, and Channel Name');
                return;
            }
            
            // Client ID is recommended but not strictly required for basic chat reading
            if (!config.clientId) {
                const proceed = confirm('‚ö†Ô∏è Client ID is not set. This is recommended for full functionality.\n\nContinue without Client ID?');
                if (!proceed) return;
            }
            
            // If using separate bot, validate bot credentials
            if (useSeparateBot && config.chatBotUsername && !config.chatBotAccessToken) {
                alert('‚ö†Ô∏è Chat Bot Username provided but no Access Token. Please provide both or uncheck "Use separate bot".');
                return;
            }
            
            try {
                const result = await window.electronAPI.saveTwitchConfig(config);
                if (result.success) {
                    // Configuration saved - connection will be attempted automatically
                    // Poll for connection status
                    setTimeout(async () => {
                        await updateTwitchStatusFromMain();
                    }, 1000);
                } else {
                    alert('Error saving config: ' + (result.error || 'Unknown error'));
                }
            } catch (e) {
                console.error('Error saving Twitch config:', e);
                alert('Error saving configuration: ' + e.message);
            }
        }

        async function updateTwitchStatus(config) {
            const statusIcon = document.getElementById('twitchStatusIcon');
            const statusText = document.getElementById('twitchStatusText');
            const configDisplay = document.getElementById('twitchConfigDisplay');
            const usernameDisplay = document.getElementById('twitchUsernameDisplay');
            const channelDisplay = document.getElementById('twitchChannelDisplay');
            const botAccountDisplay = document.getElementById('twitchBotAccountDisplay');
            const botAccountName = document.getElementById('twitchBotAccountName');
            
            // Check if using separate bot account
            const usingSeparateBot = config && config.chatBotUsername &&
                config.chatBotUsername !== config.botUsername;
            
            // Check actual connection status from main process
            let isConnected = false;
            if (window.electronAPI) {
                try {
                    const status = await window.electronAPI.getTwitchStatus();
                    isConnected = status.connected;
                } catch (e) {
                    console.error('Error getting Twitch status:', e);
                }
            }
            
            // Update based on actual connection status
            if (isConnected && config && config.botUsername && config.channelName) {
                statusIcon.textContent = 'üü¢';
                statusText.textContent = 'Connected';
                configDisplay.style.display = 'block';
                usernameDisplay.textContent = config.botUsername;
                channelDisplay.textContent = config.channelName;
                
                // Show bot account if using separate bot
                if (usingSeparateBot && botAccountDisplay && botAccountName) {
                    botAccountDisplay.style.display = 'block';
                    botAccountName.textContent = config.chatBotUsername;
                } else if (botAccountDisplay) {
                    botAccountDisplay.style.display = 'none';
                }
                
                const disconnectMainBtn = document.getElementById('disconnectMainBtn');
                const connectMainBtn = document.querySelector('button[onclick="connectTwitchAccount(\'main\')"]');
                if (disconnectMainBtn) disconnectMainBtn.style.display = 'block';
                if (connectMainBtn) connectMainBtn.style.display = 'none';
            } else if (config && config.botUsername && config.accessToken && config.channelName) {
                // Has credentials but not connected yet
                // Only show "Connecting..." if it hasn't been more than 15 seconds
                const lastConnectTime = window.lastConnectAttempt || 0;
                const timeSinceConnect = Date.now() - lastConnectTime;
                
                if (timeSinceConnect > 16000) {
                    statusIcon.textContent = 'üî¥';
                    statusText.textContent = 'Connection Failed';
                } else {
                    statusIcon.textContent = 'üü°';
                    statusText.textContent = 'Connecting...';
                }
                configDisplay.style.display = 'block';
                usernameDisplay.textContent = config.botUsername;
                channelDisplay.textContent = config.channelName;
                
                // Show bot account if using separate bot
                if (usingSeparateBot && botAccountDisplay && botAccountName) {
                    botAccountDisplay.style.display = 'block';
                    botAccountName.textContent = config.chatBotUsername;
                } else if (botAccountDisplay) {
                    botAccountDisplay.style.display = 'none';
                }
                
                const disconnectMainBtn = document.getElementById('disconnectMainBtn');
                const connectMainBtn = document.querySelector('button[onclick="connectTwitchAccount(\'main\')"]');
                if (disconnectMainBtn) disconnectMainBtn.style.display = 'none';
                if (connectMainBtn) connectMainBtn.style.display = 'block';
            } else if (config && config.botUsername && config.channelName) {
                // Has some credentials saved but missing token or not connecting
                statusIcon.textContent = 'üîµ';
                statusText.textContent = 'Credentials Saved';
                configDisplay.style.display = 'block';
                usernameDisplay.textContent = config.botUsername;
                channelDisplay.textContent = config.channelName;
                
                // Show bot account if using separate bot
                if (usingSeparateBot && botAccountDisplay && botAccountName) {
                    botAccountDisplay.style.display = 'block';
                    botAccountName.textContent = config.chatBotUsername;
                } else if (botAccountDisplay) {
                    botAccountDisplay.style.display = 'none';
                }
                
                const disconnectMainBtn = document.getElementById('disconnectMainBtn');
                const connectMainBtn = document.querySelector('button[onclick="connectTwitchAccount(\'main\')"]');
                if (disconnectMainBtn) disconnectMainBtn.style.display = 'none';
                if (connectMainBtn) connectMainBtn.style.display = 'block';
            } else {
                statusIcon.textContent = '‚ö™';
                statusText.textContent = 'Not Configured';
                configDisplay.style.display = 'none';
                if (botAccountDisplay) botAccountDisplay.style.display = 'none';
                const disconnectMainBtn = document.getElementById('disconnectMainBtn');
                const connectMainBtn = document.querySelector('button[onclick="connectTwitchAccount(\'main\')"]');
                if (disconnectMainBtn) disconnectMainBtn.style.display = 'none';
                if (connectMainBtn) connectMainBtn.style.display = 'block';
            }
        }
        
        // Listen for real-time connection status updates (set up on page load)
        function setupTwitchStatusListeners() {
            if (window.electronAPI) {
                window.electronAPI.onTwitchConnected(() => {
                    updateTwitchStatusFromMain();
                    
                    // Refresh members list when Twitch connects (to get chatters from API)
                    if (document.getElementById('membersList') && typeof loadDashboardMembers === 'function') {
                        console.log('[Dashboard] Twitch connected - refreshing members list');
                        loadDashboardMembers();
                    }
                    
                    // Show disconnect buttons when connected
                    const disconnectMainBtn = document.getElementById('disconnectMainBtn');
                    const disconnectChatBotBtn = document.getElementById('disconnectChatBotBtn');
                    const connectMainBtn = document.querySelector('button[onclick="connectTwitchAccount(\'main\')"]');
                    const connectChatBotBtn = document.getElementById('connectChatBotBtn');
                    
                    if (disconnectMainBtn) disconnectMainBtn.style.display = 'block';
                    if (disconnectChatBotBtn && connectChatBotBtn && !connectChatBotBtn.disabled) disconnectChatBotBtn.style.display = 'block';
                    if (connectMainBtn) connectMainBtn.style.display = 'none';
                    if (connectChatBotBtn) connectChatBotBtn.style.display = 'none';
                });
                
                window.electronAPI.onTwitchDisconnected((data) => {
                    updateTwitchStatusFromMain();
                    // Hide disconnect buttons when disconnected
                    const disconnectMainBtn = document.getElementById('disconnectMainBtn');
                    const disconnectChatBotBtn = document.getElementById('disconnectChatBotBtn');
                    const connectMainBtn = document.querySelector('button[onclick="connectTwitchAccount(\'main\')"]');
                    const connectChatBotBtn = document.getElementById('connectChatBotBtn');
                    
                    if (disconnectMainBtn) disconnectMainBtn.style.display = 'none';
                    if (disconnectChatBotBtn) disconnectChatBotBtn.style.display = 'none';
                    if (connectMainBtn) connectMainBtn.style.display = 'block';
                    if (connectChatBotBtn) connectChatBotBtn.style.display = 'block';
                    
                    // Show disconnect reason if provided
                    if (data && data.reason && !data.reason.includes('Requested')) {
                        console.log('Disconnected:', data.reason);
                    }
                });
                
                // Listen for potential members updates (viewers from Twitch chat)
                window.electronAPI.onPotentialMembersUpdate((chatters) => {
                    console.log('Potential members updated:', chatters.length, 'chatters');
                    // Refresh members list to include new chatters
                    if (document.getElementById('membersList')) {
                        loadDashboardMembers();
                    }
                });
                
                window.electronAPI.onTwitchError((data) => {
                    console.error('Twitch connection error:', data);
                    updateTwitchStatusFromMain();
                    
                    // Build comprehensive error message
                    let errorMsg = data.error || '‚ö†Ô∏è Twitch connection error.';
                    
                    // Add specific issue if available
                    if (data.specificIssue) {
                        errorMsg = `${data.error}\n\nüîç Issue: ${data.specificIssue}`;
                    }
                    
                    // Add troubleshooting steps
                    if (data.troubleshooting) {
                        errorMsg += '\n\nüîß How to fix:\n' + data.troubleshooting;
                    }
                    
                    // Add credential info for debugging (without exposing full token)
                    if (data.username || data.channel) {
                        errorMsg += '\n\nüìã Current configuration:';
                        if (data.username) {
                            errorMsg += `\n   Username: ${data.username}`;
                        }
                        if (data.channel) {
                            errorMsg += `\n   Channel: ${data.channel}`;
                        }
                    }
                    
                    // Update status to show error
                    const statusIcon = document.getElementById('twitchStatusIcon');
                    const statusText = document.getElementById('twitchStatusText');
                    if (statusIcon && statusText) {
                        statusIcon.textContent = 'üî¥';
                        statusText.textContent = data.specificIssue || 'Connection Failed';
                    }
                    
                    // Show detailed error alert with all information
                    alert(errorMsg);
                });

                // Twitch Chat tab: live messages
                window.electronAPI.onTwitchChatMessage((data) => {
                    const log = document.getElementById('twitchChatLog');
                    const empty = document.getElementById('twitchChatEmpty');
                    if (!log || !data || !data.message) return;
                    if (empty) empty.style.display = 'none';
                    const name = data.displayName || data.username || '?';
                    const color = (data.color && /^#?[0-9A-Fa-f]{6}$/.test(data.color)) ? (data.color.startsWith('#') ? data.color : '#' + data.color) : '#bf94ff';
                    const div = document.createElement('div');
                    div.className = 'chat-msg';
                    div.style.marginBottom = '6px';
                    div.style.wordBreak = 'break-word';
                    div.innerHTML = '<span class="chat-msg-user" style="color:' + color + ';font-weight:600;">' + escapeHtml(name) + '</span>: <span class="chat-msg-text">' + escapeHtml(String(data.message).slice(0, 500)) + '</span>';
                    log.appendChild(div);
                    const msgs = log.querySelectorAll(':scope > .chat-msg');
                    if (msgs.length > 500) msgs[0].remove();
                    const nearBottom = (log.scrollHeight - log.scrollTop - log.clientHeight) < 50;
                    if (nearBottom) log.scrollTop = log.scrollHeight;
                });
            }
        }
        
        async function updateTwitchStatusFromMain() {
            if (!window.electronAPI) return;
            
            try {
                const status = await window.electronAPI.getTwitchStatus();
                const config = await window.electronAPI.getTwitchConfig();
                
                const statusIcon = document.getElementById('twitchStatusIcon');
                const statusText = document.getElementById('twitchStatusText');
                const configDisplay = document.getElementById('twitchConfigDisplay');
                const usernameDisplay = document.getElementById('twitchUsernameDisplay');
                const channelDisplay = document.getElementById('twitchChannelDisplay');
                const botAccountDisplay = document.getElementById('twitchBotAccountDisplay');
                const botAccountName = document.getElementById('twitchBotAccountName');
                
                // Check if using separate bot account
                const usingSeparateBot = config && config.chatBotUsername &&
                    config.chatBotUsername !== config.botUsername;
                
                    if (status.connected && config && config.botUsername && config.channelName) {
                        statusIcon.textContent = 'üü¢';
                        statusText.textContent = 'Connected';
                        configDisplay.style.display = 'block';
                        usernameDisplay.textContent = config.botUsername;
                        channelDisplay.textContent = config.channelName;
                        
                        // Show bot account if using separate bot
                        if (usingSeparateBot && botAccountDisplay && botAccountName) {
                            botAccountDisplay.style.display = 'block';
                            botAccountName.textContent = config.chatBotUsername;
                        } else if (botAccountDisplay) {
                            botAccountDisplay.style.display = 'none';
                        }
                        
                        // Show disconnect buttons, hide connect buttons
                        const disconnectMainBtn = document.getElementById('disconnectMainBtn');
                        const disconnectChatBotBtn = document.getElementById('disconnectChatBotBtn');
                        const connectMainBtn = document.querySelector('button[onclick="connectTwitchAccount(\'main\')"]');
                        const connectChatBotBtn = document.getElementById('connectChatBotBtn');
                        
                        if (disconnectMainBtn) disconnectMainBtn.style.display = 'block';
                        if (connectMainBtn) connectMainBtn.style.display = 'none';
                        
                        // For bot account: show disconnect if using separate bot AND connected
                        if (usingSeparateBot) {
                            if (disconnectChatBotBtn) disconnectChatBotBtn.style.display = 'block';
                            if (connectChatBotBtn) connectChatBotBtn.style.display = 'none';
                        }
                } else if (config && config.botUsername && config.accessToken && config.channelName) {
                    statusIcon.textContent = 'üü°';
                    statusText.textContent = 'Connecting...';
                    configDisplay.style.display = 'block';
                    usernameDisplay.textContent = config.botUsername;
                    channelDisplay.textContent = config.channelName;
                    
                    // Show bot account if using separate bot
                    if (usingSeparateBot && botAccountDisplay && botAccountName) {
                        botAccountDisplay.style.display = 'block';
                        botAccountName.textContent = config.chatBotUsername;
                    } else if (botAccountDisplay) {
                        botAccountDisplay.style.display = 'none';
                    }
                } else if (config && config.botUsername && config.channelName) {
                    // Has some credentials saved but missing token or not connecting
                    statusIcon.textContent = 'üîµ';
                    statusText.textContent = 'Credentials Saved';
                    configDisplay.style.display = 'block';
                    usernameDisplay.textContent = config.botUsername;
                    channelDisplay.textContent = config.channelName;
                    
                    // Show bot account if using separate bot
                    if (usingSeparateBot && botAccountDisplay && botAccountName) {
                        botAccountDisplay.style.display = 'block';
                        botAccountName.textContent = config.chatBotUsername;
                    } else if (botAccountDisplay) {
                        botAccountDisplay.style.display = 'none';
                    }
                } else {
                    statusIcon.textContent = '‚ö™';
                    statusText.textContent = 'Not Configured';
                    configDisplay.style.display = 'none';
                    if (botAccountDisplay) botAccountDisplay.style.display = 'none';
                }
                
                // Also update the account status indicators
                updateMainAccountStatusIndicator();
                updateChatBotStatusIndicator();
            } catch (e) {
                console.error('Error updating Twitch status:', e);
            }
        }


        async function loadAppVersion() {
            if (!window.electronAPI) {
                const versionEl = document.getElementById('versionNumber');
                if (versionEl) {
                    versionEl.textContent = 'Localhost/Web';
                }
                return;
            }
            
            try {
                const result = await window.electronAPI.getAppVersion();
                if (result && result.version) {
                    const versionEl = document.getElementById('versionNumber');
                    if (versionEl) {
                        // Format version with 'v' prefix (e.g., "0.0.3" -> "v0.0.3")
                        const version = result.version.startsWith('v') ? result.version : `v${result.version}`;
                        versionEl.textContent = version;
                    }
                } else {
                    const versionEl = document.getElementById('versionNumber');
                    if (versionEl) {
                        versionEl.textContent = 'Unknown';
                    }
                }
            } catch (e) {
                console.error('Error loading app version:', e);
                const versionEl = document.getElementById('versionNumber');
                if (versionEl) {
                    versionEl.textContent = 'Error loading version';
                }
            }
        }

        // Prevent duplicate listeners
        let updateCheckerSetup = false;
        
        function setupUpdateChecker() {
            if (!window.electronAPI) return;
            if (updateCheckerSetup) {
                console.log('Update checker already setup, skipping duplicate registration');
                return;
            }
            updateCheckerSetup = true;
            
            // Listen for update status
            window.electronAPI.onUpdateStatus((data) => {
                if (data.status === 'checking') {
                    // Show checking status
                    console.log('Checking for updates...');
                    showNotification('üîç Checking for updates...');
                } else if (data.status === 'available') {
                    // Get version from DOM (already has 'v' prefix) or from data (needs 'v' prefix)
                    const domVersion = document.getElementById('versionNumber')?.textContent || '';
                    const dataVersion = data.version || '';
                    // Use DOM version if available (already formatted), otherwise format data version
                    const currentVersion = domVersion || (dataVersion ? `v${dataVersion}` : 'current');
                    const newVersion = dataVersion ? `v${dataVersion}` : 'new version';
                    if (confirm(`Update available: ${newVersion}\n\nYou have ${currentVersion}\n\nWould you like to download the update?`)) {
                        downloadUpdate();
                    }
                } else if (data.status === 'not-available') {
                    // Show fade-in/fade-out notification instead of alert
                    // Get version from DOM (already has 'v' prefix) or from data (needs 'v' prefix)
                    const domVersion = document.getElementById('versionNumber')?.textContent || '';
                    const dataVersion = data.version || '';
                    // Use DOM version if available (already formatted), otherwise format data version
                    const currentVersion = domVersion || (dataVersion ? `v${dataVersion}` : 'current');
                    showNotification(`‚úÖ You're up to date! (${currentVersion})`);
                } else if (data.status === 'downloaded') {
                    if (confirm(`Update v${data.version} downloaded and ready to install!\n\nInstall now? The app will restart.`)) {
                        installUpdate();
                    }
                } else if (data.status === 'error') {
                    // Check if it's a 404 (release not found) vs other errors
                    const errorMsg = data.error || 'Unknown error';
                    if (errorMsg.includes('404') || errorMsg.includes('not found')) {
                        // 404 could mean:
                        // 1. Repository doesn't exist or is private
                        // 2. No releases published yet
                        // 3. Repository name/owner is incorrect
                        showNotification('‚ÑπÔ∏è Unable to check for updates. Please verify:\n‚Ä¢ Repository exists and is public\n‚Ä¢ At least one release is published\n‚Ä¢ Repository name is correct');
                    } else {
                        showNotification(`‚ùå Update error: ${errorMsg}`);
                    }
                }
            });
            
            // Listen for download progress
            window.electronAPI.onUpdateProgress((progress) => {
                console.log(`Download progress: ${progress.percent.toFixed(1)}%`);
            });
        }

        async function checkForUpdates() {
            if (!window.electronAPI) {
                showNotification('This feature is only available in the desktop app.');
                return;
            }
            
            try {
                const result = await window.electronAPI.checkForUpdates();
                // All update status messages (including errors) are handled by onUpdateStatus listener
                // Only log here, don't show duplicate notifications
                if (result && result.success) {
                    console.log('Update check initiated');
                } else {
                    // The onUpdateStatus listener will handle showing the error
                    console.log('Update check returned:', result);
                }
            } catch (e) {
                // Only handle exceptions that occur before update check is initiated
                // (e.g., IPC call failed, not update-related errors)
                console.error('Error initiating update check:', e);
                showNotification(`‚ùå Failed to check for updates: ${e.message || 'Unknown error'}`);
            }
        }

        async function downloadUpdate() {
            if (!window.electronAPI) return;
            
            try {
                const result = await window.electronAPI.downloadUpdate();
                if (!result || !result.success) {
                    alert('Error downloading update: ' + (result?.error || 'Unknown error'));
                }
            } catch (e) {
                console.error('Error downloading update:', e);
                alert('Error downloading update: ' + e.message);
            }
        }

        async function installUpdate() {
            if (!window.electronAPI) return;
            
            try {
                const result = await window.electronAPI.installUpdate();
                if (!result || !result.success) {
                    alert('Error installing update: ' + (result?.error || 'Unknown error'));
                }
            } catch (e) {
                console.error('Error installing update:', e);
                alert('Error installing update: ' + e.message);
            }
        }

        // ============================================
        // SETTINGS MODAL - Sprite Path Management
        // ============================================
        
        let currentSpritePathInfo = null;
        
        async function openSettings() {
            const modal = document.getElementById('settingsModal');
            modal.classList.add('active');
            await loadSpritePathInfo();
            await loadWindowDimensionsInfo();
        }
        
        function closeSettings() {
            const modal = document.getElementById('settingsModal');
            modal.classList.remove('active');
        }
        
        async function loadSpritePathInfo() {
            if (!window.electronAPI) {
                document.getElementById('spritePathDisplay').textContent = 'Not available (Web version)';
                document.getElementById('spritePathInfo').textContent = 'Sprite path settings are only available in the desktop app.';
                return;
            }
            
            try {
                const pathInfo = await window.electronAPI.getSpritePath();
                currentSpritePathInfo = pathInfo;
                
                const display = document.getElementById('spritePathDisplay');
                const info = document.getElementById('spritePathInfo');
                const resetBtn = document.getElementById('resetSpritePathBtn');
                
                display.textContent = pathInfo.effectivePath || 'Not found';
                
                if (pathInfo.isCustom) {
                    info.innerHTML = `‚úÖ Using custom path<br>Default: ${pathInfo.defaultPath}`;
                    resetBtn.style.display = 'block';
                } else {
                    info.innerHTML = `‚úÖ Using default path`;
                    resetBtn.style.display = 'none';
                }
            } catch (error) {
                console.error('Error loading sprite path info:', error);
                document.getElementById('spritePathDisplay').textContent = 'Error loading path';
            }
        }
        
        // ============================================
        // SETTINGS MODAL - Window Dimensions Management
        // ============================================
        
        let currentWindowDimensions = null;
        
        async function loadWindowDimensionsInfo() {
            if (!window.electronAPI) {
                document.getElementById('windowWidth').value = '1920';
                document.getElementById('windowHeight').value = '1080';
                document.getElementById('windowDimensionsInfo').textContent = 'Not available (Web version)';
                document.getElementById('toggleLockBtn').style.display = 'none';
                return;
            }
            
            try {
                const dimensions = await window.electronAPI.getWindowDimensions();
                currentWindowDimensions = dimensions;
                
                document.getElementById('windowWidth').value = dimensions.width || 1920;
                document.getElementById('windowHeight').value = dimensions.height || 1080;
                
                const toggleBtn = document.getElementById('toggleLockBtn');
                if (toggleBtn) {
                    toggleBtn.textContent = dimensions.locked ? 'üîí Locked' : 'üîì Unlocked';
                    toggleBtn.style.background = dimensions.locked ? '#666' : '#444';
                    
                    // Disable inputs when locked
                    document.getElementById('windowWidth').disabled = dimensions.locked;
                    document.getElementById('windowHeight').disabled = dimensions.locked;
                }
                
                const info = document.getElementById('windowDimensionsInfo');
                if (info) {
                    info.textContent = dimensions.locked 
                        ? 'Window is locked - unlock to adjust dimensions'
                        : 'Window is unlocked - you can resize the window directly';
                }
            } catch (error) {
                console.error('Error loading window dimensions:', error);
                document.getElementById('windowDimensionsInfo').textContent = 'Error loading dimensions';
            }
        }
        
        async function toggleWindowLock() {
            if (!window.electronAPI) {
                showNotification('‚ùå Window settings are only available in the desktop app.');
                return;
            }
            
            try {
                const result = await window.electronAPI.toggleWindowLock();
                if (result.locked !== undefined) {
                    await loadWindowDimensionsInfo();
                    showNotification(result.locked ? 'üîí Window locked' : 'üîì Window unlocked');
                }
            } catch (error) {
                console.error('Error toggling window lock:', error);
                showNotification(`‚ùå Error: ${error.message || 'Unknown error'}`);
            }
        }
        
        async function applyWindowDimensions() {
            if (!window.electronAPI) {
                showNotification('‚ùå Window settings are only available in the desktop app.');
                return;
            }
            
            const width = parseInt(document.getElementById('windowWidth').value);
            const height = parseInt(document.getElementById('windowHeight').value);
            
            if (isNaN(width) || isNaN(height) || width < 600 || height < 600) {
                showNotification('‚ùå Please enter valid dimensions (min: 600x600)');
                return;
            }
            
            try {
                const result = await window.electronAPI.setWindowDimensions({ width, height });
                if (result.success) {
                    showNotification(`‚úÖ Window dimensions updated to ${width}x${height}`);
                    await loadWindowDimensionsInfo();
                } else {
                    showNotification(`‚ùå ${result.error || 'Failed to update dimensions'}`);
                }
            } catch (error) {
                console.error('Error setting window dimensions:', error);
                showNotification(`‚ùå Error: ${error.message || 'Unknown error'}`);
            }
        }
        
        async function browseSpritePath() {
            if (!window.electronAPI) {
                showNotification('‚ùå Sprite path settings are only available in the desktop app.');
                return;
            }
            
            try {
                const result = await window.electronAPI.setSpritePath();
                
                if (result.canceled) {
                    return; // User canceled
                }
                
                if (result.success) {
                    showNotification(`‚úÖ Sprite path updated!\n\n${result.path}\n\nPlease restart the server for changes to take effect.`);
                    await loadSpritePathInfo();
                    
                    // Notify user they may need to restart
                    if (confirm('Sprite path updated! The server needs to be restarted for changes to take effect.\n\nWould you like to restart the server now?')) {
                        // Stop and start server
                        if (window.electronAPI) {
                            await window.electronAPI.stopServer();
                            setTimeout(async () => {
                                await window.electronAPI.startServer();
                                showNotification('‚úÖ Server restarted with new sprite path!');
                            }, 1000);
                        }
                    }
                } else {
                    showNotification(`‚ùå ${result.error || 'Failed to set sprite path'}`);
                }
            } catch (error) {
                console.error('Error setting sprite path:', error);
                showNotification(`‚ùå Error: ${error.message || 'Unknown error'}`);
            }
        }
        
        async function resetSpritePath() {
            if (!window.electronAPI) {
                showNotification('‚ùå Sprite path settings are only available in the desktop app.');
                return;
            }
            
            if (!confirm('Reset sprite path to default?\n\nThis will use the automatically detected path.')) {
                return;
            }
            
            try {
                const result = await window.electronAPI.resetSpritePath();
                
                if (result.success) {
                    showNotification(`‚úÖ Sprite path reset to default!\n\n${result.path}\n\nPlease restart the server for changes to take effect.`);
                    await loadSpritePathInfo();
                    
                    // Notify user they may need to restart
                    if (confirm('Sprite path reset! The server needs to be restarted for changes to take effect.\n\nWould you like to restart the server now?')) {
                        // Stop and start server
                        if (window.electronAPI) {
                            await window.electronAPI.stopServer();
                            setTimeout(async () => {
                                await window.electronAPI.startServer();
                                showNotification('‚úÖ Server restarted with default sprite path!');
                            }, 1000);
                        }
                    }
                } else {
                    showNotification(`‚ùå ${result.error || 'Failed to reset sprite path'}`);
                }
            } catch (error) {
                console.error('Error resetting sprite path:', error);
                showNotification(`‚ùå Error: ${error.message || 'Unknown error'}`);
            }
        }
        
        // Listen for sprite path changes from Electron
        if (window.electronAPI) {
            window.electronAPI.onSpritePathChanged((data) => {
                console.log('Sprite path changed:', data);
                if (document.getElementById('settingsModal').classList.contains('active')) {
                    loadSpritePathInfo();
                }
            });
        }
        
        async function shutdownWidget() {
            try {
                // Send shutdown message to widget
                const widgetIframe = document.getElementById('widgetPreview');
                if (widgetIframe && widgetIframe.contentWindow) {
                    widgetIframe.contentWindow.postMessage({ type: 'shutdown' }, '*');
                }
                
                // If in Electron, also shutdown the app
                if (window.electronAPI) {
                    try {
                        await window.electronAPI.shutdownApp();
                    } catch (e) {
                        console.warn('Could not shutdown Electron app:', e);
                    }
                }
                
                // Stop local server if running (for localhost version)
                try {
                    const response = await fetch('http://localhost:3000/api/shutdown', {
                        method: 'POST'
                    });
                    if (response.ok) {
                        console.log('‚úÖ Server shutdown requested');
                    }
                } catch (e) {
                    console.warn('Could not shutdown server:', e);
                }
                
                // Clear widget preview
                if (widgetIframe) {
                    widgetIframe.src = 'about:blank';
                }
                
                alert('‚úÖ Widget and servers shutdown complete');
            } catch (error) {
                console.error('Error shutting down:', error);
                alert('‚ö†Ô∏è Some components may not have shutdown properly. Check console for details.');
            }
        }

        // Member management functions
        let memberManagementInterval = null;
        let memberMuteStates = {}; // Track muted users
        let memberStillStates = {}; // Track users who can't move

        // Load and display members (same as members window)
        let allMembers = [];
        let activeUsers = [];
        let memberVirtualList = null; // VirtualList instance for performance
        const DASH_ACTIVE_WINDOW_MS = 10 * 60 * 1000; // "recently active in chat" window
        let _dashboardMembersStatusInterval = null;
        
        async function loadDashboardMembers() {
            const membersList = document.getElementById('membersList');
            if (!membersList) return;
            
            if (!window.electronAPI) {
                membersList.innerHTML = '<div class="empty-state">Not available (Web version)</div>';
                return;
            }

            // Show loading state
            membersList.innerHTML = '<div class="empty-state">Loading members...</div>';
            
            try {
                // Load data with individual error handling
                let active = [], widgetDisplay = [], potential = [];

                try {
                    active = await window.electronAPI.getActiveUsers();
                } catch (e) {
                    console.warn('Failed to load active users:', e);
                }

                try {
                    if (window.electronAPI.getWidgetDisplayUsers) {
                        widgetDisplay = await window.electronAPI.getWidgetDisplayUsers();
                    }
                } catch (e) {
                    console.warn('Failed to load widget display users:', e);
                }

                try {
                    potential = await window.electronAPI.getPotentialMembers();
                } catch (e) {
                    console.warn('Failed to load potential members:', e);
                }

                // Check if we got at least some data
                if (active.length === 0 && widgetDisplay.length === 0 && potential.length === 0) {
                    // If no data, retry multiple times with increasing delay
                    // This handles the case where the widget/server haven't finished initializing yet
                    if (!loadDashboardMembers._retryCount) {
                        loadDashboardMembers._retryCount = 1;
                    } else {
                        loadDashboardMembers._retryCount++;
                    }

                    if (loadDashboardMembers._retryCount <= 5) { // Try up to 5 times
                        const delay = Math.min(1000 * loadDashboardMembers._retryCount, 5000); // 1s, 2s, 3s, 4s, 5s
                        console.log(`No member data available (attempt ${loadDashboardMembers._retryCount}/5), retrying in ${delay/1000}s...`);
                        setTimeout(() => {
                            loadDashboardMembers();
                        }, delay);
                        return;
                    }
                    throw new Error('All member data sources failed to load after 5 attempts');
                }

                activeUsers = active;
                const userMap = new Map();
                const usernameToKey = new Map(); // usernameLower -> canonical key (prefer userId when known)
                const normName = (v) => (v ? String(v).toLowerCase() : '');
                const normId = (v) => (v == null ? '' : String(v));
                const keyFor = (userId, username) => {
                    const id = normId(userId);
                    const name = normName(username);
                    if (id) {
                        if (name) usernameToKey.set(name, id);
                        return id;
                    }
                    if (name) return usernameToKey.get(name) || name;
                    return '';
                };
                const upsert = (rec) => {
                    const key = keyFor(rec.userId, rec.username);
                    if (!key) return;
                    const existing = userMap.get(key);
                    if (existing) {
                        // Merge fields (prefer "joined", preserve username)
                        existing.joined = !!existing.joined || !!rec.joined;
                        if (rec.username) existing.username = existing.username || rec.username;
                        existing.userId = key; // keep canonical key
                        if (rec.color) existing.color = rec.color;
                        if (rec.twitchColor) existing.twitchColor = rec.twitchColor;
                        if (rec.lastMessage) existing.lastMessage = Math.max(existing.lastMessage || 0, rec.lastMessage);
                        // Preserve user state info from widget
                        if (rec.userState) existing.userState = rec.userState;
                        if (rec.isLurking !== undefined) existing.isLurking = rec.isLurking;
                        if (rec.persisted !== undefined) existing.persisted = rec.persisted;
                        // Prefer stronger source ordering
                        const rank = { main: 3, widget: 2, potential: 1, test: 0 };
                        if ((rank[rec.source] || 0) > (rank[existing.source] || 0)) existing.source = rec.source;
                    } else {
                        userMap.set(key, { ...rec, userId: key });
                    }
                };

                // Presence sets for restored calculation (a user is "restored" if in widget but not in main and not in chatters)
                const activeSet = new Set();
                const potentialSet = new Set();
                const widgetSet = new Set();
                const addPresence = (set, userId, username) => {
                    const id = normId(userId);
                    const name = normName(username);
                    if (id) set.add(id);
                    if (name) set.add(name);
                };
                active.forEach(u => addPresence(activeSet, u.userId, u.username));
                potential.forEach(p => addPresence(potentialSet, p.userId, p.username));
                (widgetDisplay || []).forEach(w => addPresence(widgetSet, w.userId, w.username));

                // 1) Main's activeUsers
                active.forEach(u => upsert({ username: u.username, userId: u.userId, joined: true, restored: false, source: 'main', twitchColor: u.twitchColor || null, color: u.color || null }));
                // 2) Widget's actual display users (includes restored from localStorage)
                (widgetDisplay || []).forEach(u => upsert({
                    username: u.username,
                    userId: u.userId,
                    joined: true,
                    restored: true,
                    source: 'widget',
                    twitchColor: u.twitchColor || null,
                    color: u.color || null,
                    userState: u.state || 'JOINED',
                    isLurking: u.isLurking || false,
                    persisted: u.persisted || false
                }));
                // 3) Potential (chatters)
                potential.forEach(p => upsert({ username: p.username, userId: p.userId, joined: false, restored: false, source: 'potential', twitchColor: p.color || null, lastMessage: p.lastMessage || null }));
                
                const testUsers = ['TestUser1', 'TestUser2', 'TestUser3'];
                testUsers.forEach(testUser => {
                    upsert({ username: testUser, userId: testUser.toLowerCase(), joined: false, restored: false, source: 'test' });
                });

                // ========== FIX FOR RESTORED USERS DUPLICATES ==========
                // Clean up userMap to prevent duplicates when users have both userId and username entries
                const cleanedUserMap = new Map();
                const usernameToUserId = new Map();

                // First pass: build username -> userId mapping
                for (const [key, user] of userMap.entries()) {
                    const id = normId(user.userId);
                    const name = normName(user.username);
                    if (id && name) {
                        usernameToUserId.set(name, id);
                    }
                }

                // Second pass: merge entries and prevent duplicates
                for (const [key, user] of userMap.entries()) {
                    const id = normId(user.userId);
                    const name = normName(user.username);

                    // If this is a username-only entry and we have a userId for it, merge it
                    if (!id && name && usernameToUserId.has(name)) {
                        const realId = usernameToUserId.get(name);
                        const userIdEntry = userMap.get(realId);
                        if (userIdEntry) {
                            // Merge properties from username-only entry into userId entry
                            userIdEntry.username = userIdEntry.username || user.username;
                            userIdEntry.joined = userIdEntry.joined || user.joined;
                            userIdEntry.color = userIdEntry.color || user.color;
                            userIdEntry.twitchColor = userIdEntry.twitchColor || user.twitchColor;
                            if (user.lastMessage) {
                                userIdEntry.lastMessage = Math.max(userIdEntry.lastMessage || 0, user.lastMessage);
                            }
                            // Preserve the stronger source
                            const rank = { main: 3, widget: 2, potential: 1, test: 0 };
                            if ((rank[user.source] || 0) > (rank[userIdEntry.source] || 0)) {
                                userIdEntry.source = user.source;
                            }
                        }
                        continue; // Skip adding this username-only entry (it's been merged)
                    }

                    // Add to cleaned map
                    cleanedUserMap.set(key, user);
                }

                console.log('[Deduplication] Original entries:', userMap.size, 'Cleaned entries:', cleanedUserMap.size);
                // ========== END FIX ==========

                // Finalize restored flag after merging (avoid duplicate rows from userId vs username keys)
                allMembers = Array.from(cleanedUserMap.values()).map(m => {
                    const id = normId(m.userId);
                    const name = normName(m.username);
                    const inWidget = widgetSet.has(id) || (name && widgetSet.has(name));
                    const inActive = activeSet.has(id) || (name && activeSet.has(name));
                    const inPotential = potentialSet.has(id) || (name && potentialSet.has(name));
                    return {
                        ...m,
                        inCampfire: !!(inWidget || inActive),
                        inChat: !!inPotential,
                        restored: !!(inWidget && !inActive && !inPotential)
                    };
                });
                renderDashboardMembers();
                if (!_dashboardMembersStatusInterval) {
                    _dashboardMembersStatusInterval = setInterval(() => {
                        try { renderDashboardMembers(); } catch (e) { /* ignore */ }
                    }, 30 * 1000);
                }
            } catch (error) {
                console.error('Error loading members:', error);

                // If we got an error, retry multiple times with increasing delay
                // This handles the case where the widget hasn't finished initializing yet
                if (!loadDashboardMembers._retryCount) {
                    loadDashboardMembers._retryCount = 1;
                } else {
                    loadDashboardMembers._retryCount++;
                }

                if (loadDashboardMembers._retryCount <= 5) { // Try up to 5 times
                    const delay = Math.min(1000 * loadDashboardMembers._retryCount, 5000); // 1s, 2s, 3s, 4s, 5s
                    console.log(`Error loading members (attempt ${loadDashboardMembers._retryCount}/5), retrying in ${delay/1000}s...`);
                    setTimeout(() => {
                        loadDashboardMembers();
                    }, delay);
                    return;
                }

                loadDashboardMembers._retryCount = 0; // Reset for next manual call
                membersList.innerHTML = '<div class="empty-state">Error loading members</div>';
            }
        }
        
        function renderDashboardMembers() {
            const container = document.getElementById('membersList');
            if (!container) return;

            if (allMembers.length === 0) {
                container.innerHTML = '<div class="empty-state">No members found</div>';
                return;
            }

            // Render all members directly (no VirtualList library required)
            container.innerHTML = '';
            allMembers.forEach((member, index) => {
                const element = createMemberElement(member, index);
                container.appendChild(element);
            });
        }

        // Default bot message IDs (built-in commands) - these cannot be deleted
        const DEFAULT_BOT_MESSAGE_IDS = [
            // REGULAR
            'help',
            // STATE
            'join', 'leave', 'afk', 'lurk', 'return',
            // MOVEMENT
            'cw', 'ccw', 'still', 'roam', 'wander',
            // APPEARANCE
            'changesprite', 'changecolor', 'next', 'back', 'random', 'reset',
            // ANIMATION
            'spin', 'dance', 'sparkle',
            // AUTO STATE
            'sleepy', 'auto-afk', 'auto-return', 'auto-leave',
            // APP
            'who', 'duel', 'roll'
        ];

        // Command category IDs
        const STATE_COMMAND_IDS = ['join', 'leave', 'afk', 'lurk', 'return'];
        const MOVEMENT_COMMAND_IDS = ['cw', 'ccw', 'still', 'roam', 'wander'];
        const APPEARANCE_COMMAND_IDS = ['changesprite', 'changecolor', 'next', 'back', 'random', 'reset'];
        const ANIMATION_COMMAND_IDS = ['spin', 'dance', 'sparkle'];
        const AUTO_STATE_COMMAND_IDS = ['sleepy', 'auto-afk', 'auto-return', 'auto-leave'];
        const APP_COMMAND_IDS = ['who', 'duel', 'roll'];

        // Default state commands (with cooldown properties)
        const defaultStateCommands = [
            { id: 'join', name: 'Join Command', commands: ['!join'], command: '!join', message: '{username} joined the campfire!', enabled: true, silent: false, respondAllChats: true, allowNonCampers: false, isDefault: true, category: 'STATE', cooldown: 3, cooldownEnabled: true, cooldownType: 'per-user' },
            { id: 'leave', name: 'Leave Command', commands: ['!leave', '!exit'], command: '!leave', message: '{username} left the campfire.', enabled: true, silent: false, respondAllChats: true, allowNonCampers: false, isDefault: true, category: 'STATE', cooldown: 3, cooldownEnabled: true, cooldownType: 'per-user' },
            { id: 'afk', name: 'AFK Command', commands: ['!afk'], command: '!afk', message: '{username} went AFK üí§', enabled: true, silent: false, respondAllChats: true, allowNonCampers: true, isDefault: true, category: 'STATE', cooldown: 3, cooldownEnabled: true, cooldownType: 'per-user' },
            { id: 'lurk', name: 'Lurk Command', commands: ['!lurk'], command: '!lurk', message: '{username} is now lurking üëÅÔ∏è', enabled: true, silent: false, respondAllChats: true, allowNonCampers: true, isDefault: true, category: 'STATE', cooldown: 3, cooldownEnabled: true, cooldownType: 'per-user' }
        ];

        // Default APP commands (special app-specific features)
        const defaultAppCommands = [
            { id: 'who', name: 'Who Command', commands: ['!who'], command: '!who', message: 'üî• Around the campfire:', enabled: true, silent: false, respondAllChats: true, allowNonCampers: true, isDefault: true, category: 'APP', cooldown: 30, cooldownEnabled: true, cooldownType: 'global', undeletable: true, action: 'handleWhoCommand', userLineFormat: '{icon} {username}', userSeparator: ' ‚Ä¢ ', stateIcons: { JOINED: 'üî•', ACTIVE: 'üî•', SLEEPY: 'üò¥', AFK: 'üí§', LURK: 'üëÅÔ∏è', BOT: 'ü§ñ' }, stateFilters: { JOINED: true, ACTIVE: true, SLEEPY: true, AFK: true, LURK: true } },
            { id: 'return', name: 'Return Command', commands: ['!return', '!imback'], command: '!return', message: '{username} has returned!', enabled: true, silent: false, respondAllChats: true, allowNonCampers: false, isDefault: true, category: 'APP', cooldown: 3, cooldownEnabled: true, cooldownType: 'per-user', undeletable: true, action: 'handleReturnCommand', returnFromStates: { AFK: true, SLEEPY: false, LURK: true } },
            { id: 'duel', name: 'Duel Command', commands: ['!duel'], command: '!duel', message: '{winner} defeats {loser} in a duel! ‚öîÔ∏è', enabled: false, silent: false, respondAllChats: true, allowNonCampers: true, isDefault: true, category: 'APP', cooldown: 3, cooldownEnabled: true, cooldownType: 'per-user', undeletable: true, action: 'handleDuelCommand' },
            { id: 'roll', name: 'Roll Command', commands: ['!roll'], command: '!roll', message: '{username} rolls {roll} (1-{max}) üé≤', enabled: false, silent: false, respondAllChats: true, allowNonCampers: true, isDefault: true, category: 'APP', cooldown: 3, cooldownEnabled: true, cooldownType: 'per-user', undeletable: true, action: 'handleRollCommand' }
        ];

        // Default movement commands (with cooldown properties)
        const defaultMovementCommands = [
            { id: 'cw', name: 'Clockwise Rotation', commands: ['!cw'], command: '!cw', message: '', enabled: true, silent: true, respondAllChats: false, allowNonCampers: false, isDefault: true, category: 'MOVEMENT', cooldown: 3, cooldownEnabled: true, cooldownType: 'per-user' },
            { id: 'ccw', name: 'Counter-clockwise Rotation', commands: ['!ccw'], command: '!ccw', message: '', enabled: true, silent: true, respondAllChats: false, allowNonCampers: false, isDefault: true, category: 'MOVEMENT', cooldown: 3, cooldownEnabled: true, cooldownType: 'per-user' },
            { id: 'still', name: 'Stay Still', commands: ['!still'], command: '!still', message: '{username} is now still.', enabled: true, silent: false, respondAllChats: true, allowNonCampers: false, isDefault: true, category: 'MOVEMENT', cooldown: 3, cooldownEnabled: true, cooldownType: 'per-user' },
            { id: 'roam', name: 'Roam Around', commands: ['!roam'], command: '!roam', message: '{username} is now roaming.', enabled: true, silent: false, respondAllChats: true, allowNonCampers: false, isDefault: true, category: 'MOVEMENT', cooldown: 3, cooldownEnabled: true, cooldownType: 'per-user' },
            { id: 'wander', name: 'Wander Freely', commands: ['!wander'], command: '!wander', message: '{username} is now wandering.', enabled: true, silent: false, respondAllChats: true, allowNonCampers: false, isDefault: true, category: 'MOVEMENT', cooldown: 3, cooldownEnabled: true, cooldownType: 'per-user' }
        ];

        // Default appearance commands (with cooldown properties)
        const defaultAppearanceCommands = [
            { id: 'changesprite', name: 'Change Sprite', commands: ['!changesprite', '!sprite'], command: '!changesprite', message: '', enabled: true, silent: true, respondAllChats: false, allowNonCampers: false, isDefault: true, category: 'APPEARANCE', cooldown: 3, cooldownEnabled: true, cooldownType: 'per-user' },
            { id: 'changecolor', name: 'Change Color', commands: ['!changecolor', '!color'], command: '!changecolor', message: '', enabled: true, silent: true, respondAllChats: false, allowNonCampers: false, isDefault: true, category: 'APPEARANCE', cooldown: 3, cooldownEnabled: true, cooldownType: 'per-user' },
            { id: 'next', name: 'Next Sprite', commands: ['!next'], command: '!next', message: '', enabled: true, silent: true, respondAllChats: false, allowNonCampers: false, isDefault: true, category: 'APPEARANCE', cooldown: 3, cooldownEnabled: true, cooldownType: 'per-user' },
            { id: 'back', name: 'Previous Sprite', commands: ['!back'], command: '!back', message: '', enabled: true, silent: true, respondAllChats: false, allowNonCampers: false, isDefault: true, category: 'APPEARANCE', cooldown: 3, cooldownEnabled: true, cooldownType: 'per-user' },
            { id: 'random', name: 'Random Appearance', commands: ['!random'], command: '!random', message: '', enabled: true, silent: true, respondAllChats: false, allowNonCampers: false, isDefault: true, category: 'APPEARANCE', cooldown: 3, cooldownEnabled: true, cooldownType: 'per-user' },
            { id: 'reset', name: 'Reset Appearance', commands: ['!reset'], command: '!reset', message: '{username} reset their campfire look.', enabled: true, silent: false, respondAllChats: true, allowNonCampers: false, isDefault: true, category: 'APPEARANCE', cooldown: 3, cooldownEnabled: true, cooldownType: 'per-user' }
        ];

        // Default animation commands (with cooldown properties)
        const defaultAnimationCommands = [
            { id: 'spin', name: 'Spin Command', commands: ['!spin'], command: '!spin', message: '{username} spins!', enabled: true, silent: false, respondAllChats: true, allowNonCampers: false, isDefault: true, category: 'ANIMATION', cooldown: 3, cooldownEnabled: true, cooldownType: 'per-user' },
            { id: 'dance', name: 'Dance Command', commands: ['!dance'], command: '!dance', message: '{username} dances!', enabled: true, silent: false, respondAllChats: true, allowNonCampers: false, isDefault: true, category: 'ANIMATION', cooldown: 3, cooldownEnabled: true, cooldownType: 'per-user' },
            { id: 'sparkle', name: 'Sparkle Command', commands: ['!sparkle'], command: '!sparkle', message: '{username} sparkles! ‚ú®', enabled: true, silent: false, respondAllChats: true, allowNonCampers: false, isDefault: true, category: 'ANIMATION', cooldown: 3, cooldownEnabled: true, cooldownType: 'per-user' }
        ];

        // Default auto state commands (no cooldown - these are triggered automatically)
        const defaultAutoStateCommands = [
            { id: 'sleepy', name: 'Sleepy State', commands: [], command: '', message: '{username} is now sleepy üò¥', enabled: true, silent: false, respondAllChats: true, allowNonCampers: false, isDefault: true, category: 'AUTO_STATE', cooldown: 0, cooldownEnabled: false, cooldownType: 'per-user' },
            { id: 'auto-afk', name: 'Auto AFK', commands: [], command: '', message: '{username} went AFK üí§', enabled: true, silent: false, respondAllChats: true, allowNonCampers: false, isDefault: true, category: 'AUTO_STATE', cooldown: 0, cooldownEnabled: false, cooldownType: 'per-user' },
            { id: 'auto-return', name: 'Auto Return', commands: [], command: '', message: '{username} is back! üëã', enabled: true, silent: false, respondAllChats: true, allowNonCampers: false, isDefault: true, category: 'AUTO_STATE', cooldown: 0, cooldownEnabled: false, cooldownType: 'per-user' },
            { id: 'auto-leave', name: 'Auto Leave', commands: [], command: '', message: '{username} has left due to inactivity', enabled: true, silent: false, respondAllChats: true, allowNonCampers: false, isDefault: true, category: 'AUTO_STATE', cooldown: 0, cooldownEnabled: false, cooldownType: 'per-user' }
        ];

        // Generic loader function for command categories
        async function loadCommandCategory(containerId, defaultCommands) {
            const container = document.getElementById(containerId);
            if (!container) return;

            // Load saved settings from main process
            let savedMessages = [];
            try {
                savedMessages = await window.electronAPI.getBotMessages() || [];
            } catch (e) {
                console.warn('Error loading bot messages:', e);
            }

            // Merge defaults with saved settings
            const commands = defaultCommands.map(defaultCmd => {
                const savedCmd = savedMessages.find(m => m.id === defaultCmd.id);
                return savedCmd ? { ...defaultCmd, ...savedCmd, isDefault: true } : defaultCmd;
            });

            // Render commands
            container.innerHTML = '';
            commands.forEach((cmd, index) => {
                const element = createBotMessageElement(cmd, index, true);
                container.appendChild(element);
            });

            // Save all commands to main process
            const allMessages = [...savedMessages];
            commands.forEach(cmd => {
                const existingIndex = allMessages.findIndex(m => m.id === cmd.id);
                if (existingIndex >= 0) {
                    allMessages[existingIndex] = { ...allMessages[existingIndex], ...cmd };
                } else {
                    allMessages.push(cmd);
                }
            });
            window.electronAPI.initializeBotMessages(allMessages);
        }

        // Individual loader functions for each category
        async function loadStateCommands() {
            await loadCommandCategory('stateCommandsList', defaultStateCommands);
        }

        async function loadMovementCommands() {
            await loadCommandCategory('movementCommandsList', defaultMovementCommands);
        }

        async function loadAppearanceCommands() {
            await loadCommandCategory('appearanceCommandsList', defaultAppearanceCommands);
        }

        async function loadAnimationCommands() {
            await loadCommandCategory('animationCommandsList', defaultAnimationCommands);
        }

        async function loadAppCommands() {
            await loadCommandCategory('appCommandsList', defaultAppCommands);
        }

        async function loadCustomCommands() {
            const customContainer = document.getElementById('customBotMessagesList');
            const noCustomMsg = document.getElementById('noCustomMessages');
            if (!customContainer) return;

            // Load saved settings from main process
            let savedMessages = [];
            try {
                savedMessages = await window.electronAPI.getBotMessages() || [];
            } catch (e) {
                console.warn('Error loading bot messages:', e);
            }

            // Get custom messages (those not in any default list)
            const allDefaultIds = [
                ...STATE_COMMAND_IDS,
                ...MOVEMENT_COMMAND_IDS,
                ...APPEARANCE_COMMAND_IDS,
                ...ANIMATION_COMMAND_IDS,
                ...AUTO_STATE_COMMAND_IDS,
                ...APP_COMMAND_IDS,
                'help' // Also exclude help
            ];
            const customMessages = savedMessages.filter(m => !allDefaultIds.includes(m.id));
            customMessages.forEach(m => m.isDefault = false);

            // Render custom commands
            customContainer.innerHTML = '';
            if (customMessages.length === 0) {
                if (noCustomMsg) noCustomMsg.style.display = 'block';
            } else {
                if (noCustomMsg) noCustomMsg.style.display = 'none';
                customMessages.forEach((cmd, index) => {
                    const element = createBotMessageElement(cmd, index, false);
                    customContainer.appendChild(element);
                });
            }
        }

        // Helper function to reload the currently visible command subtab
        async function reloadCurrentCommandSubTab() {
            // Check which subtab is currently visible and reload it
            const stateTab = document.getElementById('stateSubTab');
            const movementTab = document.getElementById('movementSubTab');
            const appearanceTab = document.getElementById('appearanceSubTab');
            const animationTab = document.getElementById('animationSubTab');
            const autoStatesTab = document.getElementById('autoStatesSubTab');
            const appTab = document.getElementById('appSubTab');
            const customTab = document.getElementById('customSubTab');
            
            if (stateTab && stateTab.style.display !== 'none') {
                await loadStateCommands();
            } else if (movementTab && movementTab.style.display !== 'none') {
                await loadMovementCommands();
            } else if (appearanceTab && appearanceTab.style.display !== 'none') {
                await loadAppearanceCommands();
            } else if (animationTab && animationTab.style.display !== 'none') {
                await loadAnimationCommands();
            } else if (autoStatesTab && autoStatesTab.style.display !== 'none') {
                await loadAutoStateCommands();
            } else if (appTab && appTab.style.display !== 'none') {
                await loadAppCommands();
            } else if (customTab && customTab.style.display !== 'none') {
                await loadCustomCommands();
            } else {
                // Default to state commands if nothing is visible
                await loadStateCommands();
            }
        }

        // Legacy function - kept for backward compatibility
        async function loadMovementAppearanceCommands() {
            const movementContainer = document.getElementById('movementCommandsList');
            const appearanceContainer = document.getElementById('appearanceCommandsList');
            
            if (!movementContainer || !appearanceContainer) return;

            // Load saved settings from main process
            let savedMessages = [];
            try {
                savedMessages = await window.electronAPI.getBotMessages() || [];
            } catch (e) {
                console.warn('Error loading bot messages for movement/appearance:', e);
            }

            // Merge defaults with saved settings for movement commands
            const movementCommands = defaultMovementCommands.map(defaultCmd => {
                const savedCmd = savedMessages.find(m => m.id === defaultCmd.id);
                return savedCmd ? { ...defaultCmd, ...savedCmd, isDefault: true } : defaultCmd;
            });

            // Merge defaults with saved settings for appearance commands
            const appearanceCommands = defaultAppearanceCommands.map(defaultCmd => {
                const savedCmd = savedMessages.find(m => m.id === defaultCmd.id);
                return savedCmd ? { ...defaultCmd, ...savedCmd, isDefault: true } : defaultCmd;
            });

            // Render movement commands
            movementContainer.innerHTML = '';
            movementCommands.forEach((cmd, index) => {
                const element = createBotMessageElement(cmd, index, true);
                movementContainer.appendChild(element);
            });

            // Render appearance commands
            appearanceContainer.innerHTML = '';
            appearanceCommands.forEach((cmd, index) => {
                const element = createBotMessageElement(cmd, index, true);
                appearanceContainer.appendChild(element);
            });

            // Save all commands to main process (including movement/appearance)
            const allMessages = [...savedMessages];
            
            // Add or update movement commands
            movementCommands.forEach(cmd => {
                const existingIndex = allMessages.findIndex(m => m.id === cmd.id);
                if (existingIndex >= 0) {
                    allMessages[existingIndex] = { ...allMessages[existingIndex], ...cmd };
                } else {
                    allMessages.push(cmd);
                }
            });

            // Add or update appearance commands
            appearanceCommands.forEach(cmd => {
                const existingIndex = allMessages.findIndex(m => m.id === cmd.id);
                if (existingIndex >= 0) {
                    allMessages[existingIndex] = { ...allMessages[existingIndex], ...cmd };
                } else {
                    allMessages.push(cmd);
                }
            });

            window.electronAPI.initializeBotMessages(allMessages);
        }

        // Load and display auto state commands
        async function loadAutoStateCommands() {
            const autoStatesContainer = document.getElementById('autoStatesList');
            if (!autoStatesContainer) return;

            // Load saved settings from main process
            let savedMessages = [];
            try {
                savedMessages = await window.electronAPI.getBotMessages() || [];
            } catch (e) {
                console.warn('Error loading bot messages for auto states:', e);
            }

            // Merge defaults with saved settings for auto state commands
            const autoStateCommands = defaultAutoStateCommands.map(defaultCmd => {
                const savedCmd = savedMessages.find(m => m.id === defaultCmd.id);
                return savedCmd ? { ...defaultCmd, ...savedCmd, isDefault: true } : defaultCmd;
            });

            // Render auto state commands
            autoStatesContainer.innerHTML = '';
            autoStateCommands.forEach((cmd, index) => {
                const element = createBotMessageElement(cmd, index, true);
                autoStatesContainer.appendChild(element);
            });

            // Save all commands to main process (including auto states)
            const allMessages = [...savedMessages];

            // Add or update auto state commands
            autoStateCommands.forEach(cmd => {
                const existingIndex = allMessages.findIndex(m => m.id === cmd.id);
                if (existingIndex >= 0) {
                    allMessages[existingIndex] = { ...allMessages[existingIndex], ...cmd };
                } else {
                    allMessages.push(cmd);
                }
            });

            window.electronAPI.initializeBotMessages(allMessages);
        }

        // Sync STATE command display names from JOIN tab settings
        function syncStateCommandNames() {
            const settings = loadSettings();
            if (!settings) return;

            // Update join commands display
            const joinCommands = Array.isArray(settings.commands) ? settings.commands : [(settings.command || '!join')];
            // Update afk commands display
            const afkCommands = Array.isArray(settings.afkCommands) ? settings.afkCommands : ['!afk'];
            // Update lurk commands display
            const lurkCommands = Array.isArray(settings.lurkCommands) ? settings.lurkCommands : ['!lurk'];

            // Update display elements if they exist
            const joinCmdDisplay = document.querySelector('#stateCommandsList .bot-message-item[data-command-id="join"] .cmd-value');
            const afkCmdDisplay = document.querySelector('#stateCommandsList .bot-message-item[data-command-id="afk"] .cmd-value');
            const lurkCmdDisplay = document.querySelector('#stateCommandsList .bot-message-item[data-command-id="lurk"] .cmd-value');

            if (joinCmdDisplay) joinCmdDisplay.textContent = joinCommands.join(', ');
            if (afkCmdDisplay) afkCmdDisplay.textContent = afkCommands.join(', ');
            if (lurkCmdDisplay) lurkCmdDisplay.textContent = lurkCommands.join(', ');
        }

        // Load and display bot messages
        async function loadBotMessages() {
            const stateContainer = document.getElementById('stateCommandsList');
            const defaultContainer = document.getElementById('defaultBotMessagesList');
            const customContainer = document.getElementById('customBotMessagesList');
            const noCustomMsg = document.getElementById('noCustomMessages');

            if (!stateContainer || !defaultContainer || !customContainer) return;

            // Default bot messages (built-in commands and state announcements)
            const defaultBotMessages = [
                // STATE COMMANDS (commands synced from JOIN tab, messages editable)
                {
                    id: 'join',
                    name: 'Join Command',
                    commands: ['!join'], // Will be synced from JOIN tab
                    command: '!join',   // Will be synced from JOIN tab
                    message: '{username} joined the campfire!',
                    enabled: true,
                    silent: false,
                    respondAllChats: true,
                    allowNonCampers: false,
                    category: 'STATE',
                    isDefault: true,
                    bakedIn: true // Special flag for STATE commands
                },
                {
                    id: 'leave',
                    name: 'Leave Command',
                    commands: ['!leave', '!exit'], // Hardcoded for leave
                    command: '!leave',
                    message: '{username} left the campfire.',
                    enabled: true,
                    silent: false,
                    respondAllChats: true,
                    allowNonCampers: false,
                    category: 'STATE',
                    isDefault: true,
                    bakedIn: true
                },
                {
                    id: 'afk',
                    name: 'AFK Command',
                    commands: ['!afk'], // Will be synced from JOIN tab
                    command: '!afk',   // Will be synced from JOIN tab
                    message: '{username} went AFK üí§',
                    enabled: true,
                    silent: false,
                    respondAllChats: true,
                    allowNonCampers: true,
                    category: 'STATE',
                    isDefault: true,
                    bakedIn: true
                },
                {
                    id: 'lurk',
                    name: 'Lurk Command',
                    commands: ['!lurk'], // Will be synced from JOIN tab
                    command: '!lurk',   // Will be synced from JOIN tab
                    message: '{username} is now lurking üëÅÔ∏è',
                    enabled: true,
                    silent: false,
                    respondAllChats: true,
                    allowNonCampers: true,
                    category: 'STATE',
                    isDefault: true,
                    bakedIn: true
                },
                {
                    id: 'help',
                    name: 'Help Command',
                    commands: ['!help'],
                    command: '!help',
                    message: 'Commands: join with "!join" ‚Ä¢ !leave ‚Ä¢ !cw [deg] ‚Ä¢ !ccw [deg] ‚Ä¢ !color <hex> ‚Ä¢ !sprite <name> ‚Ä¢ !next/!back ‚Ä¢ !spin ‚Ä¢ !dance ‚Ä¢ !sparkle ‚Ä¢ !random ‚Ä¢ !reset ‚Ä¢ !still/!wander',
                    enabled: true,
                    silent: false,
                    respondAllChats: true,
                    allowNonCampers: true,
                    isDefault: true
                },
                {
                    id: 'reset',
                    name: 'Reset Command',
                    commands: ['!reset'],
                    command: '!reset',
                    message: '{username} reset their campfire look.',
                    enabled: true,
                    silent: false,
                    respondAllChats: true,
                    allowNonCampers: false,
                    isDefault: true
                },
                {
                    id: 'spin',
                    name: 'Spin Command',
                    commands: ['!spin'],
                    command: '!spin',
                    message: '{username} spins!',
                    enabled: true,
                    silent: false,
                    respondAllChats: true,
                    allowNonCampers: false,
                    isDefault: true
                },
                {
                    id: 'dance',
                    name: 'Dance Command',
                    commands: ['!dance'],
                    command: '!dance',
                    message: '{username} dances!',
                    enabled: true,
                    silent: false,
                    respondAllChats: true,
                    allowNonCampers: false,
                    isDefault: true
                },
                {
                    id: 'sparkle',
                    name: 'Sparkle Command',
                    commands: ['!sparkle'],
                    command: '!sparkle',
                    message: '{username} sparkles! ‚ú®',
                    enabled: true,
                    silent: false,
                    respondAllChats: true,
                    allowNonCampers: false,
                    isDefault: true
                },
                {
                    id: 'still',
                    name: 'Still Command',
                    commands: ['!still'],
                    command: '!still',
                    message: '{username} is now still.',
                    enabled: true,
                    silent: false,
                    respondAllChats: true,
                    allowNonCampers: false,
                    isDefault: true
                },
                {
                    id: 'roam',
                    name: 'Roam Command',
                    commands: ['!roam'],
                    command: '!roam',
                    message: '{username} is now roaming.',
                    enabled: true,
                    silent: false,
                    respondAllChats: true,
                    allowNonCampers: false,
                    isDefault: true
                },
                {
                    id: 'wander',
                    name: 'Wander Command',
                    commands: ['!wander'],
                    command: '!wander',
                    message: '{username} is now wandering.',
                    enabled: true,
                    silent: false,
                    respondAllChats: true,
                    allowNonCampers: false,
                    isDefault: true
                },
            ];

            // Load saved bot messages
            let allBotMessages = [...defaultBotMessages];
            let customMessages = [];
            
            try {
                const saved = await window.electronAPI.getBotMessages();
                if (saved && saved.length > 0) {
                    // Merge defaults with saved settings
                    allBotMessages = defaultBotMessages.map(defaultMsg => {
                        const savedMsg = saved.find(m => m.id === defaultMsg.id);
                        return savedMsg ? { ...defaultMsg, ...savedMsg, isDefault: true } : defaultMsg;
                    });
                    
                    // Get custom messages (those not in default list)
                    customMessages = saved.filter(m => !DEFAULT_BOT_MESSAGE_IDS.includes(m.id));
                    customMessages.forEach(m => m.isDefault = false);
                } else {
                    // No saved messages, save defaults to localStorage
                    window.electronAPI.saveBotMessages(defaultBotMessages);
                }
            } catch (e) {
                console.warn('Error loading bot messages:', e);
                window.electronAPI.saveBotMessages(defaultBotMessages);
            }

            // Separate messages by category
            const stateMessages = allBotMessages.filter(msg => msg.category === 'STATE');
            const otherDefaultMessages = allBotMessages.filter(msg => msg.category !== 'STATE');

            // Render STATE commands
            stateContainer.innerHTML = '';
            stateMessages.forEach((msg, index) => {
                const element = createBotMessageElement(msg, index, true);
                stateContainer.appendChild(element);
            });

            // Render other default messages
            defaultContainer.innerHTML = '';
            otherDefaultMessages.forEach((msg, index) => {
                const element = createBotMessageElement(msg, index, true);
                defaultContainer.appendChild(element);
            });

            // Render custom messages
            customContainer.innerHTML = '';
            if (customMessages.length > 0) {
                noCustomMsg.style.display = 'none';
                customMessages.forEach((msg, index) => {
                    const element = createBotMessageElement(msg, index, false);
                    customContainer.appendChild(element);
                });
            } else {
                noCustomMsg.style.display = 'block';
            }

            // Send all messages to main process to initialize cache
            const allMessages = [...allBotMessages, ...customMessages];
            window.electronAPI.initializeBotMessages(allMessages);

            // Sync STATE command names from JOIN tab settings
            syncStateCommandNames();
        }

        // Helper function to create bot message DOM element
        function createBotMessageElement(msg, index, isDefault = false) {
            const div = document.createElement('div');
            div.className = 'bot-message-item';
            div.setAttribute('data-command-id', msg.id); // For syncing STATE commands
            const borderColor = isDefault ? '#3a3a3a' : '#9146ff33';
            div.style.cssText = `background: #1f1f1f; border: 1px solid ${borderColor}; border-radius: 6px; padding: 15px; margin-bottom: 10px;`;

            // Create toggle switch for enabling/disabling the command
            const toggleSwitch = document.createElement('div');
            toggleSwitch.className = `toggle-switch ${msg.enabled ? 'active' : ''}`;
            toggleSwitch.style.cssText = `cursor: pointer; width: 50px; height: 24px; background: ${msg.enabled ? '#4caf50' : '#444'}; border-radius: 12px; position: relative; transition: background 0.3s; box-shadow: inset 0 1px 3px rgba(0,0,0,0.3);`;
            toggleSwitch.innerHTML = `<div style="position: absolute; top: 2px; left: ${msg.enabled ? '28px' : '2px'}; width: 20px; height: 20px; background: white; border-radius: 50%; transition: left 0.3s ease; box-shadow: 0 2px 4px rgba(0,0,0,0.2);"></div>`;
            toggleSwitch.onclick = () => toggleBotMessage(msg.id);
            toggleSwitch.title = 'Enable or disable this command';

            // Create permission toggle for ALL commands (allow non-campers to use the command)
            const permissionToggle = document.createElement('div');
            permissionToggle.style.cssText = 'display: flex; align-items: center; gap: 8px; margin-left: 15px;';

            const permCheckbox = document.createElement('input');
            permCheckbox.type = 'checkbox';
            permCheckbox.id = `perm-${msg.id}`;
            permCheckbox.checked = msg.allowNonCampers || false;
            permCheckbox.onchange = () => toggleCommandOption(msg.id, 'allowNonCampers', permCheckbox.checked);
            permCheckbox.title = 'Allow users who have not joined the campfire to use this command';

            const permLabel = document.createElement('label');
            permLabel.htmlFor = `perm-${msg.id}`;
            permLabel.style.cssText = 'font-size: 11px; color: #ccc; cursor: pointer;';
            permLabel.textContent = 'Allow non-campers';
            permLabel.title = 'Allow users who have not joined the campfire to use this command';

            permissionToggle.appendChild(permCheckbox);
            permissionToggle.appendChild(permLabel);

            // Create buttons
            const editBtn = document.createElement('button');
            editBtn.className = 'button button-secondary';
            editBtn.textContent = 'Edit';
            editBtn.style.cssText = 'padding: 6px 12px; font-size: 12px;';
            editBtn.onclick = () => editBotMessage(msg.id);
            editBtn.title = 'Edit command triggers and response message';

            // Build the element
            const headerDiv = document.createElement('div');
            headerDiv.style.cssText = 'display: flex; align-items: center; gap: 15px; margin-bottom: 12px;';

            const nameDiv = document.createElement('div');
            nameDiv.style.cssText = 'font-weight: bold; color: #fff; font-size: 14px; flex: 1;';
            nameDiv.textContent = msg.name;
            nameDiv.title = `Command: ${msg.name}`;
            
            // Add badge for default commands
            if (isDefault) {
                const badge = document.createElement('span');
                badge.style.cssText = 'font-size: 10px; background: #667eea33; color: #667eea; padding: 2px 6px; border-radius: 3px; margin-left: 8px;';
                badge.textContent = 'DEFAULT';
                badge.title = 'This is a built-in command that comes with the widget';
                nameDiv.appendChild(badge);
            }

            // Add italic formatting indicator for STATE, ANIMATION, MOVEMENT, APPEARANCE commands
            const italicCategories = ['STATE', 'ANIMATION', 'MOVEMENT', 'APPEARANCE'];
            if (msg.category && italicCategories.includes(msg.category)) {
                const italicBadge = document.createElement('span');
                italicBadge.style.cssText = 'font-size: 10px; background: #ff6b3533; color: #ff6b35; padding: 2px 6px; border-radius: 3px; margin-left: 8px; font-style: italic;';
                italicBadge.textContent = 'ITALIC';
                italicBadge.title = 'This command displays in italic/narrative style in Popout Chat';
                nameDiv.appendChild(italicBadge);
            }

            const buttonContainer = document.createElement('div');
            buttonContainer.style.cssText = 'display: flex; gap: 8px; align-items: center;';

            // Insert toggle and buttons
            headerDiv.appendChild(toggleSwitch);
            headerDiv.appendChild(nameDiv);
            headerDiv.appendChild(permissionToggle);
            buttonContainer.appendChild(editBtn);
            
            // Only show delete button for custom commands
            if (!isDefault) {
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'button';
                deleteBtn.textContent = 'Delete';
                deleteBtn.style.cssText = 'padding: 6px 12px; background: #ff4444; border: 1px solid #cc3333; font-size: 12px;';
                deleteBtn.onclick = () => deleteBotMessage(msg.id);
                deleteBtn.title = 'Permanently delete this custom command';
                buttonContainer.appendChild(deleteBtn);
            }
            
            headerDiv.appendChild(buttonContainer);

            // Create command/response grid
            const gridDiv = document.createElement('div');
            gridDiv.style.cssText = 'display: grid; grid-template-columns: 100px 1fr; gap: 10px; align-items: start; margin-bottom: 12px;';

            const cmdLabel = document.createElement('div');
            cmdLabel.style.cssText = 'font-size: 12px; color: #888; font-weight: 600;';
            cmdLabel.textContent = 'Command:';
            cmdLabel.title = 'The chat command(s) that trigger this response';

            const cmdValue = document.createElement('div');
            cmdValue.className = 'cmd-value'; // Add class for syncing
            if (msg.bakedIn) {
                // Baked-in commands (synced from JOIN tab) - read-only display
                cmdValue.style.cssText = "font-family: 'Courier New', monospace; background: #333; padding: 6px 10px; border-radius: 4px; color: #888; font-size: 13px; border: 1px solid #555; opacity: 0.7;";
                cmdValue.title = 'Command name synced from JOIN tab (not editable here)';
            } else {
                // Editable commands
                cmdValue.style.cssText = "font-family: 'Courier New', monospace; background: #2a2a2a; padding: 6px 10px; border-radius: 4px; color: #4caf50; font-size: 13px; border: 1px solid #444;";
                cmdValue.title = 'Type this in chat to trigger the command';
            }
            cmdValue.textContent = Array.isArray(msg.commands) ? msg.commands.join(', ') : (msg.command || '!command');

            const respLabel = document.createElement('div');
            respLabel.style.cssText = 'font-size: 12px; color: #888; font-weight: 600;';
            respLabel.textContent = 'Response:';
            respLabel.title = 'The message sent to chat when the command is used';

            const respValue = document.createElement('div');
            respValue.style.cssText = 'font-size: 13px; color: #ccc; background: #2a2a2a; padding: 6px 10px; border-radius: 4px; word-break: break-word; line-height: 1.5; border: 1px solid #444; min-height: 36px;';
            
            // Special handling for !who command - show editable fields
            if (msg.id === 'who') {
                const userLineFormat = msg.userLineFormat || '{icon} {username}';
                const userSeparator = msg.userSeparator || ' ‚Ä¢ ';
                const stateIcons = msg.stateIcons || { JOINED: 'üî•', ACTIVE: 'üî•', SLEEPY: 'üò¥', AFK: 'üí§', LURK: 'üëÅÔ∏è' };
                const stateFilters = msg.stateFilters || { JOINED: true, ACTIVE: true, SLEEPY: true, AFK: true, LURK: true };
                
                // Generate example output based on current format and filters
                const allExampleUsers = [
                    { state: 'JOINED', username: 'ExampleUser1' },
                    { state: 'ACTIVE', username: 'ActiveViewer' },
                    { state: 'SLEEPY', username: 'SleepyViewer' },
                    { state: 'AFK', username: 'AFKPerson' },
                    { state: 'LURK', username: 'LurkingFan' }
                ];
                const filteredExampleUsers = allExampleUsers.filter(u => stateFilters[u.state] !== false);
                const exampleOutput = filteredExampleUsers.map(u => {
                    const icon = stateIcons[u.state] || 'üî•';
                    return userLineFormat.replace('{icon}', icon).replace('{username}', u.username).replace('{state}', u.state.toLowerCase());
                }).join(userSeparator);
                
                respValue.innerHTML = `
                    <div style="margin-bottom: 12px;">
                        <div style="color: #888; font-size: 11px; margin-bottom: 4px;">Header Message:</div>
                        <input type="text" id="who-header-${msg.id}" value="${escapeHtml(msg.message || 'üî• Around the campfire:')}"
                            style="width: 100%; padding: 6px 10px; background: #333; border: 1px solid #555; border-radius: 4px; color: #fff; font-size: 13px;"
                            onchange="updateWhoCommandField('${msg.id}', 'message', this.value)"
                            title="The header message shown before the user list">
                    </div>
                    <div style="margin-bottom: 12px;">
                        <div style="color: #888; font-size: 11px; margin-bottom: 4px;">User Format:</div>
                        <input type="text" id="who-format-${msg.id}" value="${escapeHtml(userLineFormat)}"
                            style="width: 100%; padding: 6px 10px; background: #333; border: 1px solid #555; border-radius: 4px; color: #fff; font-size: 13px;"
                            onchange="updateWhoCommandField('${msg.id}', 'userLineFormat', this.value)"
                            title="Format for each user. Use {icon}, {username}, {state}">
                        <div style="color: #666; font-size: 10px; margin-top: 4px;">Placeholders: {icon} {username} {state}</div>
                    </div>
                    <div style="margin-bottom: 12px;">
                        <div style="color: #888; font-size: 11px; margin-bottom: 4px;">User Separator:</div>
                        <input type="text" id="who-separator-${msg.id}" value="${escapeHtml(userSeparator)}"
                            style="width: 100%; padding: 6px 10px; background: #333; border: 1px solid #555; border-radius: 4px; color: #fff; font-size: 13px;"
                            onchange="updateWhoCommandField('${msg.id}', 'userSeparator', this.value)"
                            title="Separator between users (e.g., ' ‚Ä¢ ' or ' - ' or ', ')">
                    </div>
                    <div style="margin-bottom: 12px;">
                        <div style="color: #888; font-size: 11px; margin-bottom: 4px;">State Icons (click to edit):</div>
                        <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                            <div style="display: flex; align-items: center; gap: 4px; background: #333; padding: 4px 8px; border-radius: 4px;">
                                <span style="font-size: 11px; color: #888;">Active:</span>
                                <input type="text" id="who-icon-active-${msg.id}" value="${escapeHtml(stateIcons.ACTIVE || 'üî•')}"
                                    style="width: 40px; padding: 2px 4px; background: #222; border: 1px solid #555; border-radius: 3px; color: #fff; font-size: 14px; text-align: center;"
                                    onchange="updateWhoStateIcon('${msg.id}', 'ACTIVE', this.value)">
                            </div>
                            <div style="display: flex; align-items: center; gap: 4px; background: #333; padding: 4px 8px; border-radius: 4px;">
                                <span style="font-size: 11px; color: #888;">Sleepy:</span>
                                <input type="text" id="who-icon-sleepy-${msg.id}" value="${escapeHtml(stateIcons.SLEEPY || 'üò¥')}"
                                    style="width: 40px; padding: 2px 4px; background: #222; border: 1px solid #555; border-radius: 3px; color: #fff; font-size: 14px; text-align: center;"
                                    onchange="updateWhoStateIcon('${msg.id}', 'SLEEPY', this.value)">
                            </div>
                            <div style="display: flex; align-items: center; gap: 4px; background: #333; padding: 4px 8px; border-radius: 4px;">
                                <span style="font-size: 11px; color: #888;">AFK:</span>
                                <input type="text" id="who-icon-afk-${msg.id}" value="${escapeHtml(stateIcons.AFK || 'üí§')}"
                                    style="width: 40px; padding: 2px 4px; background: #222; border: 1px solid #555; border-radius: 3px; color: #fff; font-size: 14px; text-align: center;"
                                    onchange="updateWhoStateIcon('${msg.id}', 'AFK', this.value)">
                            </div>
                            <div style="display: flex; align-items: center; gap: 4px; background: #333; padding: 4px 8px; border-radius: 4px;">
                                <span style="font-size: 11px; color: #888;">Lurk:</span>
                                <input type="text" id="who-icon-lurk-${msg.id}" value="${escapeHtml(stateIcons.LURK || 'üëÅÔ∏è')}"
                                    style="width: 40px; padding: 2px 4px; background: #222; border: 1px solid #555; border-radius: 3px; color: #fff; font-size: 14px; text-align: center;"
                                    onchange="updateWhoStateIcon('${msg.id}', 'LURK', this.value)">
                            </div>
                            <div style="display: flex; align-items: center; gap: 4px; background: #333; padding: 4px 8px; border-radius: 4px;">
                                <span style="font-size: 11px; color: #888;">Bot:</span>
                                <input type="text" id="who-icon-bot-${msg.id}" value="${escapeHtml(stateIcons.BOT || 'ü§ñ')}"
                                    style="width: 40px; padding: 2px 4px; background: #222; border: 1px solid #555; border-radius: 3px; color: #fff; font-size: 14px; text-align: center;"
                                    onchange="updateWhoStateIcon('${msg.id}', 'BOT', this.value)">
                            </div>
                        </div>
                    </div>
                    <div style="margin-bottom: 12px;">
                        <div style="color: #888; font-size: 11px; margin-bottom: 4px;">Include States:</div>
                        <div style="display: flex; gap: 12px; flex-wrap: wrap;">
                            <label style="display: flex; align-items: center; gap: 4px; cursor: pointer;">
                                <input type="checkbox" id="who-filter-active-${msg.id}" ${stateFilters.ACTIVE !== false && stateFilters.JOINED !== false ? 'checked' : ''}
                                    onchange="updateWhoStateFilter('${msg.id}', 'ACTIVE', this.checked); updateWhoStateFilter('${msg.id}', 'JOINED', this.checked);"
                                    style="cursor: pointer;">
                                <span style="font-size: 12px; color: #aaa;">Active/Joined</span>
                            </label>
                            <label style="display: flex; align-items: center; gap: 4px; cursor: pointer;">
                                <input type="checkbox" id="who-filter-sleepy-${msg.id}" ${stateFilters.SLEEPY !== false ? 'checked' : ''}
                                    onchange="updateWhoStateFilter('${msg.id}', 'SLEEPY', this.checked)"
                                    style="cursor: pointer;">
                                <span style="font-size: 12px; color: #aaa;">Sleepy</span>
                            </label>
                            <label style="display: flex; align-items: center; gap: 4px; cursor: pointer;">
                                <input type="checkbox" id="who-filter-afk-${msg.id}" ${stateFilters.AFK !== false ? 'checked' : ''}
                                    onchange="updateWhoStateFilter('${msg.id}', 'AFK', this.checked)"
                                    style="cursor: pointer;">
                                <span style="font-size: 12px; color: #aaa;">AFK</span>
                            </label>
                            <label style="display: flex; align-items: center; gap: 4px; cursor: pointer;">
                                <input type="checkbox" id="who-filter-lurk-${msg.id}" ${stateFilters.LURK !== false ? 'checked' : ''}
                                    onchange="updateWhoStateFilter('${msg.id}', 'LURK', this.checked)"
                                    style="cursor: pointer;">
                                <span style="font-size: 12px; color: #aaa;">Lurking</span>
                            </label>
                        </div>
                    </div>
                    <div style="background: #1a1a1a; padding: 10px; border-radius: 4px; border: 1px solid #333;">
                        <div style="color: #888; font-size: 11px; margin-bottom: 6px;">Preview:</div>
                        <div id="who-preview-${msg.id}" style="color: #aaa; font-style: italic; font-size: 12px;">${escapeHtml(msg.message || 'üî• Around the campfire:')} ${escapeHtml(exampleOutput)}</div>
                    </div>
                `;
                respValue.title = 'Customize the header message, user format, icons, and filters';
            } else {
                respValue.textContent = msg.message;
                respValue.title = 'Use {username} to include the user\'s name in the response';
            }

            gridDiv.appendChild(cmdLabel);
            gridDiv.appendChild(cmdValue);
            gridDiv.appendChild(respLabel);
            gridDiv.appendChild(respValue);

            // Create options grid
            const optionsGrid = document.createElement('div');
            optionsGrid.style.cssText = 'display: grid; grid-template-columns: 100px 1fr; gap: 10px; align-items: center; margin-top: 12px; padding-top: 12px; border-top: 1px solid #444;';

            // Silent toggle
            const silentLabel = document.createElement('div');
            silentLabel.style.cssText = 'font-size: 12px; color: #888; font-weight: 600;';
            silentLabel.textContent = 'Silent:';
            silentLabel.title = 'When enabled, the bot will not send a response message to chat';

            const silentToggle = document.createElement('div');
            silentToggle.className = `toggle-switch ${msg.silent ? 'active' : ''}`;
            silentToggle.style.cssText = `cursor: pointer; width: 50px; height: 24px; background: ${msg.silent ? '#ff6b35' : '#444'}; border-radius: 12px; position: relative; transition: background 0.3s; box-shadow: inset 0 1px 3px rgba(0,0,0,0.3);`;
            silentToggle.innerHTML = `<div style="position: absolute; top: 2px; left: ${msg.silent ? '28px' : '2px'}; width: 20px; height: 20px; background: white; border-radius: 50%; transition: left 0.3s ease; box-shadow: 0 2px 4px rgba(0,0,0,0.2);"></div>`;
            silentToggle.onclick = () => toggleCommandOption(msg.id, 'silent', !msg.silent);
            silentToggle.title = 'When enabled, the user\'s command message (e.g., "!cw") is hidden from chat displays, but the command still executes';

            // Pop Out Chat toggle (renamed from All Chats)
            const respondLabel = document.createElement('div');
            respondLabel.style.cssText = 'font-size: 12px; color: #888; font-weight: 600;';
            respondLabel.textContent = 'Pop Out Chat:';
            respondLabel.title = 'When enabled, the bot response is sent to the Pop Out Chat window. When disabled, responses only go to Twitch Chat.';

            const respondToggle = document.createElement('div');
            respondToggle.className = `toggle-switch ${msg.respondAllChats ? 'active' : ''}`;
            respondToggle.style.cssText = `cursor: pointer; width: 50px; height: 24px; background: ${msg.respondAllChats ? '#4caf50' : '#444'}; border-radius: 12px; position: relative; transition: background 0.3s; box-shadow: inset 0 1px 3px rgba(0,0,0,0.3);`;
            respondToggle.innerHTML = `<div style="position: absolute; top: 2px; left: ${msg.respondAllChats ? '28px' : '2px'}; width: 20px; height: 20px; background: white; border-radius: 50%; transition: left 0.3s ease; box-shadow: 0 2px 4px rgba(0,0,0,0.2);"></div>`;
            respondToggle.onclick = () => toggleCommandOption(msg.id, 'respondAllChats', !msg.respondAllChats);
            respondToggle.title = 'When enabled, the bot response is sent to the Pop Out Chat window. When disabled, responses only go to Twitch Chat.';

            // Cooldown toggle
            const cooldownLabel = document.createElement('div');
            cooldownLabel.style.cssText = 'font-size: 12px; color: #888; font-weight: 600;';
            cooldownLabel.textContent = 'Cooldown:';
            cooldownLabel.title = 'When enabled, this command has a cooldown period before it can be used again';

            const cooldownContainer = document.createElement('div');
            cooldownContainer.style.cssText = 'display: flex; align-items: center; gap: 10px;';

            const cooldownToggle = document.createElement('div');
            const cooldownEnabled = msg.cooldownEnabled !== false; // Default to true
            cooldownToggle.className = `toggle-switch ${cooldownEnabled ? 'active' : ''}`;
            cooldownToggle.style.cssText = `cursor: pointer; width: 50px; height: 24px; background: ${cooldownEnabled ? '#667eea' : '#444'}; border-radius: 12px; position: relative; transition: background 0.3s; box-shadow: inset 0 1px 3px rgba(0,0,0,0.3);`;
            cooldownToggle.innerHTML = `<div style="position: absolute; top: 2px; left: ${cooldownEnabled ? '28px' : '2px'}; width: 20px; height: 20px; background: white; border-radius: 50%; transition: left 0.3s ease; box-shadow: 0 2px 4px rgba(0,0,0,0.2);"></div>`;
            cooldownToggle.onclick = () => toggleCommandOption(msg.id, 'cooldownEnabled', !msg.cooldownEnabled);
            cooldownToggle.title = 'Enable or disable cooldown for this command';

            const cooldownInput = document.createElement('input');
            cooldownInput.type = 'number';
            cooldownInput.min = '0';
            cooldownInput.max = '3600';
            cooldownInput.value = msg.cooldown || 3;
            cooldownInput.style.cssText = 'width: 60px; padding: 4px 8px; background: #2a2a2a; border: 1px solid #444; border-radius: 4px; color: #fff; font-size: 12px;';
            cooldownInput.title = 'Cooldown duration in seconds';
            cooldownInput.onchange = () => updateCommandCooldown(msg.id, parseInt(cooldownInput.value) || 3);

            const cooldownSuffix = document.createElement('span');
            cooldownSuffix.style.cssText = 'font-size: 11px; color: #888;';
            cooldownSuffix.textContent = 'sec';

            cooldownContainer.appendChild(cooldownToggle);
            cooldownContainer.appendChild(cooldownInput);
            cooldownContainer.appendChild(cooldownSuffix);

            // Cooldown type selector (per-user vs global) - only show for special commands
            const cooldownTypeLabel = document.createElement('div');
            cooldownTypeLabel.style.cssText = 'font-size: 12px; color: #888; font-weight: 600;';
            cooldownTypeLabel.textContent = 'Type:';
            cooldownTypeLabel.title = 'Per-user: each user has their own cooldown. Global: one cooldown for everyone.';

            const cooldownTypeSelect = document.createElement('select');
            cooldownTypeSelect.style.cssText = 'padding: 4px 8px; background: #2a2a2a; border: 1px solid #444; border-radius: 4px; color: #fff; font-size: 11px;';
            cooldownTypeSelect.innerHTML = `
                <option value="per-user" ${(msg.cooldownType || 'per-user') === 'per-user' ? 'selected' : ''}>Per User</option>
                <option value="global" ${msg.cooldownType === 'global' ? 'selected' : ''}>Global</option>
            `;
            cooldownTypeSelect.onchange = () => toggleCommandOption(msg.id, 'cooldownType', cooldownTypeSelect.value);
            cooldownTypeSelect.title = 'Per-user: each user has their own cooldown. Global: one cooldown for everyone.';

            optionsGrid.appendChild(silentLabel);
            optionsGrid.appendChild(silentToggle);
            optionsGrid.appendChild(respondLabel);
            optionsGrid.appendChild(respondToggle);
            optionsGrid.appendChild(cooldownLabel);
            optionsGrid.appendChild(cooldownContainer);
            optionsGrid.appendChild(cooldownTypeLabel);
            optionsGrid.appendChild(cooldownTypeSelect);

            div.appendChild(headerDiv);
            div.appendChild(gridDiv);
            div.appendChild(optionsGrid);

            return div;
        }

        // Update command cooldown value
        async function updateCommandCooldown(commandId, seconds) {
            try {
                const messages = await window.electronAPI.getBotMessages();
                const msgIndex = messages.findIndex(m => m.id === commandId);
                if (msgIndex !== -1) {
                    messages[msgIndex].cooldown = seconds;
                    await window.electronAPI.saveBotMessages(messages);
                    console.log(`[Dashboard] Updated cooldown for ${commandId} to ${seconds}s`);
                }
            } catch (error) {
                console.error('[Dashboard] Error updating cooldown:', error);
            }
        }

        // Update !who command field (header message or user line format)
        async function updateWhoCommandField(commandId, field, value) {
            try {
                const messages = await window.electronAPI.getBotMessages();
                const msgIndex = messages.findIndex(m => m.id === commandId);
                if (msgIndex !== -1) {
                    messages[msgIndex][field] = value;
                    await window.electronAPI.saveBotMessages(messages);
                    // Update preview
                    updateWhoPreview(commandId);
                    console.log(`[Dashboard] Updated ${field} for ${commandId}`);
                }
            } catch (error) {
                console.error('[Dashboard] Error updating who command field:', error);
            }
        }

        // Update !who command preview
        async function updateWhoPreview(commandId) {
            const previewEl = document.getElementById(`who-preview-${commandId}`);
            if (!previewEl) return;
            
            const headerInput = document.getElementById(`who-header-${commandId}`);
            const formatInput = document.getElementById(`who-format-${commandId}`);
            const separatorInput = document.getElementById(`who-separator-${commandId}`);
            
            if (!headerInput || !formatInput) return;
            
            const header = headerInput.value || 'üî• Around the campfire:';
            const format = formatInput.value || '{icon} {username}';
            const separator = separatorInput ? separatorInput.value : ' ‚Ä¢ ';
            
            // Get current icons from inputs
            const activeIcon = document.getElementById(`who-icon-active-${commandId}`)?.value || 'üî•';
            const sleepyIcon = document.getElementById(`who-icon-sleepy-${commandId}`)?.value || 'üò¥';
            const afkIcon = document.getElementById(`who-icon-afk-${commandId}`)?.value || 'üí§';
            const lurkIcon = document.getElementById(`who-icon-lurk-${commandId}`)?.value || 'üëÅÔ∏è';
            
            // Get current filters from checkboxes
            const activeFilter = document.getElementById(`who-filter-active-${commandId}`)?.checked !== false;
            const sleepyFilter = document.getElementById(`who-filter-sleepy-${commandId}`)?.checked !== false;
            const afkFilter = document.getElementById(`who-filter-afk-${commandId}`)?.checked !== false;
            const lurkFilter = document.getElementById(`who-filter-lurk-${commandId}`)?.checked !== false;
            
            // Generate sample preview with current settings
            const allSampleUsers = [
                { state: 'ACTIVE', icon: activeIcon, username: 'ExampleUser1', filter: activeFilter },
                { state: 'SLEEPY', icon: sleepyIcon, username: 'SleepyViewer', filter: sleepyFilter },
                { state: 'AFK', icon: afkIcon, username: 'AFKPerson', filter: afkFilter },
                { state: 'LURK', icon: lurkIcon, username: 'LurkingFan', filter: lurkFilter }
            ];
            
            const filteredUsers = allSampleUsers.filter(u => u.filter);
            
            const userLines = filteredUsers.map(u =>
                format.replace('{icon}', u.icon).replace('{username}', u.username).replace('{state}', u.state.toLowerCase())
            );
            
            previewEl.textContent = `${header} ${userLines.join(separator)}`;
        }

        // Update !who state icon
        async function updateWhoStateIcon(commandId, state, icon) {
            try {
                const messages = await window.electronAPI.getBotMessages();
                const msgIndex = messages.findIndex(m => m.id === commandId);
                if (msgIndex !== -1) {
                    // Initialize stateIcons if not present
                    if (!messages[msgIndex].stateIcons) {
                        messages[msgIndex].stateIcons = { JOINED: 'üî•', ACTIVE: 'üî•', SLEEPY: 'üò¥', AFK: 'üí§', LURK: 'üëÅÔ∏è', BOT: 'ü§ñ' };
                    }
                    // Update the specific state icon
                    messages[msgIndex].stateIcons[state] = icon;
                    // Also update JOINED if ACTIVE is changed (they share the same icon)
                    if (state === 'ACTIVE') {
                        messages[msgIndex].stateIcons['JOINED'] = icon;
                    }
                    await window.electronAPI.saveBotMessages(messages);
                    // Update preview
                    updateWhoPreview(commandId);
                    console.log(`[Dashboard] Updated ${state} icon for ${commandId} to ${icon}`);
                }
            } catch (error) {
                console.error('[Dashboard] Error updating who state icon:', error);
            }
        }

        // Update !who state filter
        async function updateWhoStateFilter(commandId, state, enabled) {
            try {
                const messages = await window.electronAPI.getBotMessages();
                const msgIndex = messages.findIndex(m => m.id === commandId);
                if (msgIndex !== -1) {
                    // Initialize stateFilters if not present
                    if (!messages[msgIndex].stateFilters) {
                        messages[msgIndex].stateFilters = { JOINED: true, ACTIVE: true, SLEEPY: true, AFK: true, LURK: true };
                    }
                    // Update the specific state filter
                    messages[msgIndex].stateFilters[state] = enabled;
                    await window.electronAPI.saveBotMessages(messages);
                    // Update preview
                    updateWhoPreview(commandId);
                    console.log(`[Dashboard] Updated ${state} filter for ${commandId} to ${enabled}`);
                }
            } catch (error) {
                console.error('[Dashboard] Error updating who state filter:', error);
            }
        }

        // Helper function to create member DOM element
        function createMemberElement(member, index) {
            const now = Date.now();
            const hashColor = (username) => {
                const s = String(username || '');
                let hash = 0;
                for (let i = 0; i < s.length; i++) hash = s.charCodeAt(i) + ((hash << 5) - hash);
                const hue = Math.abs(hash % 360);
                return `hsl(${hue}, 70%, 60%)`;
            };

            const isTestUser = member.username && member.username.startsWith('TestUser');
            const memberId = 'member-' + String(member.userId || member.username || '').replace(/[^a-zA-Z0-9_-]/g, '_');
            const uid = escapeJsQuoted(member.userId || '');
            const uname = escapeJsQuoted(member.username || '');
            const unameHtml = escapeHtml(member.username || '');
            const inChat = !!member.inChat;
            const lastMessage = member.lastMessage || 0;
            const recentlyActive = !!(lastMessage && (now - lastMessage) <= DASH_ACTIVE_WINDOW_MS);
            const inCampfire = !!(member.inCampfire || member.joined);
            
            // Use actual user state from widget if available (normalize to lowercase for comparison)
            const userState = member.userState ? member.userState.toLowerCase() : null;
            const isLurking = member.isLurking || false;
            
            // Determine display status based on user state
            // Priority order: LURK > AFK > SLEEPY > ACTIVE > JOINED
            // Note: AFK takes precedence over SLEEPY in the member list
            let status, statusText, statusIcon;
            if (!inCampfire) {
                status = 'not-joined';
                statusText = 'In Chat';
                statusIcon = '';
            } else if (isLurking || userState === 'lurk') {
                status = 'lurking';
                statusText = 'üåô Lurking';
                statusIcon = '';
            } else if (userState === 'afk') {
                // AFK takes precedence over SLEEPY in the member list
                status = 'afk';
                statusText = 'üí§ AFK';
                statusIcon = '';
            } else if (userState === 'sleepy') {
                status = 'sleepy';
                statusText = 'üò¥ Sleepy';
                statusIcon = '';
            } else if (userState === 'active') {
                status = 'active-in-campfire';
                statusText = 'üü¢ Active';
                statusIcon = '';
            } else if (userState === 'joined') {
                status = 'joined';
                statusText = 'üîµ Joined';
                statusIcon = '';
            } else {
                // Default: unknown state - show as joined if in campfire
                status = 'joined';
                statusText = 'Joined';
                statusIcon = '';
            }
            
            const twitchColor = member.twitchColor || null;
            const joinedColor = twitchColor || hashColor(member.username);
            const nameColor = (status === 'not-joined') ? '#777' : (status === 'active' ? '#fff' : joinedColor);
            const zzz = ''; // No longer needed - status text shows state

            const div = document.createElement('div');
            div.id = memberId;
            div.className = 'member-item';
            div.style.cssText = 'background: #1f1f1f; border: 1px solid #3a3a3a; border-radius: 6px; padding: 8px 12px; display: flex; justify-content: space-between; align-items: center; min-height: 40px;';

            if (isTestUser) {
                div.innerHTML = `
                    <div class="member-info" style="flex: 1; display: flex; align-items: center; gap: 10px;">
                        <span class="member-name" style="font-family: 'UsernameFont', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; font-weight: bold; font-size: 14px; color: #fff;">${unameHtml}</span>
                        <span class="member-status" style="font-size: 11px; color: #888;">${member.joined ? 'Joined' : 'Not joined'}</span>
                    </div>
                    <div class="member-actions" style="display: flex; gap: 8px; align-items: center;">
                        <button class="btn" onclick="dashboardOpenMemberEdit('${uid}', '${uname}')" style="padding: 6px 12px; background: #444; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">Edit</button>
                        <div class="toggle-switch ${member.joined ? 'active' : ''}" onclick="dashboardToggleTestUser('${uid}', '${uname}')" style="cursor: pointer; width: 50px; height: 24px; background: ${member.joined ? '#4caf50' : '#444'}; border-radius: 12px; position: relative; transition: background 0.3s; box-shadow: inset 0 1px 3px rgba(0,0,0,0.3);">
                            <div style="position: absolute; top: 2px; left: ${member.joined ? '28px' : '2px'}; width: 20px; height: 20px; background: white; border-radius: 50%; transition: left 0.3s ease; box-shadow: 0 2px 4px rgba(0,0,0,0.2);"></div>
                        </div>
                    </div>
                `;
            } else {
                const restoredIcon = member.restored ? '<span title="Restored from previous session; may have disconnected" style="margin-left:4px;opacity:0.85;">üìå</span>' : '';
                div.innerHTML = `
                    <div class="member-info" style="flex: 1; display: flex; align-items: center; gap: 10px;">
                        <span class="member-name status-${status}" style="font-family: 'UsernameFont', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; font-weight: bold; font-size: 14px; color: ${nameColor};">${unameHtml}</span>${zzz}${restoredIcon}
                        <span class="member-status" style="font-size: 11px; color: #888;">${statusText}</span>
                    </div>
                    <div class="member-actions" style="display: flex; gap: 8px; align-items: center;">
                        ${member.joined
                            ? `<button class="btn danger" onclick="dashboardLeaveMember('${uid}', '${uname}')" style="padding: 6px 12px; background: #ff4444; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">Leave</button>`
                            : `<button class="btn" onclick="dashboardJoinMember('${uid}', '${uname}')" style="padding: 6px 12px; background: #4caf50; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">Join</button>`
                        }
                        <button class="btn" onclick="dashboardOpenMemberEdit('${uid}', '${uname}')" style="padding: 6px 12px; background: #444; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">Edit</button>
                    </div>
                `;
            }

            return div;
        }

        // Helper functions (if not already defined)
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function escapeJsQuoted(text) {
            return String(text || '').replace(/'/g, "\\'").replace(/"/g, '\\"');
        }

        // Bot message management functions
        async function toggleBotMessage(id) {
            try {
                let messages = await window.electronAPI.getBotMessages();

                const msg = messages.find(m => m.id === id);
                if (msg) {
                    msg.enabled = !msg.enabled;
                } else {
                    // Add default message if not found
                    const defaults = [
                        { id: 'help', name: 'Help Command', message: 'Commands: join with "!join" ‚Ä¢ !leave ‚Ä¢ !cw [deg] ‚Ä¢ !ccw [deg] ‚Ä¢ !color <hex> ‚Ä¢ !sprite <name> ‚Ä¢ !next/!back ‚Ä¢ !spin ‚Ä¢ !dance ‚Ä¢ !random ‚Ä¢ !reset ‚Ä¢ !still/!wander', enabled: true },
                        { id: 'reset', name: 'Reset Confirmation', message: '{username} reset their campfire look.', enabled: true },
                        { id: 'spin', name: 'Spin Confirmation', message: '{username} spins!', enabled: true },
                        { id: 'dance', name: 'Dance Confirmation', message: '{username} dances!', enabled: true },
                        { id: 'still', name: 'Still Confirmation', message: '{username} is now still.', enabled: true },
                        { id: 'wander', name: 'Wander Confirmation', message: '{username} is now wandering.', enabled: true }
                    ];
                    const defaultMsg = defaults.find(m => m.id === id);
                    if (defaultMsg) {
                        messages.push({ ...defaultMsg, enabled: false });
                    }
                }

                await window.electronAPI.saveBotMessages(messages);
                await reloadCurrentCommandSubTab();
            } catch (e) {
                console.error('Error toggling bot message:', e);
            }
        }

        async function toggleCommandOption(id, option, value) {
            try {
                let messages = await window.electronAPI.getBotMessages();
                const msg = messages.find(m => m.id === id);
                if (msg) {
                    msg[option] = value;
                    await window.electronAPI.saveBotMessages(messages);
                    await reloadCurrentCommandSubTab();
                }
            } catch (e) {
                console.error('Error toggling command option:', e);
            }
        }

        async function editBotMessage(id) {
            try {
                // Get saved messages from main process
                let savedMessages = await window.electronAPI.getBotMessages();
                
                // Define default messages (same as in loadBotMessages)
                const defaultBotMessages = [
                    { id: 'help', name: 'Help Command', commands: ['!help'], command: '!help', message: 'Commands: join with "!join" ‚Ä¢ !leave ‚Ä¢ !cw [deg] ‚Ä¢ !ccw [deg] ‚Ä¢ !color <hex> ‚Ä¢ !sprite <name> ‚Ä¢ !next/!back ‚Ä¢ !spin ‚Ä¢ !dance ‚Ä¢ !sparkle ‚Ä¢ !random ‚Ä¢ !reset ‚Ä¢ !still/!wander', enabled: true, silent: false, respondAllChats: true, allowNonCampers: true, isDefault: true },
                    { id: 'reset', name: 'Reset Command', commands: ['!reset'], command: '!reset', message: '{username} reset their campfire look.', enabled: true, silent: false, respondAllChats: true, allowNonCampers: false, isDefault: true },
                    { id: 'spin', name: 'Spin Command', commands: ['!spin'], command: '!spin', message: '{username} spins!', enabled: true, silent: false, respondAllChats: true, allowNonCampers: false, isDefault: true },
                    { id: 'dance', name: 'Dance Command', commands: ['!dance'], command: '!dance', message: '{username} dances!', enabled: true, silent: false, respondAllChats: true, allowNonCampers: false, isDefault: true },
                    { id: 'sparkle', name: 'Sparkle Command', commands: ['!sparkle'], command: '!sparkle', message: '{username} sparkles! ‚ú®', enabled: true, silent: false, respondAllChats: true, allowNonCampers: false, isDefault: true },
                    { id: 'still', name: 'Still Command', commands: ['!still'], command: '!still', message: '{username} is now still.', enabled: true, silent: false, respondAllChats: true, allowNonCampers: false, isDefault: true },
                    { id: 'roam', name: 'Roam Command', commands: ['!roam'], command: '!roam', message: '{username} is now roaming.', enabled: true, silent: false, respondAllChats: true, allowNonCampers: false, isDefault: true },
                    { id: 'wander', name: 'Wander Command', commands: ['!wander'], command: '!wander', message: '{username} is now wandering.', enabled: true, silent: false, respondAllChats: true, allowNonCampers: false, isDefault: true },
                    { id: 'join', name: 'Join Announcement', commands: [], command: '', message: '{username} joined the campfire!', enabled: true, silent: false, respondAllChats: true, allowNonCampers: false, isDefault: true },
                    { id: 'leave', name: 'Leave Announcement', commands: [], command: '', message: '{username} left the campfire.', enabled: true, silent: false, respondAllChats: true, allowNonCampers: false, isDefault: true },
                    { id: 'afk', name: 'AFK Announcement', commands: [], command: '', message: '{username} went AFK üí§', enabled: true, silent: false, respondAllChats: true, allowNonCampers: true, isDefault: true },
                    { id: 'lurk', name: 'Lurk Announcement', commands: [], command: '', message: '{username} is now lurking üëÅÔ∏è', enabled: true, silent: false, respondAllChats: true, allowNonCampers: true, isDefault: true },
                    { id: 'return', name: 'Return Command', commands: ['!return', '!imback'], command: '!return', message: '{username} has returned!', enabled: true, silent: false, respondAllChats: true, allowNonCampers: false, isDefault: true, category: 'APP', cooldown: 3, cooldownEnabled: true, cooldownType: 'per-user', undeletable: true, action: 'handleReturnCommand', returnFromStates: { AFK: true, SLEEPY: false, LURK: true } },
                    // Auto-state commands
                    { id: 'sleepy', name: 'Sleepy State', commands: [], command: '', message: '{username} is now sleepy üò¥', enabled: true, silent: false, respondAllChats: true, allowNonCampers: false, isDefault: true, category: 'AUTO_STATE' },
                    { id: 'auto-afk', name: 'Auto AFK', commands: [], command: '', message: '{username} went AFK üí§', enabled: true, silent: false, respondAllChats: true, allowNonCampers: false, isDefault: true, category: 'AUTO_STATE' },
                    { id: 'auto-return', name: 'Auto Return', commands: [], command: '', message: '{username} is back! üëã', enabled: true, silent: false, respondAllChats: true, allowNonCampers: false, isDefault: true, category: 'AUTO_STATE' },
                    { id: 'auto-leave', name: 'Auto Leave', commands: [], command: '', message: '{username} has left due to inactivity', enabled: true, silent: false, respondAllChats: true, allowNonCampers: false, isDefault: true, category: 'AUTO_STATE' },
                    // APP commands
                    { id: 'who', name: 'Who Command', commands: ['!who'], command: '!who', message: 'üî• Around the campfire:', enabled: true, silent: false, respondAllChats: true, allowNonCampers: true, isDefault: true, category: 'APP', cooldown: 30, cooldownEnabled: true, cooldownType: 'global', undeletable: true, userLineFormat: '{icon} {username}', userSeparator: ' ‚Ä¢ ', stateIcons: { JOINED: 'üî•', ACTIVE: 'üî•', SLEEPY: 'üò¥', AFK: 'üí§', LURK: 'üëÅÔ∏è', BOT: 'ü§ñ' }, stateFilters: { JOINED: true, ACTIVE: true, SLEEPY: true, AFK: true, LURK: true } },
                    { id: 'duel', name: 'Duel Command', commands: ['!duel'], command: '!duel', message: '{winner} defeats {loser} in a duel! ‚öîÔ∏è', enabled: false, silent: false, respondAllChats: true, allowNonCampers: true, isDefault: true, category: 'APP', cooldown: 3, cooldownEnabled: true, cooldownType: 'per-user', undeletable: true, action: 'handleDuelCommand' },
                    { id: 'roll', name: 'Roll Command', commands: ['!roll'], command: '!roll', message: '{username} rolls {roll} (1-{max}) üé≤', enabled: false, silent: false, respondAllChats: true, allowNonCampers: true, isDefault: true, category: 'APP', cooldown: 3, cooldownEnabled: true, cooldownType: 'per-user', undeletable: true, action: 'handleRollCommand' }
                ];
                
                // Merge defaults with saved settings (saved settings override defaults)
                let messages = defaultBotMessages.map(defaultMsg => {
                    const savedMsg = savedMessages.find(m => m.id === defaultMsg.id);
                    return savedMsg ? { ...defaultMsg, ...savedMsg, isDefault: true } : defaultMsg;
                });
                
                // Add any custom messages from saved
                const customMessages = savedMessages.filter(m => !DEFAULT_BOT_MESSAGE_IDS.includes(m.id));
                messages = [...messages, ...customMessages];

                const msg = messages.find(m => m.id === id);
                if (!msg) return;

                // Create a modal dialog for editing
                const modal = document.createElement('div');
                modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); display: flex; align-items: center; justify-content: center; z-index: 10000;';

                const modalContent = document.createElement('div');
                modalContent.style.cssText = 'background: #2a2a2a; border: 1px solid #444; border-radius: 8px; padding: 20px; width: 500px; max-width: 90vw;';

                const title = document.createElement('h3');
                title.style.cssText = 'margin-top: 0; color: #fff;';
                title.textContent = `Edit Command: ${msg.name}`;

                const isAutoStateCommand = AUTO_STATE_COMMAND_IDS.includes(msg.id);
                const isAppCommand = APP_COMMAND_IDS.includes(msg.id);

                // For APP commands, show primary command as read-only and allow aliases
                // For other commands, show editable command triggers
                const primaryCommand = Array.isArray(msg.commands) && msg.commands.length > 0 ? msg.commands[0] : (msg.command || '');
                const existingAliases = Array.isArray(msg.commands) && msg.commands.length > 1
                    ? msg.commands.slice(1).join(', ')
                    : '';

                const commandDiv = document.createElement('div');
                commandDiv.style.cssText = isAutoStateCommand ? 'display: none;' : 'margin-bottom: 15px;';

                const commandLabel = document.createElement('label');
                commandLabel.style.cssText = 'display: block; color: #ccc; font-size: 12px; margin-bottom: 5px;';
                commandLabel.textContent = isAppCommand ? 'Primary Command:' : 'Command Triggers (comma-separated):';

                const commandInput = document.createElement('input');
                commandInput.type = 'text';
                if (isAppCommand) {
                    // For APP commands, primary command is read-only
                    commandInput.value = primaryCommand;
                    commandInput.readOnly = true;
                    commandInput.style.cssText = 'width: 100%; padding: 8px; background: #333; border: 1px solid #555; border-radius: 4px; color: #888; font-family: monospace; cursor: not-allowed;';
                } else {
                    commandInput.value = Array.isArray(msg.commands) ? msg.commands.join(', ') : (msg.command || '');
                    commandInput.placeholder = 'e.g., !help, !commands, !howto';
                    commandInput.style.cssText = 'width: 100%; padding: 8px; background: #1f1f1f; border: 1px solid #444; border-radius: 4px; color: #fff; font-family: monospace;';
                }

                // Aliases input for APP commands
                let aliasesInput = null;
                let aliasesLabel = null;
                if (isAppCommand) {
                    aliasesLabel = document.createElement('label');
                    aliasesLabel.style.cssText = 'display: block; color: #ccc; font-size: 12px; margin-bottom: 5px; margin-top: 10px;';
                    aliasesLabel.textContent = 'Aliases (comma-separated, optional):';

                    aliasesInput = document.createElement('input');
                    aliasesInput.type = 'text';
                    aliasesInput.value = existingAliases;
                    aliasesInput.placeholder = 'e.g., !campers, !list';
                    aliasesInput.style.cssText = 'width: 100%; padding: 8px; background: #1f1f1f; border: 1px solid #444; border-radius: 4px; color: #fff; font-family: monospace;';
                }

                // Add info text for auto-state commands
                const infoDiv = document.createElement('div');
                if (isAutoStateCommand) {
                    infoDiv.style.cssText = 'margin-bottom: 15px; padding: 10px; background: #1a3a1a; border: 1px solid #2a5a2a; border-radius: 4px;';
                    infoDiv.innerHTML = '<span style="color: #7f7;">‚ÑπÔ∏è This is an auto-triggered announcement. It fires automatically when a user\'s state changes due to inactivity.</span>';
                } else if (isAppCommand) {
                    infoDiv.style.cssText = 'margin-bottom: 15px; padding: 10px; background: #1a1a3a; border: 1px solid #2a2a5a; border-radius: 4px;';
                    infoDiv.innerHTML = '<span style="color: #77f;">‚ÑπÔ∏è This is an app-integrated command. The primary command cannot be changed, but you can add aliases.</span>';
                }

                // State filters for RETURN command
                let stateFiltersDiv = null;
                if (msg.id === 'return') {
                    stateFiltersDiv = document.createElement('div');
                    stateFiltersDiv.style.cssText = 'margin-bottom: 15px; padding: 10px; background: #1f1f1f; border: 1px solid #444; border-radius: 4px;';
                    
                    const returnFromStates = msg.returnFromStates || { AFK: true, SLEEPY: false, LURK: true };
                    
                    stateFiltersDiv.innerHTML = `
                        <div style="color: #ccc; font-size: 12px; margin-bottom: 8px;">Announce return from:</div>
                        <div style="display: flex; gap: 15px; flex-wrap: wrap;">
                            <label style="display: flex; align-items: center; gap: 5px; cursor: pointer; color: #fff; font-size: 13px;">
                                <input type="checkbox" id="returnFilterAFK" ${returnFromStates.AFK !== false ? 'checked' : ''} style="cursor: pointer;">
                                <span>AFK</span>
                            </label>
                            <label style="display: flex; align-items: center; gap: 5px; cursor: pointer; color: #fff; font-size: 13px;">
                                <input type="checkbox" id="returnFilterSLEEPY" ${returnFromStates.SLEEPY !== false ? 'checked' : ''} style="cursor: pointer;">
                                <span>SLEEPY</span>
                            </label>
                            <label style="display: flex; align-items: center; gap: 5px; cursor: pointer; color: #fff; font-size: 13px;">
                                <input type="checkbox" id="returnFilterLURK" ${returnFromStates.LURK !== false ? 'checked' : ''} style="cursor: pointer;">
                                <span>LURK</span>
                            </label>
                        </div>
                        <div style="color: #888; font-size: 11px; margin-top: 5px;">Only checked states will trigger the return announcement</div>
                    `;
                }

                const messageDiv = document.createElement('div');
                messageDiv.style.cssText = 'margin-bottom: 20px;';

                const messageLabel = document.createElement('label');
                messageLabel.style.cssText = 'display: block; color: #ccc; font-size: 12px; margin-bottom: 5px;';
                messageLabel.textContent = 'Bot Response:';

                const messageInput = document.createElement('textarea');
                messageInput.value = msg.message || '';
                messageInput.style.cssText = 'width: 100%; height: 80px; padding: 8px; background: #1f1f1f; border: 1px solid #444; border-radius: 4px; color: #fff; resize: vertical; font-family: monospace;';

                const buttonDiv = document.createElement('div');
                buttonDiv.style.cssText = 'display: flex; gap: 10px; justify-content: flex-end;';

                const cancelBtn = document.createElement('button');
                cancelBtn.textContent = 'Cancel';
                cancelBtn.style.cssText = 'padding: 8px 16px; background: #444; color: #fff; border: none; border-radius: 4px; cursor: pointer;';

                const saveBtn = document.createElement('button');
                saveBtn.textContent = 'Save Changes';
                saveBtn.style.cssText = 'padding: 8px 16px; background: #4caf50; color: #fff; border: none; border-radius: 4px; cursor: pointer;';

                // Assemble the modal
                commandDiv.appendChild(commandLabel);
                commandDiv.appendChild(commandInput);
                if (isAppCommand && aliasesLabel && aliasesInput) {
                    commandDiv.appendChild(aliasesLabel);
                    commandDiv.appendChild(aliasesInput);
                }

                messageDiv.appendChild(messageLabel);
                messageDiv.appendChild(messageInput);

                buttonDiv.appendChild(cancelBtn);
                buttonDiv.appendChild(saveBtn);

                modalContent.appendChild(title);
                if (isAutoStateCommand || isAppCommand) {
                    modalContent.appendChild(infoDiv);
                }
                modalContent.appendChild(commandDiv);
                if (stateFiltersDiv) {
                    modalContent.appendChild(stateFiltersDiv);
                }
                modalContent.appendChild(messageDiv);
                modalContent.appendChild(buttonDiv);

                modal.appendChild(modalContent);
                document.body.appendChild(modal);

                // Focus on appropriate input
                setTimeout(() => {
                    if (isAutoStateCommand) {
                        messageInput.focus();
                    } else if (isAppCommand && aliasesInput) {
                        aliasesInput.focus();
                    } else {
                        commandInput.focus();
                    }
                }, 100);

                // Event handlers
                cancelBtn.onclick = () => modal.remove();

                saveBtn.onclick = async () => {
                    const commandText = commandInput.value.trim();
                    const newMessage = messageInput.value.trim();

                    if (newMessage) {
                        // For auto-state commands, commands array is empty (not user-triggered)
                        // For other commands, parse comma-separated commands
                        const isAutoStateCmd = AUTO_STATE_COMMAND_IDS.includes(msg.id);
                        const isAppCmd = APP_COMMAND_IDS.includes(msg.id);

                        if (!isAutoStateCmd && !isAppCmd && !commandText) {
                            alert('At least one command is required.');
                            return;
                        }

                        if (!isAutoStateCmd && !isAppCmd) {
                            // Parse comma-separated commands for regular commands
                            const commands = commandText.split(',').map(cmd => cmd.trim().toLowerCase()).filter(cmd => cmd.length > 0);
                            if (commands.length === 0) {
                                alert('At least one command is required.');
                                return;
                            }
                            msg.commands = commands;
                            msg.command = commands[0]; // Keep backward compatibility
                        } else if (isAppCmd) {
                            // For APP commands, keep primary command and add aliases
                            const aliasesText = aliasesInput ? aliasesInput.value.trim() : '';
                            const aliases = aliasesText
                                ? aliasesText.split(',').map(cmd => cmd.trim().toLowerCase()).filter(cmd => cmd.length > 0)
                                : [];
                            // Combine primary command with aliases
                            msg.commands = [primaryCommand, ...aliases];
                            msg.command = primaryCommand;
                        }

                        // Save state filters for RETURN command
                        if (msg.id === 'return') {
                            const afkCheckbox = document.getElementById('returnFilterAFK');
                            const sleepyCheckbox = document.getElementById('returnFilterSLEEPY');
                            const lurkCheckbox = document.getElementById('returnFilterLURK');
                            msg.returnFromStates = {
                                AFK: afkCheckbox ? afkCheckbox.checked : true,
                                SLEEPY: sleepyCheckbox ? sleepyCheckbox.checked : false,
                                LURK: lurkCheckbox ? lurkCheckbox.checked : true
                            };
                        }

                        msg.message = newMessage;

                        await window.electronAPI.saveBotMessages(messages);
                        modal.remove();
                        await reloadCurrentCommandSubTab();
                    } else {
                        alert('Message is required.');
                    }
                };

                // Close on escape
                modal.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') modal.remove();
                });

            } catch (e) {
                console.error('Error editing bot message:', e);
            }
        }

        async function deleteBotMessage(id) {
            if (!confirm('Are you sure you want to delete this bot message?')) return;

            try {
                let messages = await window.electronAPI.getBotMessages();

                messages = messages.filter(m => m.id !== id);
                await window.electronAPI.saveBotMessages(messages);
                await reloadCurrentCommandSubTab();
            } catch (e) {
                console.error('Error deleting bot message:', e);
            }
        }

        function addBotMessage() {
            try {
                // Create a modal dialog for adding new command
                const modal = document.createElement('div');
                modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); display: flex; align-items: center; justify-content: center; z-index: 10000;';

                const modalContent = document.createElement('div');
                modalContent.style.cssText = 'background: #2a2a2a; border: 1px solid #444; border-radius: 8px; padding: 20px; width: 500px; max-width: 90vw;';

                const title = document.createElement('h3');
                title.style.cssText = 'margin-top: 0; color: #fff; margin-bottom: 20px;';
                title.textContent = 'Add New Command';

                const nameDiv = document.createElement('div');
                nameDiv.style.cssText = 'margin-bottom: 15px;';

                const nameLabel = document.createElement('label');
                nameLabel.style.cssText = 'display: block; color: #ccc; font-size: 12px; margin-bottom: 5px;';
                nameLabel.textContent = 'Command Name:';

                const nameInput = document.createElement('input');
                nameInput.type = 'text';
                nameInput.placeholder = 'e.g., Custom Command';
                nameInput.style.cssText = 'width: 100%; padding: 8px; background: #1f1f1f; border: 1px solid #444; border-radius: 4px; color: #fff;';

                const commandDiv = document.createElement('div');
                commandDiv.style.cssText = 'margin-bottom: 15px;';

                const commandLabel = document.createElement('label');
                commandLabel.style.cssText = 'display: block; color: #ccc; font-size: 12px; margin-bottom: 5px;';
                commandLabel.textContent = 'Command Triggers (comma-separated):';

                const commandInput = document.createElement('input');
                commandInput.type = 'text';
                commandInput.placeholder = 'e.g., !custom, !alias, !shortcut';
                commandInput.style.cssText = 'width: 100%; padding: 8px; background: #1f1f1f; border: 1px solid #444; border-radius: 4px; color: #fff; font-family: monospace;';

                const messageDiv = document.createElement('div');
                messageDiv.style.cssText = 'margin-bottom: 20px;';

                const messageLabel = document.createElement('label');
                messageLabel.style.cssText = 'display: block; color: #ccc; font-size: 12px; margin-bottom: 5px;';
                messageLabel.textContent = 'Bot Response:';

                const messageInput = document.createElement('textarea');
                messageInput.placeholder = "Bot's response message...";
                messageInput.style.cssText = 'width: 100%; height: 80px; padding: 8px; background: #1f1f1f; border: 1px solid #444; border-radius: 4px; color: #fff; resize: vertical; font-family: monospace;';

                const buttonDiv = document.createElement('div');
                buttonDiv.style.cssText = 'display: flex; gap: 10px; justify-content: flex-end;';

                const cancelBtn = document.createElement('button');
                cancelBtn.textContent = 'Cancel';
                cancelBtn.style.cssText = 'padding: 8px 16px; background: #444; color: #fff; border: none; border-radius: 4px; cursor: pointer;';

                const saveBtn = document.createElement('button');
                saveBtn.textContent = 'Add Command';
                saveBtn.style.cssText = 'padding: 8px 16px; background: #4caf50; color: #fff; border: none; border-radius: 4px; cursor: pointer;';

                // Assemble the modal
                nameDiv.appendChild(nameLabel);
                nameDiv.appendChild(nameInput);

                commandDiv.appendChild(commandLabel);
                commandDiv.appendChild(commandInput);

                messageDiv.appendChild(messageLabel);
                messageDiv.appendChild(messageInput);

                buttonDiv.appendChild(cancelBtn);
                buttonDiv.appendChild(saveBtn);

                modalContent.appendChild(title);
                modalContent.appendChild(nameDiv);
                modalContent.appendChild(commandDiv);
                modalContent.appendChild(messageDiv);
                modalContent.appendChild(buttonDiv);

                modal.appendChild(modalContent);
                document.body.appendChild(modal);

                // Focus on name input
                setTimeout(() => nameInput.focus(), 100);

                // Event handlers
                cancelBtn.onclick = () => modal.remove();

                saveBtn.onclick = async () => {
                    const name = nameInput.value.trim();
                    const commandText = commandInput.value.trim();
                    const message = messageInput.value.trim();

                    if (name && commandText && message) {
                        // Parse comma-separated commands
                        const commands = commandText.split(',').map(cmd => cmd.trim().toLowerCase()).filter(cmd => cmd.length > 0);
                        if (commands.length === 0) {
                            alert('At least one command is required.');
                            return;
                        }

                        let messages = await window.electronAPI.getBotMessages();

                        // Generate unique ID
                        const id = 'custom_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);

                        messages.push({
                            id: id,
                            name: name,
                            commands: commands,
                            command: commands[0], // Keep backward compatibility
                            message: message,
                            enabled: true,
                            silent: false,
                            respondAllChats: true,
                            allowNonCampers: false
                        });

                        await window.electronAPI.saveBotMessages(messages);
                        modal.remove();
                        await reloadCurrentCommandSubTab();
                    } else {
                        alert('All fields are required.');
                    }
                };

                // Close on escape
                modal.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') modal.remove();
                });

            } catch (e) {
                console.error('Error adding bot message:', e);
            }
        }
        
        // Dashboard member control functions
        async function dashboardToggleTestUser(userId, username) {
            if (!window.electronAPI) return;
            
            try {
                const widgetUsers = await window.electronAPI.getWidgetUsers();
                const isInWidget = widgetUsers.find(w => {
                    const wUserId = (w.userId || '').toLowerCase();
                    const wUsername = (w.username || '').toLowerCase();
                    const checkUserId = (userId || '').toLowerCase();
                    const checkUsername = (username || '').toLowerCase();
                    return wUserId === checkUserId || wUsername === checkUsername;
                });
                
                if (isInWidget) {
                    // Remove user
                    const result = await window.electronAPI.removeTestUserFromWidget(userId, username);
                    if (!result || !result.success) {
                        console.error('Failed to remove test user:', result);
                        alert('Failed to remove test user: ' + (result?.error || 'Unknown error'));
                        return;
                    }
                    console.log('Test user removed:', username);
                } else {
                    // Add user
                    const result = await window.electronAPI.addTestUserToWidget(userId, username);
                    if (!result || !result.success) {
                        console.error('Failed to add test user:', result);
                        alert('Failed to add test user: ' + (result?.error || 'Unknown error'));
                        return;
                    }
                    console.log('Test user added:', username);
                }
                
                // Refresh members list to update toggle states
                if (typeof loadDashboardMembers === 'function') {
                    await loadDashboardMembers();
                }
                
                // Sync preview iframe
                const iframe = document.getElementById('fullWidgetPreview');
                if (iframe && iframe.contentWindow) {
                    setTimeout(async () => {
                        const updatedUsers = await window.electronAPI.getWidgetUsers();
                        iframe.contentWindow.postMessage({
                            type: 'syncFullState',
                            users: updatedUsers
                        }, '*');
                    }, 200);
                }
                
                // Refresh members list after toggle
                await loadDashboardMembers();
            } catch (e) {
                console.error('Error toggling test user:', e);
                alert('Error toggling test user: ' + e.message);
            }
        }
        
        async function dashboardJoinMember(userId, username) {
            if (!window.electronAPI) return;
            await window.electronAPI.joinMember(userId, username);
            // Refresh members list
            await loadDashboardMembers();
        }
        
        async function dashboardLeaveMember(userId, username) {
            if (!window.electronAPI) return;
            if (!confirm('Remove this member from the campfire?')) return;
            await window.electronAPI.kickMember(userId);
            // Refresh members list
            await loadDashboardMembers();
        }
        
        async function dashboardOpenMemberEdit(userId, username) {
            if (!window.electronAPI) return;
            // Open Viewer Dashboard (sprite settings) for this member
            if (window.electronAPI.openMemberDashboard) {
                await window.electronAPI.openMemberDashboard(userId, username);
            } else {
                alert(`Edit settings for ${username} - Viewer Dashboard not available`);
            }
        }

        function toggleMute(userId, username) {
            const key = userId || username;
            memberMuteStates[key] = !memberMuteStates[key];
            
            // Send mute state to widget
            const iframe = document.getElementById('fullWidgetPreview');
            if (iframe && iframe.contentWindow) {
                iframe.contentWindow.postMessage({
                    type: 'memberMute',
                    userId: userId,
                    username: username,
                    muted: memberMuteStates[key]
                }, '*');
            }
            
            // Save to localStorage
            localStorage.setItem('memberMuteStates', JSON.stringify(memberMuteStates));
            
            loadDashboardMembers();
        }

        function toggleStill(userId, username) {
            const key = userId || username;
            memberStillStates[key] = !memberStillStates[key];
            
            // Send still state to widget
            const iframe = document.getElementById('fullWidgetPreview');
            if (iframe && iframe.contentWindow) {
                iframe.contentWindow.postMessage({
                    type: 'memberStill',
                    userId: userId,
                    username: username,
                    still: memberStillStates[key]
                }, '*');
            }
            
            // Save to localStorage
            localStorage.setItem('memberStillStates', JSON.stringify(memberStillStates));
            
            loadDashboardMembers();
        }

        function kickMember(userId, username) {
            if (!confirm(`Are you sure you want to kick ${username} from the campfire?`)) {
                return;
            }

            // Remove from widget
            const iframe = document.getElementById('fullWidgetPreview');
            if (iframe && iframe.contentWindow) {
                iframe.contentWindow.postMessage({
                    type: 'kickMember',
                    userId: userId,
                    username: username
                }, '*');
            }

            // Remove from localStorage
            try {
                const savedUsers = localStorage.getItem('campfireUsers');
                const users = savedUsers ? JSON.parse(savedUsers) : [];
                const filtered = users.filter(u => (u.userId && u.userId !== userId) && (u.username !== username));
                localStorage.setItem('campfireUsers', JSON.stringify(filtered));
            } catch (e) {
                console.error('Error removing member:', e);
            }

            // Remove from mute/still states
            const key = userId || username;
            delete memberMuteStates[key];
            delete memberStillStates[key];
            localStorage.setItem('memberMuteStates', JSON.stringify(memberMuteStates));
            localStorage.setItem('memberStillStates', JSON.stringify(memberStillStates));

            loadDashboardMembers();
        }

        // Load mute/still states on init
        function loadMemberStates() {
            try {
                const savedMutes = localStorage.getItem('memberMuteStates');
                if (savedMutes) memberMuteStates = JSON.parse(savedMutes);
                
                const savedStills = localStorage.getItem('memberStillStates');
                if (savedStills) memberStillStates = JSON.parse(savedStills);
            } catch (e) {
                console.error('Error loading member states:', e);
            }
        }

        // Update switchTab to refresh members list
        const originalSwitchTab = switchTab;
        switchTab = function(tabName, element) {
            originalSwitchTab(tabName, element);
            if (tabName === 'members') {
                loadDashboardMembers();
                // Refresh every 2 seconds when on members tab
                if (memberManagementInterval) clearInterval(memberManagementInterval);
                memberManagementInterval = setInterval(loadDashboardMembers, 2000);
            } else if (tabName === 'commands') {
                if (typeof loadStateCommands === 'function') loadStateCommands();
            } else {
                if (memberManagementInterval) {
                    clearInterval(memberManagementInterval);
                    memberManagementInterval = null;
                }
            }
        };

        // Initialize member states on load
        loadMemberStates();
        
        // Open chat popout window
        async function openChatPopout() {
            if (!window.electronAPI) {
                showNotification('‚ùå Chat popout is only available in the desktop app.');
                return;
            }
            
            try {
                if (window.electronAPI.openChatPopout) {
                    await window.electronAPI.openChatPopout();
                } else {
                    showNotification('‚ùå Chat popout not available in this version.');
                }
            } catch (e) {
                console.error('Error opening chat popout:', e);
                showNotification('‚ùå Failed to open chat popout.');
            }
        }

        // Show fade-in/fade-out notification
        function showNotification(message) {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.classList.add('show');
            
            // Fade out after 1 second
            setTimeout(() => {
                notification.classList.remove('show');
            }, 1000);
        }

        // Show confirmation popup
        let confirmationCallback = null;
        function showConfirmation(title, message, callback, okText = 'Confirm', cancelText = 'Cancel') {
            confirmationCallback = callback;
            document.getElementById('confirmationTitle').textContent = title;
            document.getElementById('confirmationMessage').textContent = message;
            document.getElementById('confirmBtn').textContent = okText;
            document.getElementById('cancelBtn').textContent = cancelText;
            document.getElementById('confirmationPopup').classList.add('show');
        }

        // Close confirmation popup
        function closeConfirmation(confirmed) {
            document.getElementById('confirmationPopup').classList.remove('show');
            if (confirmationCallback) {
                if (confirmed) {
                    confirmationCallback();
                }
                confirmationCallback = null;
            }
        }

    </script>

    <!-- Notification popup -->
    <div id="notification" class="notification"></div>

    <!-- Confirmation popup -->
    <div id="confirmationPopup" class="confirmation-popup">
        <h3 id="confirmationTitle">Confirm Action</h3>
        <p id="confirmationMessage"></p>
        <div class="confirmation-buttons">
            <button id="cancelBtn" class="cancel-btn" onclick="closeConfirmation(false)">Cancel</button>
            <button id="confirmBtn" class="confirm-btn" onclick="closeConfirmation(true)">Confirm</button>
        </div>
    </div>
</body>
</html>
