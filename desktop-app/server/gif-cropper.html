<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Batch GIF Cropper</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: #1a1a1a;
            color: #fff;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        h1 {
            margin-bottom: 30px;
            color: #ff6b35;
        }
        
        .upload-area {
            border: 2px dashed #444;
            border-radius: 8px;
            padding: 40px;
            text-align: center;
            background: #222;
            margin-bottom: 30px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .upload-area:hover {
            border-color: #ff6b35;
            background: #2a2a2a;
        }
        
        .upload-area.dragover {
            border-color: #ff6b35;
            background: #333;
        }
        
        input[type="file"] {
            display: none;
        }
        
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        label {
            font-size: 14px;
            color: #aaa;
        }
        
        input[type="number"] {
            padding: 10px;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 4px;
            color: #fff;
            font-size: 16px;
        }
        
        .crop-mode {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .crop-mode button {
            flex: 1;
            padding: 12px;
            background: #333;
            border: 2px solid #444;
            border-radius: 4px;
            color: #fff;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .crop-mode button.active {
            background: #ff6b35;
            border-color: #ff6b35;
        }
        
        .crop-mode button:hover {
            background: #444;
        }
        
        .crop-mode button.active:hover {
            background: #ff8c5a;
        }
        
        .sides-controls {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-top: 15px;
        }
        
        button {
            padding: 12px 24px;
            background: #ff6b35;
            border: none;
            border-radius: 4px;
            color: #fff;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        button:hover {
            background: #ff8c5a;
        }
        
        button:disabled {
            background: #555;
            cursor: not-allowed;
        }
        
        .preview-area {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }
        
        .preview-card {
            background: #222;
            border-radius: 8px;
            padding: 20px;
        }
        
        .preview-card h3 {
            margin-bottom: 15px;
            color: #ff6b35;
        }
        
        .preview-image {
            width: 100%;
            max-width: 300px;
            height: auto;
            border-radius: 4px;
            margin-bottom: 10px;
            display: block;
        }
        
        .status {
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 20px;
        }
        
        .status.info {
            background: #2a4a7a;
            color: #aaccff;
        }
        
        .status.success {
            background: #2a7a4a;
            color: #aaffcc;
        }
        
        .status.error {
            background: #7a2a2a;
            color: #ffaacc;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>‚úÇÔ∏è Batch GIF Cropper</h1>
        
        <div id="status" class="status info" style="display: none;"></div>
        
        <div class="upload-area" id="uploadArea">
            <p style="font-size: 18px; margin-bottom: 10px;">üìÅ Drop GIF files here or click to browse</p>
            <p style="color: #888; font-size: 14px;">Supports multiple GIF files for batch processing</p>
            <input type="file" id="fileInput" accept="image/gif" multiple>
        </div>
        
        <div class="crop-mode">
            <button id="modeCentered" class="active" onclick="setCropMode('centered')">Centered Crop</button>
            <button id="modeSides" onclick="setCropMode('sides')">Crop Specific Sides</button>
        </div>
        
        <div class="controls" id="centeredControls">
            <div class="control-group">
                <label for="cropAmount">Crop Amount (px)</label>
                <input type="number" id="cropAmount" value="10" min="0" max="500">
                <small style="color: #888;">Amount to remove from each side</small>
            </div>
        </div>
        
        <div class="controls" id="sidesControls" style="display: none;">
            <div class="sides-controls">
                <div class="control-group">
                    <label for="cropTop">Top (px)</label>
                    <input type="number" id="cropTop" value="0" min="0" max="500">
                </div>
                <div class="control-group">
                    <label for="cropRight">Right (px)</label>
                    <input type="number" id="cropRight" value="0" min="0" max="500">
                </div>
                <div class="control-group">
                    <label for="cropBottom">Bottom (px)</label>
                    <input type="number" id="cropBottom" value="0" min="0" max="500">
                </div>
                <div class="control-group">
                    <label for="cropLeft">Left (px)</label>
                    <input type="number" id="cropLeft" value="0" min="0" max="500">
                </div>
            </div>
        </div>
        
        <div style="display: flex; gap: 10px; margin-bottom: 20px;">
            <button id="processBtn" onclick="processAll()">Process All GIFs</button>
            <button onclick="downloadAll()" style="background: #4a9;">Download All</button>
        </div>
        
        <div class="preview-area" id="previewArea"></div>
    </div>
    
    <!-- Using gif.js for encoding -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.js"></script>
    <script>
        // Load gifuct-js dynamically
        (function() {
            const script = document.createElement('script');
            script.src = 'https://unpkg.com/gifuct-js@2.1.2/dist/gifuct.min.js';
            script.async = true;
            script.onload = () => {
                console.log('‚úÖ gifuct-js loaded');
                window.GifuctLoaded = true;
            };
            script.onerror = () => {
                console.warn('‚ö†Ô∏è gifuct-js failed to load, will use fallback method');
                window.GifuctLoaded = false;
            };
            document.head.appendChild(script);
        })();
    </script>
    <script>
        const fileInput = document.getElementById('fileInput');
        const uploadArea = document.getElementById('uploadArea');
        const previewArea = document.getElementById('previewArea');
        const statusDiv = document.getElementById('status');
        const processBtn = document.getElementById('processBtn');
        
        let files = [];
        let cropMode = 'centered';
        const processedGifs = {};
        
        uploadArea.addEventListener('click', () => fileInput.click());
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });
        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });
        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            handleFiles(e.dataTransfer.files);
        });
        fileInput.addEventListener('change', (e) => handleFiles(e.target.files));
        
        function showStatus(message, type = 'info') {
            statusDiv.textContent = message;
            statusDiv.className = `status ${type}`;
            statusDiv.style.display = 'block';
            setTimeout(() => {
                if (type !== 'error') {
                    statusDiv.style.display = 'none';
                }
            }, 5000);
        }
        
        function setCropMode(mode) {
            cropMode = mode;
            document.getElementById('modeCentered').classList.toggle('active', mode === 'centered');
            document.getElementById('modeSides').classList.toggle('active', mode === 'sides');
            document.getElementById('centeredControls').style.display = mode === 'centered' ? 'grid' : 'none';
            document.getElementById('sidesControls').style.display = mode === 'sides' ? 'grid' : 'none';
        }
        
        function handleFiles(fileList) {
            files = Array.from(fileList).filter(f => f.type === 'image/gif' || f.name.toLowerCase().endsWith('.gif'));
            if (files.length === 0) {
                showStatus('Please select GIF files', 'error');
                return;
            }
            
            showStatus(`Loaded ${files.length} GIF file(s)`, 'success');
            previewArea.innerHTML = '';
            
            files.forEach((file, index) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    createPreviewCard(file.name, e.target.result, index);
                };
                reader.readAsDataURL(file);
            });
        }
        
        function createPreviewCard(filename, imageSrc, index) {
            const card = document.createElement('div');
            card.className = 'preview-card';
            card.id = `card-${index}`;
            card.innerHTML = `
                <h3>${filename}</h3>
                <div style="display: flex; gap: 20px; margin-bottom: 15px;">
                    <div>
                        <p style="color: #888; font-size: 12px; margin-bottom: 5px;">Original</p>
                        <img src="${imageSrc}" alt="${filename}" class="preview-image" id="preview-original-${index}">
                    </div>
                    <div id="preview-cropped-${index}" style="display: none;">
                        <p style="color: #4a9; font-size: 12px; margin-bottom: 5px;">Cropped</p>
                        <img id="preview-cropped-img-${index}" class="preview-image">
                    </div>
                </div>
                <div style="display: flex; gap: 10px;">
                    <button onclick="processSingle(${index})" id="process-btn-${index}">Process</button>
                    <button onclick="downloadSingle(${index})" id="download-btn-${index}" style="display: none; background: #4a9;">Download</button>
                </div>
            `;
            previewArea.appendChild(card);
        }
        
        async function waitForGifLibrary() {
            const maxWait = 10000;
            const startTime = Date.now();
            
            while (typeof GIF === 'undefined' && (Date.now() - startTime) < maxWait) {
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            
            if (typeof GIF === 'undefined') {
                throw new Error('GIF.js library failed to load. Please refresh the page.');
            }
        }
        
        async function processSingle(index) {
            const file = files[index];
            const btn = document.getElementById(`process-btn-${index}`);
            btn.disabled = true;
            btn.textContent = 'Processing...';
            
            showStatus(`Processing ${file.name}...`, 'info');
            
            try {
                await waitForGifLibrary();
                const croppedGif = await cropGif(file);
                
                processedGifs[index] = {
                    blob: croppedGif,
                    filename: file.name.replace(/\.gif$/i, '_cropped.gif')
                };
                
                // Show preview
                const previewCropped = document.getElementById(`preview-cropped-${index}`);
                const previewCroppedImg = document.getElementById(`preview-cropped-img-${index}`);
                const downloadBtn = document.getElementById(`download-btn-${index}`);
                
                const gifUrl = URL.createObjectURL(croppedGif);
                previewCroppedImg.src = gifUrl;
                previewCropped.style.display = 'block';
                downloadBtn.style.display = 'inline-block';
                btn.textContent = 'Processed ‚úì';
                btn.disabled = true;
                
                showStatus(`‚úÖ Processed ${file.name}`, 'success');
            } catch (error) {
                showStatus(`Error: ${error.message}`, 'error');
                console.error(error);
                btn.disabled = false;
                btn.textContent = 'Process';
            }
        }
        
        async function processAll() {
            if (files.length === 0) {
                showStatus('Please select GIF files first', 'error');
                return;
            }
            
            processBtn.disabled = true;
            processBtn.textContent = 'Processing...';
            
            try {
                await waitForGifLibrary();
            } catch (error) {
                showStatus(`Error: ${error.message}`, 'error');
                processBtn.disabled = false;
                processBtn.textContent = 'Process All GIFs';
                return;
            }
            
            for (let i = 0; i < files.length; i++) {
                showStatus(`Processing ${i + 1}/${files.length}: ${files[i].name}...`, 'info');
                try {
                    await processSingle(i);
                } catch (error) {
                    console.error(`Error processing ${files[i].name}:`, error);
                }
            }
            
            processBtn.disabled = false;
            processBtn.textContent = 'Process All GIFs';
            showStatus(`‚úÖ Processed ${files.length} file(s)`, 'success');
        }
        
        async function cropGif(file) {
            return new Promise((resolve, reject) => {
                // Get crop values
                let cropTop, cropRight, cropBottom, cropLeft;
                
                if (cropMode === 'centered') {
                    const cropAmount = parseInt(document.getElementById('cropAmount').value) || 0;
                    cropTop = cropBottom = cropLeft = cropRight = cropAmount;
                } else {
                    cropTop = parseInt(document.getElementById('cropTop').value) || 0;
                    cropRight = parseInt(document.getElementById('cropRight').value) || 0;
                    cropBottom = parseInt(document.getElementById('cropBottom').value) || 0;
                    cropLeft = parseInt(document.getElementById('cropLeft').value) || 0;
                }
                
                // Create FormData to send file and crop values to server
                const formData = new FormData();
                formData.append('gif', file);
                formData.append('cropTop', cropTop);
                formData.append('cropRight', cropRight);
                formData.append('cropBottom', cropBottom);
                formData.append('cropLeft', cropLeft);
                
                // Send to server API endpoint that uses gifsicle
                fetch('/api/crop-gif', {
                    method: 'POST',
                    body: formData
                })
                .then(response => {
                    if (!response.ok) {
                        return response.json().then(err => {
                            throw new Error(err.error || 'Server error');
                        });
                    }
                    return response.blob();
                })
                .then(blob => {
                    console.log(`‚úÖ Cropped GIF received from server (${(blob.size / 1024).toFixed(2)} KB)`);
                    resolve(blob);
                })
                .catch(error => {
                    console.error('Error cropping GIF:', error);
                    reject(error);
                });
            });
        }
        
        async function extractGifFrames(gifData) {
            return new Promise((resolve, reject) => {
                try {
                    // Use gifuct-js to properly parse GIF frames
                    if (typeof decompressFrames === 'undefined') {
                        reject(new Error('GIF parser library (gifuct-js) not loaded. Please refresh the page.'));
                        return;
                    }
                    
                    // Parse GIF - decompressFrames returns raw frame data
                    const rawFrames = decompressFrames(gifData, true); // true = build patches
                    
                    if (!rawFrames || rawFrames.length === 0) {
                        reject(new Error('No frames found in GIF'));
                        return;
                    }
                    
                    console.log(`Parsed ${rawFrames.length} raw frames from GIF`);
                    
                    // Get dimensions from first frame
                    const firstFrame = rawFrames[0];
                    const width = firstFrame.dims.width;
                    const height = firstFrame.dims.height;
                    
                    // Get global color table
                    const globalColorTable = firstFrame.colorTable || [];
                    const globalTransparentIndex = firstFrame.transparentIndex !== undefined ? firstFrame.transparentIndex : null;
                    
                    // Composite frames properly (handle disposal methods)
                    const canvas = document.createElement('canvas');
                    canvas.width = width;
                    canvas.height = height;
                    const ctx = canvas.getContext('2d', { alpha: true });
                    
                    const frames = [];
                    let previousImageData = null;
                    
                    rawFrames.forEach((frame, index) => {
                        // Get frame dimensions and position
                        const frameDims = frame.dims;
                        const frameLeft = frameDims.left;
                        const frameTop = frameDims.top;
                        const frameWidth = frameDims.width;
                        const frameHeight = frameDims.height;
                        
                        // Get color table (local or global)
                        const colorTable = frame.colorTable || globalColorTable;
                        const transparentIndex = frame.transparentIndex !== undefined ? frame.transparentIndex : globalTransparentIndex;
                        
                        // Handle disposal method from previous frame
                        if (index > 0 && previousImageData) {
                            const prevFrame = rawFrames[index - 1];
                            const disposal = prevFrame.disposal !== undefined ? prevFrame.disposal : 0;
                            
                            if (disposal === 2) {
                                // Dispose: restore to background (clear the frame area)
                                const prevDims = prevFrame.dims;
                                ctx.clearRect(prevDims.left, prevDims.top, prevDims.width, prevDims.height);
                            } else if (disposal === 3) {
                                // Dispose: restore to previous (keep previous frame)
                                // Do nothing - keep the previous frame
                            }
                            // disposal === 0 or 1: do not dispose (keep frame)
                        }
                        
                        // Decode frame patch to full frame
                        const patch = frame.patch;
                        const frameImageData = new ImageData(width, height);
                        
                        // Copy previous frame data if it exists
                        if (previousImageData) {
                            frameImageData.data.set(previousImageData.data);
                        }
                        
                        // Apply the patch
                        for (let y = 0; y < frameHeight; y++) {
                            for (let x = 0; x < frameWidth; x++) {
                                const patchIndex = y * frameWidth + x;
                                if (patchIndex < patch.length) {
                                    const colorIndex = patch[patchIndex];
                                    const color = colorTable[colorIndex];
                                    
                                    const fullX = frameLeft + x;
                                    const fullY = frameTop + y;
                                    
                                    if (fullX >= 0 && fullX < width && fullY >= 0 && fullY < height) {
                                        const pixelIndex = (fullY * width + fullX) * 4;
                                        
                                        if (color && colorIndex !== transparentIndex) {
                                            frameImageData.data[pixelIndex] = color[0];
                                            frameImageData.data[pixelIndex + 1] = color[1];
                                            frameImageData.data[pixelIndex + 2] = color[2];
                                            frameImageData.data[pixelIndex + 3] = 255;
                                        } else {
                                            // Transparent pixel
                                            frameImageData.data[pixelIndex] = 0;
                                            frameImageData.data[pixelIndex + 1] = 0;
                                            frameImageData.data[pixelIndex + 2] = 0;
                                            frameImageData.data[pixelIndex + 3] = 0;
                                        }
                                    }
                                }
                            }
                        }
                        
                        // Get delay in centiseconds
                        const delayCs = frame.delay !== null && frame.delay !== undefined ? Math.max(1, frame.delay) : 10;
                        
                        frames.push({
                            imageData: frameImageData,
                            delay: delayCs,
                            disposal: frame.disposal !== undefined ? frame.disposal : 0,
                            transparentIndex: transparentIndex,
                            colorTable: colorTable
                        });
                        
                        previousImageData = new ImageData(
                            new Uint8ClampedArray(frameImageData.data),
                            width,
                            height
                        );
                    });
                    
                    console.log(`Composited ${frames.length} frames with delays:`, frames.map(f => f.delay + 'cs'));
                    resolve(frames);
                } catch (err) {
                    console.error('Error parsing GIF with gifuct-js:', err);
                    // Fallback to simple extraction
                    extractFramesSimple(gifData).then(resolve).catch((fallbackErr) => {
                        reject(new Error(`Failed to parse GIF: ${err.message || err}`));
                    });
                }
            });
        }
        
        // Fallback simple extraction method (less reliable but works)
        async function extractFramesSimple(gifData) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                const blob = new Blob([gifData], { type: 'image/gif' });
                const url = URL.createObjectURL(blob);
                
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    const ctx = canvas.getContext('2d', { alpha: true });
                    
                    // Draw the GIF (browser will show current frame)
                    ctx.drawImage(img, 0, 0);
                    const frameData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    
                    // Return single frame with default delay
                    // Note: This won't extract all frames, but preserves transparency
                    URL.revokeObjectURL(url);
                    resolve([{
                        imageData: frameData,
                        delay: 10, // 100ms default
                        disposal: 0,
                        transparentIndex: null,
                        colorTable: null
                    }]);
                };
                
                img.onerror = () => {
                    URL.revokeObjectURL(url);
                    reject(new Error('Failed to load GIF'));
                };
                img.src = url;
            });
        }
        
        
        async function createCroppedGif(frames, width, height, cropLeft, cropTop) {
            return new Promise((resolve, reject) => {
                if (frames.length === 0) {
                    reject(new Error('No frames to process'));
                    return;
                }
                
                const useWorkers = window.location.protocol === 'http:' || window.location.protocol === 'https:';
                const workerCount = useWorkers ? 2 : 0;
                const workerScriptUrl = useWorkers ? window.location.origin + '/gif.worker.js' : null;
                
                const gifOptions = {
                    workers: workerCount,
                    quality: 10,
                    width: width,
                    height: height,
                    repeat: 0
                };
                
                if (workerScriptUrl) {
                    gifOptions.workerScript = workerScriptUrl;
                }
                
                const gif = new GIF(gifOptions);
                const canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                // Use 'willReadFrequently' and ensure transparency is preserved
                const ctx = canvas.getContext('2d', { 
                    willReadFrequently: true,
                    alpha: true // Ensure alpha channel is preserved
                });
                
                // Detect transparent color from the original GIF's color table
                let transparentColor = null;
                const firstFrameInfo = frames[0];
                
                // Use the transparent index from the GIF if available
                if (firstFrameInfo.transparentIndex !== null && firstFrameInfo.transparentIndex !== undefined) {
                    const colorTable = firstFrameInfo.colorTable;
                    if (colorTable && colorTable[firstFrameInfo.transparentIndex]) {
                        const transparentColorRGB = colorTable[firstFrameInfo.transparentIndex];
                        transparentColor = transparentColorRGB;
                        console.log(`Using GIF transparent color from color table: RGB(${transparentColor.join(',')})`);
                    }
                }
                
                // If no transparent color found, detect it from the cropped frames
                if (transparentColor === null) {
                    // We'll detect it after cropping the first frame
                }
                
                // Crop and add each frame
                frames.forEach((frameInfo, i) => {
                    const frameData = frameInfo.imageData;
                    const delay = frameInfo.delay || 10; // Use original delay (in centiseconds)
                    
                    // Create a temporary canvas for the original frame
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = frameData.width;
                    tempCanvas.height = frameData.height;
                    const tempCtx = tempCanvas.getContext('2d', { alpha: true });
                    
                    // Put the frame data (with transparency) onto temp canvas
                    tempCtx.putImageData(frameData, 0, 0);
                    
                    // Clear the main canvas completely (important for transparency)
                    ctx.clearRect(0, 0, width, height);
                    
                    // Draw cropped portion to main canvas
                    // This preserves transparency automatically because we're using alpha: true
                    ctx.drawImage(
                        tempCanvas,
                        cropLeft, cropTop, width, height,  // Source rectangle (cropped area)
                        0, 0, width, height                 // Destination rectangle
                    );
                    
                    // Detect transparent color from first cropped frame if not already set
                    if (i === 0 && transparentColor === null) {
                        const croppedImageData = ctx.getImageData(0, 0, width, height);
                        // Find the most common color among fully transparent pixels
                        const transparentPixels = new Map();
                        for (let j = 3; j < croppedImageData.data.length; j += 4) {
                            if (croppedImageData.data[j] === 0) { // Alpha = 0 (fully transparent)
                                const pixelIndex = j - 3;
                                const r = croppedImageData.data[pixelIndex];
                                const g = croppedImageData.data[pixelIndex + 1];
                                const b = croppedImageData.data[pixelIndex + 2];
                                const key = `${r},${g},${b}`;
                                transparentPixels.set(key, (transparentPixels.get(key) || 0) + 1);
                            }
                        }
                        
                        // Use the most common transparent color, or default to black
                        if (transparentPixels.size > 0) {
                            let maxCount = 0;
                            let mostCommon = [0, 0, 0]; // Default to black
                            transparentPixels.forEach((count, key) => {
                                if (count > maxCount) {
                                    maxCount = count;
                                    mostCommon = key.split(',').map(Number);
                                }
                            });
                            transparentColor = mostCommon;
                            console.log(`Detected transparent color from pixels: RGB(${transparentColor.join(',')})`);
                        } else {
                            // No transparent pixels found, use black as default
                            transparentColor = [0, 0, 0];
                            console.log(`No transparent pixels found, using black as transparent color`);
                        }
                    }
                    
                    // Add frame with original delay and transparency
                    const frameOptions = { delay: delay };
                    if (transparentColor) {
                        // GIF.js expects transparent color as RGB number: (R << 16) | (G << 8) | B
                        frameOptions.transparent = (transparentColor[0] << 16) | (transparentColor[1] << 8) | transparentColor[2];
                    }
                    gif.addFrame(ctx, frameOptions);
                    
                    console.log(`Added frame ${i + 1}/${frames.length} with delay ${delay}cs${transparentColor ? ', transparent: ' + transparentColor.join(',') : ''}`);
                });
                
                gif.on('finished', (blob) => {
                    console.log('‚úÖ Cropped GIF created, size:', blob.size, 'bytes');
                    resolve(blob);
                });
                
                gif.on('error', (err) => {
                    console.error('GIF creation error:', err);
                    reject(new Error(`GIF creation error: ${err.message || err}`));
                });
                
                gif.render();
            });
        }
        
        function downloadSingle(index) {
            if (processedGifs[index]) {
                downloadGif(processedGifs[index].blob, processedGifs[index].filename);
                showStatus(`Downloaded ${processedGifs[index].filename}`, 'success');
            }
        }
        
        function downloadGif(blob, filename) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        function downloadAll() {
            const gifCount = Object.keys(processedGifs).length;
            if (gifCount === 0) {
                showStatus('No processed GIFs to download. Process them first!', 'error');
                return;
            }
            
            let downloaded = 0;
            Object.keys(processedGifs).forEach((index, i) => {
                setTimeout(() => {
                    downloadGif(processedGifs[index].blob, processedGifs[index].filename);
                    downloaded++;
                    if (downloaded === gifCount) {
                        showStatus(`‚úÖ Downloaded ${gifCount} GIF file(s)`, 'success');
                    }
                }, i * 300);
            });
        }
    </script>
</body>
</html>
