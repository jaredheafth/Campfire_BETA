<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sprite Sheet to GIF Converter</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: #1a1a1a;
            color: #fff;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        h1 {
            margin-bottom: 30px;
            color: #ff6b35;
        }
        
        .upload-area {
            border: 2px dashed #444;
            border-radius: 8px;
            padding: 40px;
            text-align: center;
            background: #222;
            margin-bottom: 30px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .upload-area:hover {
            border-color: #ff6b35;
            background: #2a2a2a;
        }
        
        .upload-area.dragover {
            border-color: #ff6b35;
            background: #333;
        }
        
        input[type="file"] {
            display: none;
        }
        
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        label {
            font-size: 14px;
            color: #aaa;
        }
        
        input[type="number"] {
            padding: 10px;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 4px;
            color: #fff;
            font-size: 16px;
        }
        
        button {
            padding: 12px 24px;
            background: #ff6b35;
            border: none;
            border-radius: 4px;
            color: #fff;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        button:hover {
            background: #ff8c5a;
        }
        
        button:disabled {
            background: #555;
            cursor: not-allowed;
        }
        
        .preview-area {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }
        
        .preview-card {
            background: #222;
            border-radius: 8px;
            padding: 20px;
        }
        
        .preview-card h3 {
            margin-bottom: 15px;
            color: #ff6b35;
        }
        
        .preview-image {
            width: 100%;
            max-width: 300px;
            height: auto;
            border-radius: 4px;
            margin-bottom: 10px;
        }
        
        .status {
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 20px;
        }
        
        .status.info {
            background: #2a4a7a;
            color: #aaccff;
        }
        
        .status.success {
            background: #2a7a4a;
            color: #aaffcc;
        }
        
        .status.error {
            background: #7a2a2a;
            color: #ffaacc;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üé® Sprite Sheet to GIF Converter</h1>
        
        <div id="status" class="status info" style="display: none;"></div>
        
        <div class="upload-area" id="uploadArea">
            <p style="font-size: 18px; margin-bottom: 10px;">üìÅ Drop sprite sheet PNG here or click to browse</p>
            <p style="color: #888; font-size: 14px;">Supports horizontal sprite sheets with multiple frames</p>
            <input type="file" id="fileInput" accept="image/png,image/jpeg" multiple>
        </div>
        
        <div class="controls">
            <div class="control-group">
                <label for="frameWidth">Frame Width (px)</label>
                <input type="number" id="frameWidth" value="100" min="10" max="500">
            </div>
            <div class="control-group">
                <label for="frameHeight">Frame Height (px)</label>
                <input type="number" id="frameHeight" value="100" min="10" max="500">
            </div>
            <div class="control-group">
                <label for="frameDelay">Delay (ms)</label>
                <input type="number" id="frameDelay" value="150" min="50" max="500" step="50">
            </div>
            <div class="control-group">
                <button id="convertBtn" onclick="convertAll()">Convert All to GIF</button>
            </div>
            <div class="control-group">
                <button onclick="downloadAllGifs()" style="background: #4a9;">Download All GIFs</button>
            </div>
        </div>
        
        <div class="preview-area" id="previewArea"></div>
    </div>
    
    <script src="https://cdn.jsdelivr.net/npm/omggif@1.0.10/omggif.js"></script>
    <script>
        // Use omggif library which works better without workers
        // Fallback to GIF.js if omggif doesn't load
        (function() {
            function loadGifJs(src, isRetry = false) {
                const script = document.createElement('script');
                script.src = src;
                script.async = true;
                script.onload = () => {
                    if (typeof GIF !== 'undefined') {
                        console.log('‚úÖ GIF.js loaded successfully from', src);
                        window.GIFLoaded = true;
                    } else {
                        console.warn('Script loaded but GIF not defined');
                    }
                };
                script.onerror = () => {
                    console.error('‚ùå Failed to load GIF.js from', src);
                };
                document.head.appendChild(script);
            }
            
            // Load GIF.js as fallback
            loadGifJs('https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.js');
        })();
    </script>
    <script>
        const fileInput = document.getElementById('fileInput');
        const uploadArea = document.getElementById('uploadArea');
        const previewArea = document.getElementById('previewArea');
        const statusDiv = document.getElementById('status');
        const convertBtn = document.getElementById('convertBtn');
        
        let files = [];
        
        uploadArea.addEventListener('click', () => fileInput.click());
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });
        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });
        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            handleFiles(e.dataTransfer.files);
        });
        fileInput.addEventListener('change', (e) => handleFiles(e.target.files));
        
        function showStatus(message, type = 'info') {
            statusDiv.textContent = message;
            statusDiv.className = `status ${type}`;
            statusDiv.style.display = 'block';
            setTimeout(() => {
                statusDiv.style.display = 'none';
            }, 5000);
        }
        
        function handleFiles(fileList) {
            files = Array.from(fileList).filter(f => f.type.startsWith('image/'));
            if (files.length === 0) {
                showStatus('Please select image files', 'error');
                return;
            }
            
            showStatus(`Loaded ${files.length} file(s)`, 'success');
            previewArea.innerHTML = '';
            
            files.forEach((file, index) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    createPreviewCard(file.name, e.target.result, index);
                };
                reader.readAsDataURL(file);
            });
        }
        
        const convertedGifs = {}; // Store converted GIFs by index
        
        function createPreviewCard(filename, imageSrc, index) {
            const card = document.createElement('div');
            card.className = 'preview-card';
            card.id = `card-${index}`;
            card.innerHTML = `
                <h3>${filename}</h3>
                <img src="${imageSrc}" alt="${filename}" class="preview-image" id="preview-${index}">
                <div id="gif-preview-${index}" style="display: none; margin: 10px 0;">
                    <p style="color: #4a9; margin-bottom: 8px;">‚úÖ GIF Created!</p>
                    <img id="gif-image-${index}" class="preview-image" style="max-width: 200px;">
                </div>
                <div style="display: flex; gap: 10px; margin-top: 10px;">
                    <button onclick="convertSingle(${index})" id="convert-btn-${index}">Convert to GIF</button>
                    <button onclick="downloadGifFromStorage(${index})" id="download-btn-${index}" style="display: none; background: #4a9;">Download GIF</button>
                </div>
            `;
            previewArea.appendChild(card);
        }
        
        async function waitForGifLibrary() {
            // Wait for GIF library to load (max 10 seconds)
            const maxWait = 10000;
            const startTime = Date.now();
            
            while (typeof GIF === 'undefined' && (Date.now() - startTime) < maxWait) {
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            
            if (typeof GIF === 'undefined') {
                throw new Error('GIF.js library failed to load. Please refresh the page.');
            }
        }
        
        async function convertSingle(index) {
            const file = files[index];
            const frameWidth = parseInt(document.getElementById('frameWidth').value);
            const frameHeight = parseInt(document.getElementById('frameHeight').value);
            const delay = parseInt(document.getElementById('frameDelay').value);
            
            const convertBtn = document.getElementById(`convert-btn-${index}`);
            convertBtn.disabled = true;
            convertBtn.textContent = 'Converting...';
            
            showStatus(`Converting ${file.name}...`, 'info');
            
            try {
                // Wait for GIF library
                await waitForGifLibrary();
                // Step 1: Cut sprite sheet into frames
                const frames = await cutSpriteSheetIntoFrames(file, frameWidth, frameHeight);
                showStatus(`Cut ${frames.length} frames from ${file.name}`, 'info');
                
                // Step 2: Create GIF from frames
                const gif = await createGifFromFrames(frames, frameWidth, frameHeight, delay);
                
                // Store the GIF blob
                convertedGifs[index] = {
                    blob: gif,
                    filename: file.name.replace(/\.(png|jpg|jpeg)$/i, '.gif')
                };
                
                // Show preview
                const gifPreview = document.getElementById(`gif-preview-${index}`);
                const gifImage = document.getElementById(`gif-image-${index}`);
                const downloadBtn = document.getElementById(`download-btn-${index}`);
                
                const gifUrl = URL.createObjectURL(gif);
                gifImage.src = gifUrl;
                gifPreview.style.display = 'block';
                downloadBtn.style.display = 'inline-block';
                convertBtn.textContent = 'Converted ‚úì';
                convertBtn.disabled = true;
                
                showStatus(`‚úÖ Converted ${file.name} (${frames.length} frames) - Click Download to save`, 'success');
            } catch (error) {
                showStatus(`Error: ${error.message}`, 'error');
                console.error(error);
                convertBtn.disabled = false;
                convertBtn.textContent = 'Convert to GIF';
            }
        }
        
        function downloadGifFromStorage(index) {
            if (convertedGifs[index]) {
                downloadGif(convertedGifs[index].blob, convertedGifs[index].filename);
                showStatus(`Downloaded ${convertedGifs[index].filename}`, 'success');
            }
        }
        
        async function convertAll() {
            if (files.length === 0) {
                showStatus('Please select files first', 'error');
                return;
            }
            
            convertBtn.disabled = true;
            convertBtn.textContent = 'Converting...';
            
            // Wait for GIF library
            try {
                await waitForGifLibrary();
            } catch (error) {
                showStatus(`Error: ${error.message}`, 'error');
                convertBtn.disabled = false;
                convertBtn.textContent = 'Convert All to GIF';
                return;
            }
            
            const frameWidth = parseInt(document.getElementById('frameWidth').value);
            const frameHeight = parseInt(document.getElementById('frameHeight').value);
            const delay = parseInt(document.getElementById('frameDelay').value);
            
            for (let i = 0; i < files.length; i++) {
                showStatus(`Converting ${i + 1}/${files.length}: ${files[i].name}...`, 'info');
                try {
                    // Step 1: Cut sprite sheet into frames
                    const frames = await cutSpriteSheetIntoFrames(files[i], frameWidth, frameHeight);
                    
                    // Step 2: Create GIF from frames
                    const gif = await createGifFromFrames(frames, frameWidth, frameHeight, delay);
                    
                    // Store the GIF
                    convertedGifs[i] = {
                        blob: gif,
                        filename: files[i].name.replace(/\.(png|jpg|jpeg)$/i, '.gif')
                    };
                    
                    // Show preview and download button
                    const gifPreview = document.getElementById(`gif-preview-${i}`);
                    const gifImage = document.getElementById(`gif-image-${i}`);
                    const downloadBtn = document.getElementById(`download-btn-${i}`);
                    const btn = document.getElementById(`convert-btn-${i}`);
                    
                    if (gifPreview && gifImage && downloadBtn) {
                        const gifUrl = URL.createObjectURL(gif);
                        gifImage.src = gifUrl;
                        gifPreview.style.display = 'block';
                        downloadBtn.style.display = 'inline-block';
                        if (btn) {
                            btn.textContent = 'Converted ‚úì';
                            btn.disabled = true;
                        }
                    }
                } catch (error) {
                    showStatus(`Error converting ${files[i].name}: ${error.message}`, 'error');
                }
            }
            
            convertBtn.disabled = false;
            convertBtn.textContent = 'Convert All to GIF';
            showStatus(`‚úÖ Converted ${files.length} file(s) - Click Download buttons to save GIFs`, 'success');
        }
        
        // Step 1: Cut sprite sheet into individual frames
        async function cutSpriteSheetIntoFrames(file, frameWidth, frameHeight) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    const frames = [];
                    const canvas = document.createElement('canvas');
                    canvas.width = frameWidth;
                    canvas.height = frameHeight;
                    const ctx = canvas.getContext('2d');
                    
                    // Calculate how many frames fit horizontally and vertically
                    const framesPerRow = Math.floor(img.width / frameWidth);
                    const framesPerCol = Math.floor(img.height / frameHeight);
                    const totalFrames = framesPerRow * framesPerCol;
                    
                    console.log(`Sprite sheet: ${img.width}x${img.height}, Frame: ${frameWidth}x${frameHeight}`);
                    console.log(`Frames per row: ${framesPerRow}, Frames per col: ${framesPerCol}, Total: ${totalFrames}`);
                    
                    // Extract each frame
                    for (let row = 0; row < framesPerCol; row++) {
                        for (let col = 0; col < framesPerRow; col++) {
                            const x = col * frameWidth;
                            const y = row * frameHeight;
                            
                            // Clear canvas
                            ctx.clearRect(0, 0, frameWidth, frameHeight);
                            
                            // Draw the frame from sprite sheet
                            ctx.drawImage(
                                img,
                                x, y, frameWidth, frameHeight,  // Source rectangle
                                0, 0, frameWidth, frameHeight   // Destination rectangle
                            );
                            
                            // Convert canvas to image data URL
                            const frameDataUrl = canvas.toDataURL('image/png');
                            frames.push(frameDataUrl);
                        }
                    }
                    
                    resolve(frames);
                };
                
                img.onerror = () => reject(new Error('Failed to load image'));
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    img.src = e.target.result;
                };
                reader.onerror = () => reject(new Error('Failed to read file'));
                reader.readAsDataURL(file);
            });
        }
        
        // Step 2: Create GIF from individual frames
        async function createGifFromFrames(frames, frameWidth, frameHeight, delay) {
            return new Promise((resolve, reject) => {
                if (frames.length === 0) {
                    reject(new Error('No frames to create GIF from'));
                    return;
                }
                
                // Check if GIF library is loaded
                if (typeof GIF === 'undefined') {
                    reject(new Error('GIF.js library not loaded. Please refresh the page.'));
                    return;
                }
                
                console.log(`Creating GIF from ${frames.length} frames, size: ${frameWidth}x${frameHeight}, delay: ${delay}ms`);
                
                try {
                    // Disable workers for local file:// access (CORS restriction)
                    // Set workers to 0 to use single-threaded mode
                    const gif = new GIF({
                        workers: 0, // 0 = no workers, works with file:// protocol
                        quality: 10,
                        width: frameWidth,
                        height: frameHeight,
                        repeat: 0 // 0 = infinite loop
                    });
                
                    const canvas = document.createElement('canvas');
                    canvas.width = frameWidth;
                    canvas.height = frameHeight;
                    const ctx = canvas.getContext('2d');
                    
                    let framesLoaded = 0;
                    const frameImages = new Array(frames.length);
                    let hasError = false;
                    let gifFinished = false;
                    
                    // Set timeout to prevent hanging
                    const timeout = setTimeout(() => {
                        if (!hasError && !gifFinished) {
                            hasError = true;
                            reject(new Error(`Timeout: Process took too long. Loaded ${framesLoaded}/${frames.length} frames.`));
                        }
                    }, 60000); // 60 second timeout
                
                // Load all frame images
                frames.forEach((frameDataUrl, index) => {
                    const img = new Image();
                    img.crossOrigin = 'anonymous'; // Handle CORS if needed
                    
                    img.onload = () => {
                        if (hasError) return;
                        
                        try {
                            frameImages[index] = img;
                            framesLoaded++;
                            console.log(`Loaded frame ${framesLoaded}/${frames.length}`);
                            
                            // When all frames are loaded, add them to GIF
                            if (framesLoaded === frames.length) {
                                clearTimeout(timeout);
                                console.log('All frames loaded, creating GIF...');
                                
                                try {
                                    // Add frames in order
                                    frameImages.forEach((frameImg, i) => {
                                        ctx.clearRect(0, 0, frameWidth, frameHeight);
                                        ctx.drawImage(frameImg, 0, 0, frameWidth, frameHeight);
                                        gif.addFrame(ctx, { delay: delay });
                                        console.log(`Added frame ${i + 1} to GIF`);
                                    });
                                    
                                    // Set up event handlers
                                    let progressInterval;
                                    
                                    gif.on('finished', (blob) => {
                                        if (gifFinished) return;
                                        gifFinished = true;
                                        clearTimeout(timeout);
                                        if (progressInterval) clearInterval(progressInterval);
                                        console.log('‚úÖ GIF finished rendering, size:', blob.size, 'bytes');
                                        
                                        // Update status
                                        const statusEl = document.getElementById('status');
                                        if (statusEl) {
                                            statusEl.textContent = `‚úÖ GIF created successfully!`;
                                            statusEl.className = 'status success';
                                            statusEl.style.display = 'block';
                                        }
                                        
                                        resolve(blob);
                                    });
                                    
                                    gif.on('progress', (p) => {
                                        const percent = Math.round(p * 100);
                                        console.log('GIF progress:', percent + '%');
                                        
                                        // Update status
                                        const statusEl = document.getElementById('status');
                                        if (statusEl) {
                                            statusEl.textContent = `Rendering GIF: ${percent}%`;
                                            statusEl.className = 'status info';
                                            statusEl.style.display = 'block';
                                        }
                                    });
                                    
                                    // For single-threaded mode (workers: 0), progress might not fire regularly
                                    // Add a fallback progress indicator with elapsed time
                                    let renderStartTime = Date.now();
                                    progressInterval = setInterval(() => {
                                        if (gifFinished) {
                                            clearInterval(progressInterval);
                                            return;
                                        }
                                        
                                        const elapsed = ((Date.now() - renderStartTime) / 1000).toFixed(1);
                                        const statusEl = document.getElementById('status');
                                        if (statusEl) {
                                            statusEl.textContent = `Rendering GIF... (${elapsed}s elapsed - single-threaded mode is slower)`;
                                            statusEl.className = 'status info';
                                            statusEl.style.display = 'block';
                                        }
                                        console.log(`Still rendering... (${elapsed}s elapsed)`);
                                    }, 1000); // Update every second
                                    
                                    // Start rendering
                                    console.log('Starting GIF render (single-threaded mode - may take 10-30 seconds for 6 frames)...');
                                    renderStartTime = Date.now();
                                    
                                    try {
                                        // Render the GIF
                                        // In single-threaded mode, this processes frames one by one
                                        // It might take 10-30 seconds for 6 frames, but it will complete
                                        gif.render();
                                        console.log('gif.render() called, waiting for finished event...');
                                        console.log('Note: Single-threaded rendering can take 10-30 seconds. Please wait...');
                                    } catch (renderError) {
                                        clearTimeout(timeout);
                                        if (progressInterval) clearInterval(progressInterval);
                                        hasError = true;
                                        console.error('GIF render error:', renderError);
                                        reject(new Error(`GIF render error: ${renderError.message}`));
                                    }
                                } catch (err) {
                                    clearTimeout(timeout);
                                    hasError = true;
                                    reject(new Error(`Error creating GIF: ${err.message}`));
                                }
                            }
                        } catch (err) {
                            if (!hasError) {
                                clearTimeout(timeout);
                                hasError = true;
                                reject(new Error(`Error processing frame ${index + 1}: ${err.message}`));
                            }
                        }
                    };
                    
                    img.onerror = (err) => {
                        if (!hasError) {
                            clearTimeout(timeout);
                            hasError = true;
                            reject(new Error(`Failed to load frame ${index + 1}: ${err.message || 'Unknown error'}`));
                        }
                    };
                    
                    // Load the image
                    try {
                        img.src = frameDataUrl;
                    } catch (err) {
                        if (!hasError) {
                            clearTimeout(timeout);
                            hasError = true;
                            reject(new Error(`Error setting frame ${index + 1} source: ${err.message}`));
                        }
                    }
                });
                } catch (initError) {
                    reject(new Error(`Failed to initialize GIF: ${initError.message}`));
                }
            });
        }
        
        function downloadGif(blob, filename) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        function downloadAllGifs() {
            const gifCount = Object.keys(convertedGifs).length;
            if (gifCount === 0) {
                showStatus('No GIFs converted yet. Convert them first!', 'error');
                return;
            }
            
            let downloaded = 0;
            Object.keys(convertedGifs).forEach((index, i) => {
                setTimeout(() => {
                    downloadGif(convertedGifs[index].blob, convertedGifs[index].filename);
                    downloaded++;
                    if (downloaded === gifCount) {
                        showStatus(`‚úÖ Downloaded ${gifCount} GIF file(s)`, 'success');
                    }
                }, i * 300); // Stagger downloads by 300ms
            });
        }
    </script>
</body>
</html>
