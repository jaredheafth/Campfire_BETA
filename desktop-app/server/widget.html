<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Campfire Widget - Visual Display</title>
    <style>
        /* Custom font for usernames and chat bubbles */
        @font-face {
            font-family: 'UsernameFont';
            src: url('fonts/w95fa.woff2') format('woff2'),
                 url('fonts/w95fa.woff') format('woff'),
                 url('fonts/W95FA.otf') format('opentype'),
                 url('fonts/username-font.woff2') format('woff2'),
                 url('fonts/username-font.woff') format('woff'),
                 url('fonts/username-font.ttf') format('truetype'),
                 url('fonts/username-font.otf') format('opentype');
            font-weight: normal;
            font-style: normal;
            font-display: swap; /* Show fallback font immediately, swap when custom font loads */
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            width: 100vw;
            height: 100vh;
            /*
             * SPRITE VISIBILITY FIX: Use visible overflow
             * overflow: clip/hidden was clipping sprites at the top of the ring
             * Using visible allows sprites to extend beyond viewport bounds
             * Scrollbars are prevented by the fixed window size in Electron
             */
            overflow: visible;
            background: transparent !important; /* Ensure transparent for OBS */
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            /* Prevent text selection which can interfere with window dragging */
            -webkit-user-select: none;
            user-select: none;
        }
        
        /* In frameless mode, make the entire body draggable except for interactive elements */
        body.frameless {
            -webkit-app-region: drag;
        }
        
        /* Ensure interactive elements are not draggable */
        body.frameless .menu-button,
        body.frameless .menu-button-square,
        body.frameless .desktop-menu-bar,
        body.frameless input,
        body.frameless select,
        body.frameless button,
        body.frameless textarea,
        body.frameless a,
        body.frameless .user-shape,
        body.frameless .chat-message,
        body.frameless .username,
        body.frameless .campfire-graphic,
        body.frameless .campfire-area {
            -webkit-app-region: no-drag;
        }
        
        html {
            background: transparent !important; /* Ensure HTML is also transparent */
            /* Use visible to allow sprites to extend beyond viewport bounds */
            overflow: visible;
        }

        .widget-container {
            width: 100%;
            height: 100%;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            /* CRITICAL: Allow sprites to extend beyond container bounds */
            overflow: visible;
            /* No padding needed - z-index fix handles menu bar overlap */
            padding: 0;
            box-sizing: border-box;
        }

        .campfire-area {
            position: relative;
            /*
             * OUTER RING FIX: Scale content to fit within window bounds
             * The outer ring uses 1.67x radius, so we need to account for that.
             * Instead of trying to expand the container (which causes clipping),
             * we use a smaller base size that leaves room for the outer ring.
             *
             * Formula: availableSpace / (1 + outerRingOverhang)
             * With 1.67x multiplier, overhang is 0.67 on each side = 1.34 total
             * Reduced to 60% to ensure sprites at top of ring don't get clipped
             * Also accounts for menu bar height (60px) at top of viewport
             */
            --outer-ring-scale: 0.60; /* Leave 40% margin for outer ring sprites + menu bar */
            width: calc(min(100vw, 100vh - 60px) * var(--outer-ring-scale));
            height: calc(min(100vw, 100vh - 60px) * var(--outer-ring-scale));
            min-width: 360px; /* Scaled minimum (600 * 0.60) */
            min-height: 360px; /* Scaled minimum (600 * 0.60) */
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: visible; /* Ensure outer ring sprites are visible */
        }

        .campfire-graphic {
            width: 100%; /* Responsive to container size */
            height: 100%; /* Responsive to container size */
            max-width: 800px; /* Maximum size for glow effect */
            max-height: 800px; /* Maximum size for glow effect */
            object-fit: contain;
            z-index: 10;
            position: relative;
            overflow: visible; /* Allow glow to extend beyond container */
            background: transparent; /* No background */
            border: none; /* No border */
            box-shadow: none; /* No box shadow on container */
            /* Center the container content */
            display: flex;
            align-items: center;
            justify-content: center;
            /* Streamer-adjustable campfire vertical offset */
            transform: translateY(var(--campfire-y-offset, 0px));
            will-change: transform;
        }

        /* 3D Layering - Front users (bottom of circle) */
        .user-shape.front-layer {
            z-index: 15;
        }

        /* 3D Layering - Back users (top of circle) */
        .user-shape.back-layer {
            z-index: 5;
        }

        .campfire-graphic img,
        .campfire-graphic video {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        .circle-container {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            /* Remove transform from container - we'll apply perspective to individual elements */
            /* CRITICAL: Allow sprites to extend beyond container bounds (for outer ring) */
            overflow: visible;
        }

        .user-shape {
            position: absolute;
            width: 40px; /* Default, will be overridden by spriteSize setting */
            height: 40px; /* Default, will be overridden by spriteSize setting */
            transform-origin: center;
            transition: left 0.6s ease, top 0.6s ease, z-index 0s; /* Only transition position, not transforms - 0.6s for smoother movement */
            z-index: 5;
            outline: none; /* Remove any outline */
        }
        
        /* User State Indicator Ring - ONLY visible for circles mode */
        .user-shape .state-ring {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: calc(100% + 8px);
            height: calc(100% + 8px);
            border-radius: 50%;
            border: 2px solid transparent;
            pointer-events: none;
            transition: border-color 0.3s ease, opacity 0.3s ease;
            z-index: -1;
            display: none; /* Hidden by default - only shown for circles mode */
        }
        
        /* Only show state rings for circles mode */
        .sprite-mode-circles .user-shape .state-ring {
            display: block;
        }
        
        /* State: ACTIVE - User recently chatted (green glow) */
        .user-shape.state-active .state-ring {
            border-color: #00ff00;
            box-shadow: 0 0 8px rgba(0, 255, 0, 0.5);
        }
        
        /* State: JOINED - User just joined (yellow pulse) */
        .user-shape.state-joined .state-ring {
            border-color: #ffff00;
            animation: joinedPulse 1.5s ease-in-out 3;
        }
        
        @keyframes joinedPulse {
            0%, 100% {
                border-color: #ffff00;
                box-shadow: 0 0 4px rgba(255, 255, 0, 0.3);
            }
            50% {
                border-color: #ffcc00;
                box-shadow: 0 0 12px rgba(255, 255, 0, 0.7);
            }
        }
        
        /* State: SLEEPY - User hasn't chatted in a while (inner ring: just icon + STILL, outer ring: blue overlay) */
        /* Inner ring SLEEPY: no color change, just the üí§ icon */
        .user-shape.state-sleepy .state-ring {
            border-color: #5b9bd5;
            box-shadow: 0 0 8px rgba(91, 155, 213, 0.4);
        }
        
        /* SLEEPY in inner ring: NO color overlay, sprite stays normal */
        .user-shape.state-sleepy:not(.outer-ring) .shape {
            /* No filter - sprite stays fully opaque and normal colored */
        }
        
        /* SLEEPY in outer ring: blue overlay */
        .user-shape.state-sleepy.outer-ring .shape {
            filter: sepia(100%) saturate(200%) hue-rotate(180deg) brightness(0.9);
        }
        
        .user-shape.state-sleepy .username {
            opacity: 0.8;
            color: #5b9bd5 !important;
        }
        
        /* Sleepy indicator - floating üí§ animation */
        .user-shape.state-sleepy .sleepy-indicator,
        .user-shape.state-afk.was-sleepy .sleepy-indicator {
            position: absolute;
            top: var(--status-icon-top, -20px);
            right: var(--status-icon-right, -5px);
            font-size: 14px;
            animation: sleepyFloat 2s ease-in-out infinite;
            pointer-events: none;
            z-index: 10;
        }
        
        @keyframes sleepyFloat {
            0%, 100% {
                transform: translateY(0) scale(1);
                opacity: 0.7;
            }
            50% {
                transform: translateY(-8px) scale(1.1);
                opacity: 1;
            }
        }
        
        /* State: AFK - User hasn't chatted in a long time (dark, dimmed, outer ring) */
        .user-shape.state-afk .state-ring {
            border-color: #444444;
            opacity: 0.6;
        }
        
        .user-shape.state-afk .shape {
            opacity: 0.6;
            filter: grayscale(50%) brightness(0.7);
        }
        
        .user-shape.state-afk .username {
            opacity: 0.5;
        }
        
        /* AFK indicator - small text badge (no background, sans-serif) */
        .user-shape.state-afk .afk-indicator {
            position: absolute;
            top: var(--status-icon-top, -20px);
            right: var(--status-icon-right, -5px);
            font-size: 9px;
            font-weight: bold;
            font-family: Tahoma, Arial, sans-serif;
            color: #888;
            animation: afkPulse 3s ease-in-out infinite;
            pointer-events: none;
            z-index: 10;
            white-space: nowrap;
            text-shadow: 0 0 2px rgba(0, 0, 0, 0.8);
        }
        
        @keyframes afkPulse {
            0%, 100% {
                opacity: 0.5;
            }
            50% {
                opacity: 0.9;
            }
        }
        
        /* Combined SLEEPY + AFK state - blue overlay + dimmed + outer ring */
        .user-shape.state-afk.was-sleepy .state-ring {
            border-color: #3a6d99;
            box-shadow: 0 0 6px rgba(91, 155, 213, 0.3);
        }
        
        .user-shape.state-afk.was-sleepy .shape {
            opacity: 0.6;
            filter: sepia(100%) saturate(150%) hue-rotate(180deg) brightness(0.6);
        }
        
        .user-shape.state-afk.was-sleepy .username {
            opacity: 0.5;
            color: #5b9bd5 !important;
        }
        
        /* State: LURK - User is lurking (purple overlay, manual exit only) */
        .user-shape.state-lurk .state-ring {
            border-color: #9b59b6;
            box-shadow: 0 0 10px rgba(155, 89, 182, 0.5);
        }
        
        /* Purple overlay for LURK - uses filter to respect sprite shape */
        .user-shape.state-lurk .shape {
            opacity: 0.8;
            filter: sepia(100%) saturate(300%) hue-rotate(230deg);
        }
        
        .user-shape.state-lurk .username {
            opacity: 0.6;
            color: #9b59b6 !important;
        }
        
        /* Lurk indicator - SVG eye icon */
        .user-shape.state-lurk .lurk-indicator {
            position: absolute;
            top: var(--status-icon-top, -20px);
            right: var(--status-icon-right, -5px);
            width: 16px;
            height: 16px;
            animation: lurkPulse 3s ease-in-out infinite;
            pointer-events: none;
            z-index: 10;
        }
        
        .user-shape.state-lurk .lurk-indicator svg {
            width: 100%;
            height: 100%;
            fill: #9b59b6;
        }
        
        @keyframes lurkPulse {
            0%, 100% {
                opacity: 0.5;
            }
            50% {
                opacity: 1;
            }
        }
        
        /* Outer ring positioning for AFK/LURK users */
        .user-shape.outer-ring {
            /* Will be positioned via JavaScript to outer circle */
        }
        
        /* Disable transitions during exit animation for smooth animation */
        .user-shape.leaving {
            transition: none !important;
        }
        
        .user-shape .shape {
            transform-origin: center;
        }
        
        .user-shape .shape.flipped {
            transform: scaleX(-1);
        }

        .user-shape .shape {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: 2px solid transparent; /* Start transparent - only show if fallback circle is needed */
            /* No box-shadow - removed to eliminate bubble effect around sprites */
            box-shadow: none;
            outline: none !important; /* Remove outline that might create unwanted circles */
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            color: white;
            font-weight: bold;
            overflow: visible; /* Allow sprites to extend beyond if needed */
        }
        
        /* Ensure sprites (any with background-image) have no shadows, borders, or circular clipping */
        .user-shape .shape[style*="background-image"] {
            box-shadow: none !important;
            /* NOTE: Removed filter: drop-shadow(none) !important; because it was overriding
               the AFK/LURK state filters (grayscale, sepia, etc.). State filters are now
               applied via more specific selectors below. */
            border: none !important;
            border-radius: 0 !important;
            outline: none !important; /* Remove outline that might create unwanted circles */
            overflow: visible !important; /* Prevent clipping of sprite edges */
            background-size: contain !important; /* Ensure full sprite is visible */
        }
        
        /* State filters for sprites - use higher specificity to override base styles */
        /* Support both background-image (legacy) and img elements (current) */
        .user-shape.state-afk .shape[style*="background-image"],
        .user-shape.state-afk .shape img {
            filter: grayscale(50%) brightness(0.7) !important;
        }
        
        .user-shape.state-afk.was-sleepy .shape[style*="background-image"],
        .user-shape.state-afk.was-sleepy .shape img {
            filter: sepia(100%) saturate(150%) hue-rotate(180deg) brightness(0.6) !important;
        }
        
        .user-shape.state-lurk .shape[style*="background-image"],
        .user-shape.state-lurk .shape img {
            filter: sepia(100%) saturate(300%) hue-rotate(230deg) !important;
        }
        
        .user-shape.state-sleepy.outer-ring .shape[style*="background-image"],
        .user-shape.state-sleepy.outer-ring .shape img {
            filter: sepia(100%) saturate(200%) hue-rotate(180deg) brightness(0.9) !important;
        }

        .user-shape .username {
            position: absolute;
            top: var(--name-bubble-offset, -25px);
            left: 50%;
            transform: translateX(-50%);
            white-space: nowrap;
            /* Removed background box - using text stroke instead */
            padding: 2px 4px;
            font-size: 14px; /* Increased from 12px for better readability */
            font-weight: 600;
            font-family: 'UsernameFont', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            pointer-events: none;
            z-index: 100; /* Always above sprites - use high z-index so usernames layer correctly relative to each other */
            /* Outside stroke effect using text-shadow (no -webkit-text-stroke to avoid covering font) */
            /* Multiple shadows positioned around text create an outside-only outline */
            text-shadow: 
                -1px -1px 0 #000,
                1px -1px 0 #000,
                -1px 1px 0 #000,
                1px 1px 0 #000,
                0 -1px 0 #000,
                0 1px 0 #000,
                -1px 0 0 #000,
                1px 0 0 #000,
                0 0 2px #000; /* Additional blur for smoother outline */
            transition: opacity 0.3s ease, color 0.3s ease;
        }

        /* Hide nameplates without breaking chat bubble alignment logic */
        body.hide-nameplates .user-shape .username {
            opacity: 0 !important;
        }

        .user-shape .chat-message {
            position: absolute;
            top: var(--name-bubble-offset, -25px);
            left: 50%;
            transform: translateX(-50%);
            background: #0d0d0d;
            color: #fff;
            padding: 4px 8px;
            font-family: 'UsernameFont', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            border: 2px solid #fff;
            border-radius: 0;
            font-size: var(--chat-bubble-font-size, 11px);
            font-weight: 500;
            pointer-events: none;
            z-index: 25;
            min-width: 0;
            max-width: 150px;
            width: max-content;
            white-space: normal;
            word-break: normal;
            word-wrap: break-word;
            text-align: center;
            opacity: 0;
            transition: opacity 0.25s ease;
            box-shadow: none;
            /* Pixel/notched corners (Gameboy/Pok√©mon-ish) without changing colors */
            clip-path: polygon(
                0 4px, 2px 4px, 2px 2px, 4px 2px, 4px 0,
                calc(100% - 4px) 0,
                calc(100% - 4px) 2px, calc(100% - 2px) 2px, calc(100% - 2px) 4px, 100% 4px,
                100% calc(100% - 4px),
                calc(100% - 2px) calc(100% - 4px), calc(100% - 2px) calc(100% - 2px), calc(100% - 4px) calc(100% - 2px), calc(100% - 4px) 100%,
                4px 100%,
                4px calc(100% - 2px), 2px calc(100% - 2px), 2px calc(100% - 4px), 0 calc(100% - 4px)
            );
        }

        /* Clamp bubble text to 3 lines and show ellipsis (Chromium/Electron) */
        .user-shape .chat-message .chat-text {
            display: -webkit-box;
            -webkit-box-orient: vertical;
            -webkit-line-clamp: 3;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .user-shape .chat-message .chat-emote {
            height: 1.5em; /* Consistent emote size relative to text */
            max-height: 24px; /* Maximum height to prevent oversized emotes */
            width: auto;
            vertical-align: middle;
            display: inline-block;
            object-fit: contain;
        }
        
        /* Third-party emotes (BTTV/FFZ/7TV) may have different aspect ratios */
        .user-shape .chat-message .chat-emote-third {
            height: 1.5em;
            max-height: 24px;
        }

        .user-shape .chat-message.show {
            opacity: 1;
        }

        .user-shape .chat-message.fade-out {
            opacity: 0;
        }

        /* Animate the sprite only (not the username) */
        .user-shape.entering .shape {
            animation: popIn 0.5s ease-out forwards;
            will-change: transform, opacity;
        }

        /* Swivel/spin animation for existing users (no opacity flash) */
        .user-shape.swivel .shape {
            animation: swivelSpin 1.5s ease-out forwards;
            will-change: transform, opacity;
        }

        .user-shape.leaving {
            animation: liftFadeOut 0.6s ease-in forwards;
            /* Override any inline transforms during exit animation */
            transform-origin: center bottom;
            /* Ensure animation can override positioning */
            will-change: transform, opacity;
        }
        
        /* Apply preserved scale to the shape during exit */
        .user-shape.leaving .shape {
            transform: scaleX(var(--exit-scaleX, 1)) scaleY(var(--exit-scaleY, 1)) !important;
        }

        .user-shape.idle .shape {
            animation: floatIdle 3s ease-in-out infinite;
            will-change: transform;
        }

        .user-shape.moving .shape {
            animation: bounceWalk 0.6s ease-in-out infinite;
            will-change: transform;
        }
        
        /* Dancing animation - more energetic bounce with side-to-side */
        .user-shape.dancing .shape {
            animation: danceMove 0.3s ease-in-out infinite;
            will-change: transform;
        }
        
        @keyframes danceMove {
            0%, 100% {
                translate: 0 0;
                scale: 1 1;
            }
            25% {
                translate: -3px -8px;
                scale: 1.05 0.95;
            }
            50% {
                translate: 0 -12px;
                scale: 0.95 1.05;
            }
            75% {
                translate: 3px -8px;
                scale: 1.05 0.95;
            }
        }

        /* Sparkling animation - glow and pulse effect */
        .user-shape.sparkling .shape {
            animation: sparkleGlow 0.5s ease-in-out infinite alternate;
            will-change: filter, transform;
        }
        
        @keyframes sparkleGlow {
            0% {
                filter: brightness(1) drop-shadow(0 0 5px rgba(255, 255, 100, 0.8));
                scale: 1;
            }
            100% {
                filter: brightness(1.3) drop-shadow(0 0 15px rgba(255, 255, 100, 1)) drop-shadow(0 0 25px rgba(255, 200, 50, 0.8));
                scale: 1.1;
            }
        }
        
        /* Sparkle particle that swirls outward */
        .sparkle-particle {
            position: fixed;
            width: 10px;
            height: 10px;
            background: radial-gradient(circle, #fff 0%, #ffff00 30%, #ffa500 60%, transparent 100%);
            border-radius: 50%;
            pointer-events: none;
            z-index: 9999;
            box-shadow: 0 0 8px 3px rgba(255, 255, 100, 0.9), 0 0 12px 4px rgba(255, 200, 50, 0.6);
            /* Use margin to center instead of transform */
            margin-left: -5px;
            margin-top: -5px;
            /* Animation will be applied via inline style with specific keyframes */
            opacity: 1;
            transform: scale(1) translate(0, 0);
            transition: none;
        }
        
        /* Sparkle animation - uses transform for movement */
        .sparkle-particle.animating {
            animation: sparkleSwirl var(--sparkle-duration, 1s) ease-out forwards;
        }
        
        @keyframes sparkleSwirl {
            0% {
                opacity: 1;
                transform: scale(1) translate(0, 0);
            }
            50% {
                opacity: 1;
                transform: scale(1.5) translate(calc(var(--end-x, 0px) * 0.5), calc(var(--end-y, 0px) * 0.5));
            }
            100% {
                opacity: 0;
                transform: scale(0.5) translate(var(--end-x, 0px), var(--end-y, 0px));
            }
        }

        @keyframes popIn {
            0% {
                transform: scale(0) rotateY(0deg) translateY(0);
                opacity: 0;
            }
            50% {
                transform: scale(1.1) rotateY(180deg) translateY(0);
            }
            100% {
                transform: scale(1) rotateY(360deg) translateY(0);
                opacity: 1;
            }
        }

        @keyframes swivelSpin {
            /* Use transform longhands so we don't override inline transform (sprite size, flip, perspective) */
            /* 3 full rotations (1080¬∞) for a more satisfying spin */
            0% {
                rotate: y 0deg;
                scale: 1;
                translate: 0 0;
                opacity: 1;
            }
            25% {
                rotate: y 270deg;
                scale: 1.05;
                translate: 0 0;
                opacity: 1;
            }
            50% {
                rotate: y 540deg;
                scale: 1.08;
                translate: 0 0;
                opacity: 1;
            }
            75% {
                rotate: y 810deg;
                scale: 1.05;
                translate: 0 0;
                opacity: 1;
            }
            100% {
                rotate: y 1080deg;
                scale: 1;
                translate: 0 0;
                opacity: 1;
            }
        }

        @keyframes floatIdle {
            0%, 100% {
                /* Use transform longhands so we don't overwrite inline scaleX/scaleY (flip + perspective). */
                translate: 0 0;
                scale: 1;
            }
            50% {
                translate: 0 -3px; /* More subtle float - reduced from -8px */
                scale: 1;
            }
        }

        @keyframes bounceWalk {
            0%, 100% {
                /* IMPORTANT:
                   Movement animation must not override inline `transform` which carries:
                   - perspective scaling (scaleX/scaleY)
                   - flip state (left/right)
                   So we animate with transform longhands instead. */
                translate: 0 0;
                scale: 1 1;
            }
            25% {
                translate: 0 -5px;
                scale: 1 0.95;
            }
            50% {
                translate: 0 -10px;
                scale: 1 0.9;
            }
            75% {
                translate: 0 -5px;
                scale: 1 0.95;
            }
        }

        @keyframes liftFadeOut {
            0% {
                transform: translateY(0) scale(1);
                opacity: 1;
            }
            100% {
                transform: translateY(var(--lift-distance, -40px)) scale(1);
                opacity: 0;
            }
        }

        /* Debug circle visualization (hidden by default) */
        .debug-circle {
            position: absolute;
            border: none; /* Removed dashed border */
            border-radius: 50%;
            pointer-events: none;
            display: none; /* Hide debug circle */
        }

        /* Desktop App Menu Bar */
        .desktop-menu-bar {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: none; /* Hidden by default, shown only in desktop app */
            z-index: 999999 !important; /* Very high z-index to ensure it's on top */
            flex-direction: row;
            align-items: center;
            gap: 8px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 13px;
            pointer-events: auto; /* Ensure it can be clicked */
            /* Dragging is enabled when the window is frameless (Title Bar disabled). */
            -webkit-app-region: no-drag;
            transition: transform 0.3s ease-out, opacity 0.3s ease-out;
            opacity: 1;
            /* Give the whole bar a visible base so it doesn't vanish on transparent windows */
            padding: 6px;
            background: rgba(18, 18, 18, 0.92);
            border: 1px solid rgba(255, 255, 255, 0.14);
            border-radius: 10px;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.55);
        }

        /* Drag strip for frameless mode - separate from buttons for reliable clicks */
        .menu-drag-strip {
            display: none;
            width: 100%;
            height: 24px;
            -webkit-app-region: drag;
            cursor: grab;
            justify-content: center;
            align-items: center;
            color: rgba(255, 255, 255, 0.35);
            font-size: 14px;
            letter-spacing: 2px;
            user-select: none;
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
            margin-bottom: 4px;
        }

        .menu-drag-strip:active {
            cursor: grabbing;
        }

        body.frameless .menu-drag-strip {
            display: flex;
        }

        /* In frameless mode, use flex-wrap so drag strip is on its own row */
        body.frameless .desktop-menu-bar {
            flex-wrap: wrap;
            -webkit-app-region: no-drag;
        }

        .desktop-menu-bar.desktop-app {
            display: flex !important; /* Force display */
        }

        .desktop-menu-bar.hidden {
            transform: translateX(-50%) translateY(-60px);
            opacity: 0;
            pointer-events: none;
        }

        .menu-button {
            padding: 8px 14px;
            min-height: 32px;
            background: rgba(28, 28, 28, 0.95);
            backdrop-filter: none;
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 6px;
            color: #fff;
            cursor: pointer;
            -webkit-app-region: no-drag;
            transition: background 0.15s, border-color 0.15s;
            font-size: 12px;
            white-space: nowrap;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .menu-button:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .menu-button:active {
            background: rgba(255, 255, 255, 0.15);
        }

        .menu-button.primary {
            background: rgba(255, 107, 53, 0.3);
            border-color: rgba(255, 107, 53, 0.5);
        }

        .menu-button.primary:hover {
            background: rgba(255, 107, 53, 0.5);
            border-color: rgba(255, 107, 53, 0.7);
        }

        .menu-button.danger {
            background: rgba(255, 59, 48, 0.3);
            border-color: rgba(255, 59, 48, 0.5);
        }

        .menu-button.danger:hover {
            background: rgba(255, 59, 48, 0.5);
            border-color: rgba(255, 59, 48, 0.7);
        }
        
        .menu-button-square {
            width: 32px;
            height: 32px;
            padding: 0;
            background: rgba(28, 28, 28, 0.95);
            backdrop-filter: none;
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 6px;
            color: #fff;
            cursor: pointer;
            -webkit-app-region: no-drag;
            transition: background 0.15s, border-color 0.15s, transform 0.15s;
            font-size: 18px;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-weight: 600;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .menu-button-square:hover {
            border-color: rgba(255, 255, 255, 0.3);
            transform: translateY(-1px);
        }
        
        .menu-button-square:active {
            transform: translateY(0);
        }
        
        .menu-button-square.success {
            background: rgba(76, 175, 80, 0.3);
            border-color: rgba(76, 175, 80, 0.5);
        }
        
        .menu-button-square.success:hover {
            background: rgba(76, 175, 80, 0.5);
            border-color: rgba(76, 175, 80, 0.7);
        }
        
        .menu-button-square.danger {
            background: rgba(244, 67, 54, 0.3);
            border-color: rgba(244, 67, 54, 0.5);
        }
        
        .menu-button-square.danger:hover {
            background: rgba(244, 67, 54, 0.5);
            border-color: rgba(244, 67, 54, 0.7);
        }

        .menu-spacer {
            flex: 1;
        }

        .menu-status {
            padding: 6px 12px;
            min-height: 32px;
            font-size: 11px;
            color: rgba(255, 255, 255, 0.6);
            display: flex;
            align-items: center;
            gap: 6px;
            background: rgba(28, 28, 28, 0.95);
            backdrop-filter: none;
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            -webkit-app-region: no-drag;
        }

        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #ff3b30;
            animation: pulse 2s infinite;
        }

        .status-indicator.connected {
            background: #34c759;
        }
        
        @keyframes pulse {
            0% {
                transform: scale(1);
                opacity: 1;
            }
            50% {
                transform: scale(1.2);
                opacity: 0.7;
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }
        
        /* ============================================
           INTEGRATED DASHBOARD OVERLAY
           ============================================ */
        .dashboard-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            /* Keep the overlay clickable for close-on-backdrop, but don't darken the entire scene */
            background: transparent;
            backdrop-filter: none;
            z-index: 50000;
            display: none;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .dashboard-overlay.active {
            display: flex;
            opacity: 1;
        }
        
        .dashboard-panel {
            background: #1f1f1f;
            border: 1px solid #3a3a3a;
            border-radius: 12px;
            width: 600px;
            height: 500px;
            display: flex;
            flex-direction: column;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.9);
            overflow: hidden;
        }
        
        .dashboard-header {
            padding: 15px 20px;
            border-bottom: 1px solid #3a3a3a;
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: #1a1a1a;
            flex-shrink: 0;
        }
        
        .dashboard-title {
            font-size: 18px;
            font-weight: 600;
            color: #fff;
        }
        
        .dashboard-close {
            background: none;
            border: none;
            color: #888;
            font-size: 28px;
            cursor: pointer;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: all 0.2s;
        }
        
        .dashboard-close:hover {
            background: #333;
            color: #fff;
        }
        
        .dashboard-tabs {
            display: flex;
            gap: 0;
            padding: 0 20px;
            background: #1a1a1a;
            border-bottom: 1px solid #3a3a3a;
            overflow-x: auto;
            flex-shrink: 0;
        }
        
        .dashboard-tab {
            padding: 12px 16px;
            background: none;
            border: none;
            color: #888;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
            white-space: nowrap;
        }
        
        .dashboard-tab:hover {
            color: #fff;
            background: #252525;
        }
        
        .dashboard-tab.active {
            color: #667eea;
            border-bottom-color: #667eea;
        }
        
        .dashboard-content {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }
        
        .dashboard-section {
            display: none !important;
        }
        
        .dashboard-section.active {
            display: block !important;
        }
        
        .form-group {
            margin-bottom: 20px;
        }
        
        .form-group label {
            display: block;
            font-size: 13px;
            font-weight: 600;
            color: #aaa;
            margin-bottom: 6px;
        }
        
        .form-group input,
        .form-group select {
            width: 100%;
            padding: 10px 12px;
            background: #2a2a2a;
            border: 1px solid #3a3a3a;
            border-radius: 6px;
            color: #fff;
            font-size: 14px;
            transition: all 0.2s;
        }
        
        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: #667eea;
            background: #333;
        }
        
        .form-hint {
            display: block;
            font-size: 11px;
            color: #666;
            margin-top: 4px;
        }
        
        .button {
            padding: 10px 16px;
            background: #667eea;
            color: #fff;
            border: none;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .button:hover {
            background: #5568d3;
        }
        
        .button-secondary {
            background: #3a3a3a;
        }
        
        .button-secondary:hover {
            background: #4a4a4a;
        }
        
        .button-danger {
            background: #ff4444;
        }
        
        .button-danger:hover {
            background: #cc0000;
        }
        
        .test-users-section {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        
        .members-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 10px;
        }
        
        .member-item {
            padding: 10px 12px;
            background: #2a2a2a;
            border: 1px solid #3a3a3a;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .member-name {
            font-weight: 600;
            color: #fff;
        }
        .member-name.status-not-joined { color: #777; }
        .member-name.status-active { color: #fff; }
        .member-name.status-joined { }
        .member-name.status-sleepy {
            animation: sleepyPulse 2.4s ease-in-out infinite;
        }
        .member-zzz {
            margin-left: 6px;
            font-size: 11px;
            letter-spacing: 1px;
            opacity: 0.75;
            animation: zzzFloat 1.8s ease-in-out infinite;
            user-select: none;
        }
        @keyframes sleepyPulse {
            0%, 100% { opacity: 0.55; }
            50% { opacity: 1; }
        }
        @keyframes zzzFloat {
            0%, 100% { opacity: 0.35; transform: translateY(0); }
            50% { opacity: 0.95; transform: translateY(-2px); }
        }
        
        .member-status {
            font-size: 11px;
            color: #888;
            margin-left: 8px;
        }
        
        .member-actions {
            display: flex;
            gap: 6px;
        }
        
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 8px 0;
        }
        
        .checkbox-group input[type="checkbox"] {
            width: auto;
            margin: 0;
        }
    </style>
</head>
<body>
    <!-- Desktop App Menu Bar (only visible in Electron) -->
    <div class="desktop-menu-bar" id="desktopMenuBar">
        <!-- Drag strip for frameless/transparent mode - keeps buttons clickable -->
        <div class="menu-drag-strip" title="Drag to move window">‚ãÆ‚ãÆ‚ãÆ</div>
        <button class="menu-button" id="btnSettings">‚öôÔ∏è</button>
        <button class="menu-button" id="btnMembers">üë•</button>
        <button class="menu-button-square success" id="btnShowAll">‚úì</button>
        <button class="menu-button-square danger" id="btnHideAll">‚úï</button>
        <button class="menu-button" id="btnDashboard">üìü</button>
        <button class="menu-button" id="btnChatPopout">üí¨</button>
        <div class="menu-spacer"></div>
        <div class="menu-status">
            <div class="status-indicator" id="statusIndicator"></div>
        </div>
        <button class="menu-button-square danger" id="btnKickAllUsers" title="Kick all (non-test) users">‚òÅÔ∏è</button>
        <button class="menu-button-square success" id="btnJoinControlled" title="Join all (controlled)">üî•</button>
        <button class="menu-button-square" id="btnJoinChaos" title="Join all (chaos)">‚ö°</button>
        <button class="menu-button danger" id="btnEnd">End</button>
    </div>
    
    <!-- Integrated Dashboard Overlay -->
    <div class="dashboard-overlay" id="dashboardOverlay">
        <div class="dashboard-panel">
            <div class="dashboard-header">
                <button class="dashboard-close" onclick="closeDashboard()">√ó</button>
            </div>
            
            <div class="dashboard-tabs" id="dashboardTabs">
                <button class="dashboard-tab active" onclick="switchDashboardTab('quick')">Quick Settings</button>
                <button class="dashboard-tab" onclick="switchDashboardTab('members')">Members</button>
            </div>
            
            <div class="dashboard-content">
                <!-- Quick Settings Tab -->
                <div class="dashboard-section active" id="quickSection">
                    <h3 style="color: #fff; margin-bottom: 15px;">‚ö° Quick Settings</h3>
                    
                    <div class="form-group">
                        <label for="spriteMode">Sprite Mode</label>
                        <select id="spriteMode" onchange="updateSpriteMode()">
                            <option value="circles">CIRCLES</option>
                            <option value="circle">SHADOWS</option>
                            <option value="rpg-characters">ADVENTURERS (pixel characters)</option>
                            <option value="pixel-morphs">MORPHS (animated morphs)</option>
                            <option value="custom">CUSTOM (upload your own)</option>
                        </select>
                    </div>
                    
                    <div class="form-group">
                        <label for="maxUsers">Maximum Users</label>
                        <input type="number" id="maxUsers" value="20" min="1" max="50" onchange="updateMaxUsers()">
                        <span class="form-hint">Maximum number of users around the campfire</span>
                    </div>
                    
                    <div class="form-group">
                        <label for="joinMethod">Join Method</label>
                        <select id="joinMethod" onchange="updateJoinMethod()">
                            <option value="command">Chat Command (!join)</option>
                            <option value="emote">Emote</option>
                            <option value="cheer">Cheer/Bits</option>
                        </select>
                    </div>

                    <div class="form-group" id="quickCommandSettings">
                        <label for="quickJoinCommand">Join Command</label>
                        <input type="text" id="quickJoinCommand" value="!join" placeholder="!join" oninput="updateJoinMethod()">
                        <span class="form-hint">Users must type this command to join</span>
                    </div>

                    <div class="form-group" id="quickEmoteSettings" style="display: none;">
                        <label for="quickJoinEmote">Join Emote Name</label>
                        <input type="text" id="quickJoinEmote" value="" placeholder="heafthCamp" oninput="updateJoinMethod()">
                        <span class="form-hint">Users can type this emote/code to join</span>
                    </div>
                    
                    <div class="form-group" id="quickCheerSettings" style="display: none;">
                        <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px; align-items: start;">
                            <div>
                                <label for="quickCheerType" style="display: block; margin-bottom: 8px;">Payment Type</label>
                                <select id="quickCheerType">
                                    <option value="bits">Bits</option>
                                    <option value="channel-points">Channel Points</option>
                                </select>
                            </div>
                            <div>
                                <label for="quickCheerAmount" style="display: block; margin-bottom: 8px;">Amount</label>
                                <input type="number" id="quickCheerAmount" value="100" min="1">
                            </div>
                        </div>
                    </div>

                    <div class="form-group" style="margin-top: 10px;">
                        <label style="display:flex; align-items:center; gap:10px;">
                            <input type="checkbox" id="muteChatBubbles" onchange="updateMuteChatBubbles()">
                            <span>Mute chat bubbles</span>
                        </label>
                        <div id="muteChatBubblesOptions" style="display:none; margin-top:10px; padding:10px; border:1px solid #333; border-radius:8px; background:#1f1f1f;">
                            <div style="font-size: 12px; color:#aaa; margin-bottom:8px;">Allow chat bubbles only for:</div>
                            <div style="display:grid; grid-template-columns: 1fr 1fr; gap:8px;">
                                <label style="display:flex; align-items:center; gap:8px;"><input type="checkbox" id="muteAllowVip" onchange="updateMuteChatBubbles()"> VIP</label>
                                <label style="display:flex; align-items:center; gap:8px;"><input type="checkbox" id="muteAllowMod" onchange="updateMuteChatBubbles()"> MOD</label>
                                <label style="display:flex; align-items:center; gap:8px;"><input type="checkbox" id="muteAllowTier1" onchange="updateMuteChatBubbles()"> TIER 1</label>
                                <label style="display:flex; align-items:center; gap:8px;"><input type="checkbox" id="muteAllowTier2" onchange="updateMuteChatBubbles()"> TIER 2</label>
                                <label style="display:flex; align-items:center; gap:8px;"><input type="checkbox" id="muteAllowTier3" onchange="updateMuteChatBubbles()"> TIER 3</label>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Members Tab -->
                <div class="dashboard-section" id="membersSection">
                    <h3 style="color: #fff; margin-bottom: 15px;">üë• Campfire Members</h3>
                    <div class="members-list" id="membersList">
                        <p style="color: #888;">No members yet. Users will appear here when they join.</p>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="widget-container">
        <div class="campfire-area">
            <div class="circle-container" id="circleContainer">
                <!-- Debug circle (optional, for visualization) -->
                <div class="debug-circle" id="debugCircle"></div>
                
                <!-- User shapes will be dynamically added here -->
            </div>
            
            <div class="campfire-graphic" id="campfireGraphic">
                <!-- Campfire GIF/video will be inserted here -->
            </div>
        </div>
    </div>

    <script>
        // ============================================
        // MENU BAR - Check if we should show it
        // ============================================
        // Hide menu bar in preview/test contexts (iframe, popup windows, etc.)
        const isPreviewContext = window.self !== window.top || window.opener !== null || window.location.search.includes('preview=true') || window.location.search.includes('test=true');
        
        if (isPreviewContext) {
            console.log('[Menu Bar] Hiding menu bar - in preview/test context');
            const menuBar = document.getElementById('desktopMenuBar');
            if (menuBar) {
                menuBar.style.display = 'none';
            }
        }
        
        // ============================================
        // Audio Manager for sound effects
        // ============================================
        class AudioManager {
            constructor() {
                this.audioElements = {};
                this.settings = {};
                this.enabled = true;
            }
            
            updateSettings(audioSettings) {
                if (!audioSettings) return;
                this.settings = audioSettings;
            }
            
            playSound(soundType) {
                if (!this.enabled) return;
                
                let audioData = null;
                let volume = 0.5;
                
                // Get audio data based on sound type
                if (soundType === 'join' && this.settings.userSounds?.join) {
                    audioData = this.settings.userSounds.join.fileData;
                    volume = (parseInt(this.settings.userSounds.join.gain) || 80) / 100;
                } else if (soundType === 'leave' && this.settings.userSounds?.leave) {
                    audioData = this.settings.userSounds.leave.fileData;
                    volume = (parseInt(this.settings.userSounds.leave.gain) || 60) / 100;
                } else if (soundType === 'speak' && this.settings.userSounds?.speak) {
                    audioData = this.settings.userSounds.speak.fileData;
                    volume = (parseInt(this.settings.userSounds.speak.gain) || 40) / 100;
                } else if (soundType === 'afk' && this.settings.userSounds?.afk) {
                    audioData = this.settings.userSounds.afk.fileData;
                    volume = (parseInt(this.settings.userSounds.afk.gain) || 50) / 100;
                } else if (soundType === 'lurk' && this.settings.userSounds?.lurk) {
                    audioData = this.settings.userSounds.lurk.fileData;
                    volume = (parseInt(this.settings.userSounds.lurk.gain) || 50) / 100;
                } else if (soundType === 'music' && this.settings.music) {
                    audioData = this.settings.music.fileData;
                    volume = (parseInt(this.settings.music.volume) || 70) / 100;
                } else if (soundType === 'ambience' && this.settings.ambience) {
                    audioData = this.settings.ambience.fileData;
                    volume = (parseInt(this.settings.ambience.volume) || 50) / 100;
                }
                
                if (!audioData) {
                    return; // No audio file configured for this sound type
                }
                
                try {
                    // Stop existing sound of same type if playing
                    if (this.audioElements[soundType]) {
                        this.audioElements[soundType].pause();
                        this.audioElements[soundType].currentTime = 0;
                    }
                    
                    // Create and play new audio
                    const audio = new Audio(audioData);
                    audio.volume = volume;
                    this.audioElements[soundType] = audio;
                    
                    // Handle looping for music/ambience
                    if ((soundType === 'music' && this.settings.music?.loop) ||
                        (soundType === 'ambience' && this.settings.ambience?.loop)) {
                        audio.loop = true;
                    }
                    
                    // Get selected audio output device from localStorage
                    const selectedDeviceId = localStorage.getItem('audioOutputDeviceId') || '';
                    
                    // Set audio output device if selected and supported
                    if (selectedDeviceId && audio.setSinkId) {
                        audio.setSinkId(selectedDeviceId).then(() => {
                            audio.play().catch(e => {
                                console.warn(`[AudioManager] Could not play ${soundType} sound:`, e.message);
                            });
                        }).catch(err => {
                            console.warn(`[AudioManager] Could not set audio output device:`, err.message);
                            // Fall back to default device
                            audio.play().catch(e => {
                                console.warn(`[AudioManager] Could not play ${soundType} sound:`, e.message);
                            });
                        });
                    } else {
                        audio.play().catch(e => {
                            // Autoplay may be blocked by browser
                            console.warn(`[AudioManager] Could not play ${soundType} sound:`, e.message);
                        });
                    }
                } catch (e) {
                    console.error(`[AudioManager] Error playing ${soundType} sound:`, e);
                }
            }
            
            stopSound(soundType) {
                if (this.audioElements[soundType]) {
                    this.audioElements[soundType].pause();
                    this.audioElements[soundType].currentTime = 0;
                }
            }
            
            stopAll() {
                Object.keys(this.audioElements).forEach(type => {
                    this.stopSound(type);
                });
            }
            
            // Auto-play music and ambience if enabled in settings
            async autoPlayOnLoad() {
                const audioSettings = JSON.parse(localStorage.getItem('audioSettings') || '{}');
                
                // Auto-play music if enabled
                if (audioSettings.music?.autoPlay) {
                    let audioData = audioSettings.music?.fileData;
                    
                    // Load from disk if useFileStorage is set
                    if (!audioData && audioSettings.music?.useFileStorage && window.electronAPI?.loadAudioFile) {
                        try {
                            const result = await window.electronAPI.loadAudioFile('music');
                            if (result.success) {
                                audioData = result.fileData;
                            }
                        } catch (e) {
                            console.error('[AudioManager] Failed to load music from disk:', e);
                        }
                    }
                    
                    if (audioData) {
                        this.settings.music = {
                            fileData: audioData,
                            volume: audioSettings.music?.volume || 70,
                            loop: audioSettings.music?.loop !== false
                        };
                        setTimeout(() => this.playSound('music'), 500);
                        console.log('[AudioManager] Auto-playing music');
                    }
                }
                
                // Auto-play ambience if enabled
                if (audioSettings.ambience?.autoPlay) {
                    let audioData = audioSettings.ambience?.fileData;
                    
                    // Load from disk if useFileStorage is set
                    if (!audioData && audioSettings.ambience?.useFileStorage && window.electronAPI?.loadAudioFile) {
                        try {
                            const result = await window.electronAPI.loadAudioFile('ambience');
                            if (result.success) {
                                audioData = result.fileData;
                            }
                        } catch (e) {
                            console.error('[AudioManager] Failed to load ambience from disk:', e);
                        }
                    }
                    
                    if (audioData) {
                        this.settings.ambience = {
                            fileData: audioData,
                            volume: audioSettings.ambience?.volume || 50,
                            loop: audioSettings.ambience?.loop !== false
                        };
                        setTimeout(() => this.playSound('ambience'), 700);
                        console.log('[AudioManager] Auto-playing ambience');
                    }
                }
            }
        }
        
        // Global audio manager instance
        const audioManager = new AudioManager();
        
        class CampfireWidget {
            constructor() {
                console.log('CampfireWidget constructor called');
                this.users = [];
                this.settings = this.loadSettings();
                console.log('Settings loaded:', this.settings);
                this.circleRadius = 120;
                this.circleAngle = this.settings.circleAngle || 0; // 0 = top-down, 90 = side-view
                this.maxUsers = this.settings.maxUsers || 20;
                this.animationFrame = null;
                
                console.log('Calling init()...');
                (async () => {
                    await this.init();
                    console.log('Init completed');
                })();
            }

            loadSettings() {
                // First, try to load from URL parameters (for Custom Widget)
                const urlParams = new URLSearchParams(window.location.search);
                const urlSettings = {};
                
                if (urlParams.has('graphic')) urlSettings.campfireGraphicUrl = decodeURIComponent(urlParams.get('graphic'));
                if (urlParams.has('angle')) urlSettings.circleAngle = parseInt(urlParams.get('angle'));
                if (urlParams.has('joinMethod')) urlSettings.joinMethod = urlParams.get('joinMethod');
                if (urlParams.has('command')) urlSettings.command = urlParams.get('command');
                if (urlParams.has('emoteName')) urlSettings.emoteName = urlParams.get('emoteName');
                if (urlParams.has('maxUsers')) urlSettings.maxUsers = parseInt(urlParams.get('maxUsers'));
                if (urlParams.has('shapeStyle')) urlSettings.shapeStyle = urlParams.get('shapeStyle');
                if (urlParams.has('subOnly')) urlSettings.subscriberOnly = urlParams.get('subOnly') === 'true';
                if (urlParams.has('subTier2')) urlSettings.subTier2Only = urlParams.get('subTier2') === 'true';
                if (urlParams.has('subTier3')) urlSettings.subTier3Only = urlParams.get('subTier3') === 'true';
                if (urlParams.has('vipOnly')) urlSettings.vipOnly = urlParams.get('vipOnly') === 'true';
                if (urlParams.has('primeOnly')) urlSettings.primeOnly = urlParams.get('primeOnly') === 'true';
                if (urlParams.has('bits')) urlSettings.bitsRequired = parseInt(urlParams.get('bits'));
                if (urlParams.has('glowSize')) urlSettings.glowSize = parseInt(urlParams.get('glowSize'));
                if (urlParams.has('glowIntensity')) urlSettings.glowIntensity = parseInt(urlParams.get('glowIntensity'));
                if (urlParams.has('shadowIntensity')) urlSettings.shadowIntensity = parseInt(urlParams.get('shadowIntensity'));
                if (urlParams.has('glowSpread')) urlSettings.glowSpread = parseInt(urlParams.get('glowSpread'));
                if (urlParams.has('flickerOpacity')) urlSettings.flickerOpacity = parseInt(urlParams.get('flickerOpacity'));
                if (urlParams.has('flickerSpread')) urlSettings.flickerSpread = parseInt(urlParams.get('flickerSpread'));
                if (urlParams.has('animatedGlow')) urlSettings.animatedGlow = urlParams.get('animatedGlow') === 'true';
                if (urlParams.has('spriteMode')) urlSettings.spriteMode = urlParams.get('spriteMode');
                if (urlParams.has('fireSize')) urlSettings.fireSize = parseInt(urlParams.get('fireSize'));
                if (urlParams.has('spriteSize')) urlSettings.spriteSize = parseInt(urlParams.get('spriteSize'));
                if (urlParams.has('spriteDefaultDirection')) urlSettings.spriteDefaultDirection = urlParams.get('spriteDefaultDirection');
                
                // Load sprite data from localStorage (always check for latest)
                const defaultSprite = localStorage.getItem('defaultSpriteData');
                const customSprite = localStorage.getItem('customSpriteData');
                
                // If URL params exist, use them (Custom Widget mode)
                if (Object.keys(urlSettings).length > 0) {
                    if (defaultSprite) urlSettings.defaultSpriteData = defaultSprite;
                    if (customSprite) urlSettings.customSpriteData = customSprite;
                    return { ...this.getDefaultSettings(), ...urlSettings };
                }
                
                // Otherwise, try to load from LocalStorage (set by dashboard)
                const saved = localStorage.getItem('campfireWidgetSettings');
                if (saved) {
                    try {
                        const settings = { ...this.getDefaultSettings(), ...JSON.parse(saved) };
                        // Always load latest sprite data from localStorage
                        if (defaultSprite) settings.defaultSpriteData = defaultSprite;
                        if (customSprite) settings.customSpriteData = customSprite;
                        return settings;
                    } catch (e) {
                        console.error('Error loading settings:', e);
                    }
                }
                
                // Also check localStorage for sprites even if no settings saved
                if (defaultSprite || customSprite) {
                    const settings = this.getDefaultSettings();
                    if (defaultSprite) settings.defaultSpriteData = defaultSprite;
                    if (customSprite) settings.customSpriteData = customSprite;
                    return settings;
                }
                
                // Return default settings
                return this.getDefaultSettings();
            }

            getDefaultSettings() {
                return {
                    campfireMethod: 'url',
                    campfireGraphicUrl: '',
                    campfireGraphicData: '',
                    campfireYOffset: 50, // 0‚Äì100, where 50 = centered
                    widgetBackground: 'black', // 'transparent' | 'black' | 'white' | 'green'
                    useNativeFrame: true,
                            // Chat bubbles
                            muteChatBubbles: false,
                            muteAllowVip: false,
                            muteAllowMod: true,
                            muteAllowTier1: false,
                            muteAllowTier2: false,
                            muteAllowTier3: false,
                            hideNameplates: false,
                    circleAngle: 64,
                    joinMethod: 'command',
                    command: '!join',
                    emoteName: '',
                    maxUsers: 20,
                    shapeStyle: 'circle',
                    subscriberOnly: false,
                    subTier2Only: false,
                    subTier3Only: false,
                    vipOnly: false,
                    primeOnly: false,
                    bitsRequired: 0,
                    glowSize: 500,
                    glowIntensity: 77,
                    shadowIntensity: 91,
                    glowSpread: 64,
                    animatedGlow: true,
                    flickerOpacity: 25,
                    flickerSpread: 55,
                    spriteMode: 'circles',
                    defaultSpriteData: '',
                    customSpriteData: '',
                    shadowSprites: [],
                    rpgSprites: [],
                    morphSprites: [],
                    fireSize: 48,
                    spriteSize: 40,
                    spriteDefaultDirection: 'left', // 'left' or 'right'
                    enableUserGrouping: false, // If true, users group near each other; if false, even distribution
                    userGroupingDistance: 15 // Minimum degrees between users when grouping (default 15¬∞)
                };
            }
            
            // Helper to extract sprite data string from various formats
            // Handles: string, {data: string}, {data: {data: string}}, etc.
            extractSpriteDataString(spriteData) {
                if (!spriteData) return null;
                if (typeof spriteData === 'string') return spriteData;
                if (typeof spriteData === 'object') {
                    // Try to extract .data property
                    if (spriteData.data) {
                        return this.extractSpriteDataString(spriteData.data);
                    }
                }
                console.warn('[extractSpriteDataString] Could not extract string from:', typeof spriteData);
                return null;
            }
            
            // Get a random sprite from a collection
            getRandomSprite(collection) {
                if (!collection || collection.length === 0) return null;
                const sprite = collection[Math.floor(Math.random() * collection.length)];
                // Ensure sprite.data is a string
                if (sprite && sprite.data) {
                    const dataString = this.extractSpriteDataString(sprite.data);
                    if (dataString && dataString !== sprite.data) {
                        // Fix the sprite object in place to prevent future issues
                        sprite.data = dataString;
                    }
                }
                return sprite;
            }
            
            // Get role-based sprite for user (if enabled and applicable)
            getRoleSpriteForUser(user) {
                // Check if role-based sprites are enabled (from settings synced via IPC)
                const roleSprites = this.settings.roleSprites;
                if (!roleSprites || !roleSprites.enabled) return null;
                
                try {
                    
                    // Get user roles (from user object or default to regular)
                    const roles = user.roles || {};
                    
                    // Check roles in priority order: Broadcaster > Mod > VIP > Subscriber
                    // Broadcaster
                    if (roles.isBroadcaster && roleSprites.broadcaster && roleSprites.broadcaster.enabled) {
                        const sprite = this.getRoleSpriteData(roleSprites.broadcaster);
                        if (sprite) {
                            console.log(`[getRoleSpriteForUser] ${user.username} using Broadcaster sprite`);
                            return sprite;
                        }
                    }
                    
                    // Moderator
                    if (roles.isMod && roleSprites.moderator && roleSprites.moderator.enabled) {
                        const sprite = this.getRoleSpriteData(roleSprites.moderator);
                        if (sprite) {
                            console.log(`[getRoleSpriteForUser] ${user.username} using Moderator sprite`);
                            return sprite;
                        }
                    }
                    
                    // VIP
                    if (roles.isVip && roleSprites.vip && roleSprites.vip.enabled) {
                        const sprite = this.getRoleSpriteData(roleSprites.vip);
                        if (sprite) {
                            console.log(`[getRoleSpriteForUser] ${user.username} using VIP sprite`);
                            return sprite;
                        }
                    }
                    
                    // Subscriber
                    if (roles.isSubscriber && roleSprites.subscriber && roleSprites.subscriber.enabled) {
                        const sprite = this.getRoleSpriteData(roleSprites.subscriber);
                        if (sprite) {
                            console.log(`[getRoleSpriteForUser] ${user.username} using Subscriber sprite`);
                            return sprite;
                        }
                    }
                    
                    // No role-based sprite found, return null to use default
                    return null;
                } catch (e) {
                    console.warn('[getRoleSpriteForUser] Error parsing role sprites:', e);
                    return null;
                }
            }
            
            // Get sprite data from role sprite config
            getRoleSpriteData(roleConfig) {
                if (!roleConfig) return null;
                
                // Custom uploaded sprite
                if (roleConfig.sprite === 'custom' && roleConfig.customData) {
                    const dataString = this.extractSpriteDataString(roleConfig.customData);
                    if (dataString) {
                        return {
                            data: dataString,
                            colorize: false
                        };
                    }
                }
                
                // Sprite from a mode (e.g., "rpg:Knight" or "morph:pixelmorph_blue")
                if (roleConfig.sprite && roleConfig.sprite.includes(':')) {
                    const [mode, name] = roleConfig.sprite.split(':');
                    let spriteCollection = [];
                    
                    if (mode === 'rpg') {
                        spriteCollection = this.settings.rpgSprites || [];
                    } else if (mode === 'morph') {
                        spriteCollection = this.settings.morphSprites || [];
                    } else if (mode === 'shadow') {
                        spriteCollection = this.settings.shadowSprites || [];
                    }
                    
                    const sprite = spriteCollection.find(s => s.name === name);
                    if (sprite && sprite.data) {
                        const dataString = this.extractSpriteDataString(sprite.data);
                        if (dataString) {
                            return {
                                data: dataString,
                                colorize: mode === 'shadow' || mode === 'morph'
                            };
                        }
                    }
                }
                
                return null;
            }
            
            // Get sprite for user based on mode and user preferences
            getUserSprite(user) {
                const spriteMode = this.settings.spriteMode || 'circles';
                // For circle/circles modes: use getCircleSpriteColor (checks saved colors first, then Twitch color)
                // For other modes: use getViewerColor (for sprite colorization if needed, but usernames use getTwitchColor)
                const viewerColor = (spriteMode === 'circle' || spriteMode === 'circles')
                    ? this.getCircleSpriteColor(user.username, user.userId)
                    : (user.color || this.getViewerColor(user.username, user.userId));
                
                // Ensure sprite collections are arrays
                if (!Array.isArray(this.settings.rpgSprites)) this.settings.rpgSprites = [];
                if (!Array.isArray(this.settings.shadowSprites)) this.settings.shadowSprites = [];
                if (!Array.isArray(this.settings.morphSprites)) this.settings.morphSprites = [];
                
                // Debug: Log sprite availability (only once per user)
                if (!user.assignedSprite && !user.selectedSprite && !user._spriteLogged) {
                    console.log(`[getUserSprite] ${user.username} - Mode: ${spriteMode}, RPG: ${this.settings.rpgSprites.length}, Shadows: ${this.settings.shadowSprites.length}, Morph: ${this.settings.morphSprites.length}`);
                    user._spriteLogged = true;
                }
                
                // Check for role-based sprites first
                const roleSprite = this.getRoleSpriteForUser(user);
                if (roleSprite) {
                    return roleSprite;
                }
                
                if (spriteMode === 'rpg-characters') {
                    // RPG mode: use random sprite (or user's selected one)
                    // Initialize spritesByMode if needed
                    if (!user.spritesByMode) user.spritesByMode = {};

                    // User's saved RPG sprite (from Viewer Dashboard / persistence).
                    // Only applies when spriteMode is RPG so mode switching actually updates everyone.
                    if (user.selectedSprite) {
                        let spriteData = typeof user.selectedSprite === 'string'
                            ? user.selectedSprite
                            : (user.selectedSprite.data || user.selectedSprite);
                        
                        // Ensure spriteData is a string (handle nested objects)
                        if (typeof spriteData !== 'string') {
                            if (typeof spriteData === 'object' && spriteData.data) {
                                spriteData = spriteData.data;
                            }
                        }
                        
                        if (spriteData && typeof spriteData === 'string') {
                            user.spritesByMode['rpg-characters'] = spriteData;
                            return { data: spriteData, colorize: false };
                        }
                    }
                    
                    // Check if user already has a sprite for this mode
                    if (user.spritesByMode['rpg-characters']) {
                        // Validate that the cached sprite is a string
                        let cachedSprite = user.spritesByMode['rpg-characters'];
                        if (typeof cachedSprite !== 'string') {
                            console.warn(`[getUserSprite] Cached sprite is not a string for ${user.username}:`, typeof cachedSprite);
                            // Try to extract string data
                            if (typeof cachedSprite === 'object' && cachedSprite.data) {
                                cachedSprite = cachedSprite.data;
                                user.spritesByMode['rpg-characters'] = cachedSprite; // Fix the cache
                            }
                            // If still not a string, clear the cache and get a new sprite
                            if (typeof cachedSprite !== 'string') {
                                console.error(`[getUserSprite] Could not fix cached sprite for ${user.username}, clearing cache`);
                                delete user.spritesByMode['rpg-characters'];
                                cachedSprite = null;
                            }
                        }
                        if (cachedSprite) {
                            return {
                                data: cachedSprite,
                                colorize: false
                            };
                        }
                    }
                    
                    const rpgSprites = this.settings.rpgSprites || [];
                    if (rpgSprites.length === 0) {
                        console.warn(`[getUserSprite] No RPG sprites available for ${user.username}, using fallback`);
                    }
                    const sprite = this.getRandomSprite(rpgSprites);
                    if (sprite && sprite.data) {
                        // CRITICAL: Ensure sprite.data is a string, not an object
                        // This handles cases where sprites might have nested data structures
                        let spriteDataString = sprite.data;
                        if (typeof spriteDataString !== 'string') {
                            console.warn(`[getUserSprite] sprite.data is not a string for ${user.username}:`, typeof spriteDataString);
                            // Try to extract the actual data string
                            if (typeof spriteDataString === 'object' && spriteDataString.data) {
                                spriteDataString = spriteDataString.data;
                            }
                            // If still not a string, skip this sprite
                            if (typeof spriteDataString !== 'string') {
                                console.error(`[getUserSprite] Could not extract string data from sprite for ${user.username}`);
                                spriteDataString = null;
                            }
                        }
                        
                        if (spriteDataString) {
                            // Store the assigned sprite so it doesn't change on updates
                            user.spritesByMode['rpg-characters'] = spriteDataString;
                            return {
                                data: spriteDataString,
                                colorize: false // RPG sprites aren't colorized
                            };
                        }
                    }
                    // Fallback: Use colored circle (ALL modes fall back to circles when sprites fail)
                    console.warn(`[getUserSprite] No valid RPG sprite found for ${user.username}, falling back to colored circle`);
                    const svgCircle = 'data:image/svg+xml;base64,' + btoa(`
                        <svg width="40" height="40" xmlns="http://www.w3.org/2000/svg">
                            <circle cx="20" cy="20" r="18" fill="${viewerColor}" stroke="${viewerColor}" stroke-width="2"/>
                        </svg>
                    `);
                    user.spritesByMode['rpg-characters'] = svgCircle;
                    return {
                        data: svgCircle,
                        colorize: false,
                        color: viewerColor
                    };
                } else if (spriteMode === 'circles') {
                    // Circles mode: use simple colored SVG circles (Twitch username color or saved custom color)
                    // Initialize spritesByMode if needed
                    if (!user.spritesByMode) user.spritesByMode = {};
                    
                    // Check if user already has a sprite for this mode
                    if (user.spritesByMode['circles']) {
                        return {
                            data: user.spritesByMode['circles'],
                            colorize: false, // Already colored
                            color: viewerColor
                        };
                    }
                    
                    // Create a colored SVG circle with the user's color
                    const svgCircle = 'data:image/svg+xml;base64,' + btoa(`
                        <svg width="40" height="40" xmlns="http://www.w3.org/2000/svg">
                            <circle cx="20" cy="20" r="18" fill="${viewerColor}" stroke="${viewerColor}" stroke-width="2"/>
                        </svg>
                    `);
                    user.spritesByMode['circles'] = svgCircle;
                    return {
                        data: svgCircle,
                        colorize: false, // Already colored
                        color: viewerColor
                    };
                } else if (spriteMode === 'circle') {
                    // Circle/Shadows mode: use shadow sprites and colorize them
                    // Initialize spritesByMode if needed
                    if (!user.spritesByMode) user.spritesByMode = {};
                    
                    // Check if user already has a sprite for this mode
                    if (user.spritesByMode['circle']) {
                        return {
                            data: user.spritesByMode['circle'],
                            colorize: true,
                            color: viewerColor
                        };
                    }
                    
                    const shadowSprites = this.settings.shadowSprites || [];
                    const sprite = this.getRandomSprite(shadowSprites);
                    if (sprite && sprite.data) {
                        user.spritesByMode['circle'] = sprite.data;
                        return {
                            data: sprite.data,
                            colorize: true,
                            color: viewerColor
                        };
                    }
                    
                    // Fallback: Create a colored SVG circle (ALL modes fall back to circles when sprites fail)
                    console.warn(`[getUserSprite] No shadow sprites available for ${user.username}, using SVG circle fallback`);
                    const svgCircle = 'data:image/svg+xml;base64,' + btoa(`
                        <svg width="40" height="40" xmlns="http://www.w3.org/2000/svg">
                            <circle cx="20" cy="20" r="18" fill="${viewerColor}" stroke="${viewerColor}" stroke-width="2"/>
                        </svg>
                    `);
                    user.spritesByMode['circle'] = svgCircle;
                    return {
                        data: svgCircle,
                        colorize: false, // Already colored
                        color: viewerColor
                    };
                } else if (spriteMode === 'pixel-morphs') {
                    // Morph mode: use random morph sprite and colorize it
                    // Initialize spritesByMode if needed
                    if (!user.spritesByMode) user.spritesByMode = {};
                    
                    // Check if user already has a sprite for this mode
                    if (user.spritesByMode['pixel-morphs']) {
                        return {
                            data: user.spritesByMode['pixel-morphs'],
                            colorize: true,
                            color: viewerColor
                        };
                    }
                    
                    const morphSprites = this.settings.morphSprites || [];
                    const sprite = this.getRandomSprite(morphSprites);
                    if (sprite && sprite.data) {
                        user.spritesByMode['pixel-morphs'] = sprite.data;
                        return {
                            data: sprite.data,
                            colorize: true,
                            color: viewerColor
                        };
                    }
                    // Fallback: Create a colored SVG circle (ALL modes fall back to circles when sprites fail)
                    console.warn(`[getUserSprite] No morph sprites available for ${user.username}, using circle fallback`);
                    const svgCircle = 'data:image/svg+xml;base64,' + btoa(`
                        <svg width="40" height="40" xmlns="http://www.w3.org/2000/svg">
                            <circle cx="20" cy="20" r="18" fill="${viewerColor}" stroke="${viewerColor}" stroke-width="2"/>
                        </svg>
                    `);
                    user.spritesByMode['pixel-morphs'] = svgCircle;
                    return {
                        data: svgCircle,
                        colorize: false,
                        color: viewerColor
                    };
                } else if (spriteMode === 'custom') {
                    // Custom mode: use custom sprite (not colorized)
                    if (this.settings.customSpriteData) {
                        return {
                            data: this.settings.customSpriteData,
                            colorize: false
                        };
                    }
                }
                
                // Fallback: ALL modes fall back to colored SVG circles when sprites fail
                console.warn(`[getUserSprite] No sprite found for ${user.username} in mode ${spriteMode}, using circle fallback`);
                const svgCircle = 'data:image/svg+xml;base64,' + btoa(`
                    <svg width="40" height="40" xmlns="http://www.w3.org/2000/svg">
                        <circle cx="20" cy="20" r="18" fill="${viewerColor}" stroke="${viewerColor}" stroke-width="2"/>
                    </svg>
                `);
                if (!user.spritesByMode) user.spritesByMode = {};
                user.spritesByMode[spriteMode] = svgCircle;
                return {
                    data: svgCircle,
                    colorize: false,
                    color: viewerColor
                };
            }

            async init() {
                console.log('Init() called');
                // Always reload sprite data and campfire graphic from localStorage on init
                const defaultSprite = localStorage.getItem('defaultSpriteData');
                const customSprite = localStorage.getItem('customSpriteData');
                const campfireGraphic = localStorage.getItem('campfireGraphicData');
                if (defaultSprite) this.settings.defaultSpriteData = defaultSprite;
                if (customSprite) this.settings.customSpriteData = customSprite;
                if (campfireGraphic) this.settings.campfireGraphicData = campfireGraphic;
                
                // Load sprite collections
                const shadowSprites = localStorage.getItem('shadowSprites');
                const rpgSprites = localStorage.getItem('rpgSprites');
                const morphSprites = localStorage.getItem('morphSprites');
                
                if (shadowSprites) {
                    try {
                        this.settings.shadowSprites = JSON.parse(shadowSprites);
                        if (!Array.isArray(this.settings.shadowSprites)) {
                            this.settings.shadowSprites = [];
                        }
                    } catch (e) {
                        console.error('Error parsing shadowSprites:', e);
                        this.settings.shadowSprites = [];
                    }
                } else {
                    this.settings.shadowSprites = [];
                }
                
                if (rpgSprites) {
                    try {
                        this.settings.rpgSprites = JSON.parse(rpgSprites);
                        if (!Array.isArray(this.settings.rpgSprites)) {
                            this.settings.rpgSprites = [];
                        }
                        console.log(`Loaded ${this.settings.rpgSprites.length} RPG sprites from localStorage`);
                    } catch (e) {
                        console.error('Error parsing rpgSprites:', e);
                        this.settings.rpgSprites = [];
                    }
                } else {
                    console.warn('No RPG sprites found in localStorage');
                    this.settings.rpgSprites = [];
                }
                
                if (morphSprites) {
                    try {
                        this.settings.morphSprites = JSON.parse(morphSprites);
                        if (!Array.isArray(this.settings.morphSprites)) {
                            this.settings.morphSprites = [];
                        }
                    } catch (e) {
                        console.error('Error parsing morphSprites:', e);
                        this.settings.morphSprites = [];
                    }
                } else {
                    this.settings.morphSprites = [];
                }
                
                // Load audio settings
                const audioSettings = localStorage.getItem('audioSettings');
                if (audioSettings) {
                    try {
                        this.settings.audioSettings = JSON.parse(audioSettings);
                        
                        // Load audio files from disk if useFileStorage is set
                        const loadAudioFromDisk = async (audioType) => {
                            if (window.electronAPI && window.electronAPI.loadAudioFile) {
                                try {
                                    const result = await window.electronAPI.loadAudioFile(audioType);
                                    if (result.success) {
                                        if (!this.settings.audioSettings[audioType]) {
                                            this.settings.audioSettings[audioType] = {};
                                        }
                                        this.settings.audioSettings[audioType].fileData = result.fileData;
                                        console.log(`Loaded ${audioType} audio from disk`);
                                        return true;
                                    }
                                } catch (err) {
                                    console.error(`Failed to load ${audioType} audio from disk:`, err);
                                }
                            }
                            return false;
                        };
                        
                        // Check if music/ambience need to be loaded from disk
                        const loadPromises = [];
                        if (this.settings.audioSettings.music?.useFileStorage) {
                            loadPromises.push(loadAudioFromDisk('music'));
                        }
                        if (this.settings.audioSettings.ambience?.useFileStorage) {
                            loadPromises.push(loadAudioFromDisk('ambience'));
                        }
                        
                        // Wait for disk loads to complete, then update audio manager
                        if (loadPromises.length > 0) {
                            Promise.all(loadPromises).then(() => {
                                audioManager.updateSettings(this.settings.audioSettings);
                            });
                        } else {
                            audioManager.updateSettings(this.settings.audioSettings);
                        }
                        
                        console.log('Audio settings loaded');
                    } catch (e) {
                        console.error('Error parsing audioSettings:', e);
                    }
                }
                
                // Load user state settings
                const userStates = localStorage.getItem('userStates');
                if (userStates) {
                    try {
                        this.settings.userStates = JSON.parse(userStates);
                        console.log('User state settings loaded');
                    } catch (e) {
                        console.error('Error parsing userStates:', e);
                    }
                }
                
                // Start user state updates if enabled
                if (this.settings.userStates && this.settings.userStates.enabled) {
                    this.startUserStateUpdates();
                }
                
                console.log('Sprite mode:', this.settings.spriteMode);
                console.log('Sprite collections loaded - RPG:', this.settings.rpgSprites.length, 'Shadows:', this.settings.shadowSprites.length, 'Morph:', this.settings.morphSprites.length);
                
                // Set sprite mode class on container for CSS targeting
                const container = document.getElementById('circleContainer');
                if (container && this.settings.spriteMode) {
                    container.classList.add(`sprite-mode-${this.settings.spriteMode}`);
                }
                
                console.log('Setting up campfire graphic...');
                this.setupCampfireGraphic();
                this.applyCampfireYOffset();
                this.applyNameBubbleOffset();
                this.applyChatBubbleSize();
                this.applyStatusIconPosition();
                this.applyWidgetBackground();
                this.applyNativeFrameMode();
                this.applyHideNameplates();
                console.log('Updating circle transform...');
                this.updateCircleTransform();
                
                // Clear any persisted user data on startup for clean slate
                try {
                    localStorage.removeItem('campfireUsers');
                    localStorage.removeItem('campfireWidgetState');
                    console.log('Cleared persisted user data for clean startup');
                } catch (e) {
                    console.warn('Error clearing persisted user data:', e);
                }

                // Force showTestUsers to false on startup (default: not present)
                if (this.settings.showTestUsers !== false) {
                    this.settings.showTestUsers = false;
                    // Save settings to localStorage
                    try {
                        localStorage.setItem('campfireWidgetSettings', JSON.stringify(this.settings));
                    } catch (e) {
                        console.error('Error saving settings:', e);
                    }
                }
                
                // Only show test users if explicitly enabled (default: false)
                // Test users are only added when "Show Test Users" toggle is ON
                if (this.settings.showTestUsers === true) {
                    console.log('Test users enabled, setting up mock users...');
                    this.setupMockUsers();
                }
                
                // NOTE: simulateJoinForConnectedUsers() is now called from onTwitchConnected handler
                // to ensure Twitch is connected before trying to fetch user data
                
                // Start random movement for ALL users (NPC movement)
                // Users with their dashboard open (activeViewer) won't move - they control their sprite manually
                // When they close their dashboard, activeViewer is cleared and movement automatically resumes
                if (!this._randomMovementStarted) {
                    setTimeout(() => {
                        console.log('Starting random movement for all users...');
                        this.startRandomMovement();
                        this._randomMovementStarted = true;
                    }, 1000); // Start after 1 second to let users load
                }
                
                console.log('Init complete, users:', this.users.length);
            }
            
            savePersistedUsers() {
                // Persistence disabled - users are not saved across app restarts
                // This provides a clean slate each time the app starts
                console.log('User persistence disabled - not saving users to localStorage');
            }
            
            async simulateJoinForConnectedUsers() {
                try {
                    // Get Twitch config with real IDs
                    const config = await this.getTwitchConfig();
                    if (!config) {
                        console.log('[simulateJoinForConnectedUsers] No Twitch config available');
                        return;
                    }
                    
                    const streamerUsername = (config.channelName || '').replace(/^#/, '').toLowerCase();
                    const streamerUserId = config.streamerUserId;
                    const botUsername = (config.chatBotUsername || '').toLowerCase();
                    const botUserId = config.botUserId;
                    
                    // Simulate !join command for streamer - ONLY if we have a real Twitch ID
                    if (streamerUsername && streamerUserId) {
                        console.log(`Simulating !join command for streamer: ${streamerUsername} (ID: ${streamerUserId})`);
                        await this.simulateJoinCommand(streamerUsername, streamerUserId);
                    } else if (streamerUsername) {
                        console.warn(`[simulateJoinForConnectedUsers] Streamer ${streamerUsername} has no real Twitch ID - cannot join`);
                    }
                    
                    // Simulate !join command for bot (if different from streamer) - ONLY if we have a real Twitch ID
                    if (botUsername && botUsername !== streamerUsername && botUserId) {
                        console.log(`Simulating !join command for bot: ${botUsername} (ID: ${botUserId})`);
                        await this.simulateJoinCommand(botUsername, botUserId);
                    } else if (botUsername && botUsername !== streamerUsername) {
                        console.warn(`[simulateJoinForConnectedUsers] Bot ${botUsername} has no real Twitch ID - cannot join`);
                    }
                } catch (e) {
                    console.error('Error simulating join commands for connected users:', e);
                }
            }
            
            async getTwitchConfig() {
                try {
                    if (window.electronAPI && window.electronAPI.getTwitchConfig) {
                        return await window.electronAPI.getTwitchConfig();
                    }
                } catch (e) {
                    console.warn('Error getting Twitch config:', e);
                }
                return null;
            }
            
            async simulateJoinCommand(username, userId) {
                try {
                    // Call the main process to simulate a !join command
                    if (window.electronAPI && window.electronAPI.simulateJoinCommand) {
                        const result = await window.electronAPI.simulateJoinCommand(username, userId);
                        if (result && result.success) {
                            console.log(`[simulateJoinCommand] Successfully simulated !join for ${username}`);
                        } else {
                            console.warn(`[simulateJoinCommand] Failed to simulate !join for ${username}:`, result);
                        }
                    } else {
                        console.warn(`[simulateJoinCommand] electronAPI.simulateJoinCommand not available`);
                    }
                } catch (e) {
                    console.error(`[simulateJoinCommand] Error simulating !join for ${username}:`, e);
                }
            }

            async getStreamerUsername() {
                // Try to get streamer username from various sources
                try {
                    // From electron API (desktop app)
                    if (window.electronAPI && window.electronAPI.getTwitchConfig) {
                        const config = await window.electronAPI.getTwitchConfig();
                        if (config && config.channelName) {
                            return config.channelName.replace(/^#/, '').toLowerCase();
                        }
                    }

                    // From localStorage (fallback for web version)
                    const twitchConfig = localStorage.getItem('twitchConfig');
                    if (twitchConfig) {
                        const config = JSON.parse(twitchConfig);
                        if (config.channelName) {
                            return config.channelName.replace(/^#/, '').toLowerCase();
                        }
                    }

                    // From URL parameters (for custom widget)
                    const urlParams = new URLSearchParams(window.location.search);
                    if (urlParams.has('channel')) {
                        return urlParams.get('channel').replace(/^#/, '').toLowerCase();
                    }
                } catch (e) {
                    console.warn('Error getting streamer username:', e);
                }

                return null;
            }

            async getBotUsername() {
                // Try to get bot username from various sources
                try {
                    // From electron API (desktop app)
                    if (window.electronAPI && window.electronAPI.getTwitchConfig) {
                        const config = await window.electronAPI.getTwitchConfig();
                        if (config && config.chatBotUsername) {
                            return config.chatBotUsername.toLowerCase();
                        }
                    }

                    // From localStorage (fallback for web version)
                    const twitchConfig = localStorage.getItem('twitchConfig');
                    if (twitchConfig) {
                        const config = JSON.parse(twitchConfig);
                        if (config.botUsername) {
                            return config.botUsername.toLowerCase();
                        }
                    }
                } catch (e) {
                    console.warn('Error getting bot username:', e);
                }

                return null;
            }

            setupCampfireGraphic() {
                console.log('setupCampfireGraphic() called');
                const container = document.getElementById('campfireGraphic');
                if (!container) {
                    console.error('Campfire graphic container not found!');
                    return;
                }
                
                // Check if campfire graphic should be hidden
                if (this.settings.hideCampfireGraphic) {
                    container.style.display = 'none';
                    console.log('Campfire graphic hidden by user setting');
                    return;
                } else {
                    container.style.display = '';
                }
                
                console.log('Container found:', container);
                console.log('Container display:', window.getComputedStyle(container).display);
                console.log('Container visibility:', window.getComputedStyle(container).visibility);
                console.log('Container opacity:', window.getComputedStyle(container).opacity);
                
                // Check for uploaded graphic first, then URL
                const uploadedData = this.settings.campfireGraphicData || localStorage.getItem('campfireGraphicData');
                const url = this.settings.campfireGraphicUrl;
                const graphicSource = uploadedData || url;
                
                console.log('Graphic source:', uploadedData ? 'uploaded' : (url ? 'URL' : 'none (using default)'));
                
                // Calculate perspective transform for glow
                // Cap glow angle at 77 degrees to prevent it from getting too thin
                // User orbit can go to 90, but glow visual stops at 77
                const glowAngle = Math.min(this.circleAngle, 77);
                const angleRad = (glowAngle * Math.PI) / 180;
                const scaleY = Math.cos(angleRad);
                
                if (!graphicSource) {
                    // Get glow settings
                    const glowSize = this.settings.glowSize || 500;
                    const glowIntensity = this.settings.glowIntensity || 77;
                    const shadowIntensity = this.settings.shadowIntensity || 91;
                    const glowSpread = this.settings.glowSpread || 64;
                    const animatedGlow = this.settings.animatedGlow !== false; // Default to true
                    // Flicker glow (front-of-campfire layer)
                    const flickerSize = (this.settings.flickerSize || glowSize);
                    const flickerOpacity = this.settings.flickerOpacity || 25; // 0-100
                    const flickerSpread = this.settings.flickerSpread || 55; // 20-100
                    
                    // Calculate opacity values based on intensity (0-100% maps to 0-0.5 opacity)
                    const baseOpacity = (glowIntensity / 100) * 0.5;
                    const shadowOpacity = (shadowIntensity / 100);
                    
                    // Calculate gradient stops based on spread
                    const stop1 = Math.max(0, glowSpread * 0.25);
                    const stop2 = Math.max(5, glowSpread * 0.4);
                    const stop3 = Math.max(10, glowSpread * 0.55);
                    const stop4 = Math.max(15, glowSpread * 0.7);
                    const stop5 = Math.max(20, glowSpread * 0.85);
                    
                    // Build glow gradient with dynamic stops
                    const glowGradient = `radial-gradient(ellipse at center, 
                        rgba(255, 107, 53, ${baseOpacity}) 0%, 
                        rgba(247, 147, 30, ${baseOpacity * 0.7}) ${stop1}%, 
                        rgba(255, 204, 2, ${baseOpacity * 0.5}) ${stop2}%, 
                        rgba(255, 204, 2, ${baseOpacity * 0.3}) ${stop3}%, 
                        rgba(255, 204, 2, ${baseOpacity * 0.15}) ${stop4}%, 
                        transparent ${glowSpread}%)`;

                    // Flicker gradient (front layer)
                    const flickerBaseOpacity = Math.max(0, Math.min(1, (flickerOpacity / 100) * 0.6));
                    const f1 = Math.max(0, flickerSpread * 0.25);
                    const f2 = Math.max(5, flickerSpread * 0.45);
                    const flickerGradient = `radial-gradient(ellipse at center,
                        rgba(255, 255, 255, ${flickerBaseOpacity * 0.15}) 0%,
                        rgba(255, 204, 2, ${flickerBaseOpacity * 0.7}) ${f1}%,
                        rgba(255, 107, 53, ${flickerBaseOpacity * 0.35}) ${f2}%,
                        transparent ${flickerSpread}%)`;
                    
                    // Default placeholder with natural transparent glow (no borders, follows angle)
                    console.log('Creating default campfire glow...');
                    container.innerHTML = `
                        <div id="campfireGlow" style="position: absolute; width: ${glowSize}px; height: ${glowSize}px; left: 50%; top: 50%; transform: translate(-50%, -50%) scaleY(${scaleY}); 
                                    background: ${glowGradient}; 
                                    pointer-events: none; border: none; outline: none; box-shadow: none; transition: background 0.3s ease;">
                        </div>
                        <div id="campfireFlicker" style="position: absolute; width: ${flickerSize}px; height: ${flickerSize}px; left: 50%; top: 50%; transform: translate(-50%, -50%) scaleY(${scaleY});
                                    background: ${flickerGradient};
                                    pointer-events: none; border: none; outline: none; box-shadow: none; transition: background 0.3s ease; z-index: 12;">
                        </div>
                        <div id="campfireEmoji" style="position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); z-index: 11; font-size: ${this.settings.fireSize || 48}px; filter: none; pointer-events: none;">üî•</div>
                    `;
                    console.log('Campfire graphic HTML set, container.innerHTML length:', container.innerHTML.length);
                    
                    // Start animation if enabled
                    if (animatedGlow) {
                        this.startGlowAnimation();
                    }
                    
                    return;
                }

                // Get glow settings (always create glow, even for custom graphics)
                const glowSize = this.settings.glowSize || 500;
                const glowIntensity = this.settings.glowIntensity || 77;
                const shadowIntensity = this.settings.shadowIntensity || 91;
                const glowSpread = this.settings.glowSpread || 64;
                const animatedGlow = this.settings.animatedGlow !== false; // Default to true
                // Flicker glow (front-of-campfire layer)
                const flickerSize = (this.settings.flickerSize || glowSize);
                const flickerOpacity = this.settings.flickerOpacity || 25; // 0-100
                const flickerSpread = this.settings.flickerSpread || 55; // 20-100
                
                // Calculate opacity values based on intensity (0-100% maps to 0-0.5 opacity)
                const baseOpacity = (glowIntensity / 100) * 0.5;
                const shadowOpacity = (shadowIntensity / 100);
                
                // Calculate gradient stops based on spread
                const stop1 = Math.max(0, glowSpread * 0.25);
                const stop2 = Math.max(5, glowSpread * 0.4);
                const stop3 = Math.max(10, glowSpread * 0.55);
                const stop4 = Math.max(15, glowSpread * 0.7);
                const stop5 = Math.max(20, glowSpread * 0.85);
                
                // Build glow gradient with dynamic stops
                const glowGradient = `radial-gradient(ellipse at center, 
                    rgba(255, 107, 53, ${baseOpacity}) 0%, 
                    rgba(247, 147, 30, ${baseOpacity * 0.7}) ${stop1}%, 
                    rgba(255, 204, 2, ${baseOpacity * 0.5}) ${stop2}%, 
                    rgba(255, 204, 2, ${baseOpacity * 0.3}) ${stop3}%, 
                    rgba(255, 204, 2, ${baseOpacity * 0.15}) ${stop4}%, 
                    transparent ${glowSpread}%)`;

                // Flicker gradient (sits in front of the campfire image)
                const flickerBaseOpacity = Math.max(0, Math.min(1, (flickerOpacity / 100) * 0.6));
                const f1 = Math.max(0, flickerSpread * 0.25);
                const f2 = Math.max(5, flickerSpread * 0.45);
                const flickerGradient = `radial-gradient(ellipse at center,
                    rgba(255, 255, 255, ${flickerBaseOpacity * 0.15}) 0%,
                    rgba(255, 204, 2, ${flickerBaseOpacity * 0.7}) ${f1}%,
                    rgba(255, 107, 53, ${flickerBaseOpacity * 0.35}) ${f2}%,
                    transparent ${flickerSpread}%)`;
                
                // Use uploaded data if available, otherwise use URL
                const fireSize = this.settings.fireSize || 48;
                let graphicHTML = '';
                
                // Always create glow element first (behind the graphic)
                graphicHTML = `<div id="campfireGlow" style="position: absolute; width: ${glowSize}px; height: ${glowSize}px; left: 50%; top: 50%; transform: translate(-50%, -50%) scaleY(${scaleY}); 
                            background: ${glowGradient}; 
                            pointer-events: none; border: none; outline: none; box-shadow: none; transition: background 0.3s ease; z-index: 10;">
                        </div>`;
                
                if (uploadedData) {
                    // Check if it's a video or image based on data URL
                    if (uploadedData.startsWith('data:video/')) {
                        graphicHTML += `<video autoplay loop muted playsinline style="width: ${fireSize}px; height: ${fireSize}px; object-fit: contain; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); z-index: 11; filter: none;"><source src="${uploadedData}"></video>`;
                    } else {
                        graphicHTML += `<img src="${uploadedData}" alt="Campfire" style="width: ${fireSize}px; height: ${fireSize}px; object-fit: contain; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); z-index: 11; filter: none;">`;
                    }
                } else if (url) {
                    // Check if it's a video or image
                    const extension = url.split('.').pop().toLowerCase();
                    if (['mp4', 'webm', 'mov'].includes(extension)) {
                        graphicHTML += `<video autoplay loop muted playsinline style="width: ${fireSize}px; height: ${fireSize}px; object-fit: contain; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); z-index: 11; filter: none;"><source src="${url}" type="video/${extension}"></video>`;
                    } else {
                        graphicHTML += `<img src="${url}" alt="Campfire" style="width: ${fireSize}px; height: ${fireSize}px; object-fit: contain; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); z-index: 11; filter: none;">`;
                    }
                }

                // Front-of-campfire flicker layer (above the campfire image)
                graphicHTML += `<div id="campfireFlicker" style="position: absolute; width: ${flickerSize}px; height: ${flickerSize}px; left: 50%; top: 50%; transform: translate(-50%, -50%) scaleY(${scaleY});
                            background: ${flickerGradient};
                            pointer-events: none; border: none; outline: none; box-shadow: none; transition: background 0.3s ease; z-index: 12;">
                        </div>`;
                
                container.innerHTML = graphicHTML;
                console.log('Campfire graphic HTML set, length:', graphicHTML.length);
                console.log('Container innerHTML after set:', container.innerHTML.substring(0, 200));
                
                // Verify elements were created
                const glow = document.getElementById('campfireGlow');
                const flicker = document.getElementById('campfireFlicker');
                const emoji = document.getElementById('campfireEmoji');
                console.log('Campfire glow element:', glow ? 'found' : 'NOT FOUND');
                console.log('Campfire flicker element:', flicker ? 'found' : 'NOT FOUND');
                console.log('Campfire emoji element:', emoji ? 'found' : 'NOT FOUND');
                
                // Start animation if enabled
                if (animatedGlow) {
                    this.startGlowAnimation();
                }
            }

            applyCampfireYOffset() {
                const el = document.getElementById('campfireGraphic');
                if (!el) return;
                const v = parseInt(this.settings.campfireYOffset ?? 50, 10);
                // Map 0‚Äì100 ‚Üí -200px..+200px (50 = 0px)
                const px = (v - 50) * 4;
                el.style.setProperty('--campfire-y-offset', `${px}px`);
            }

            applyNameBubbleOffset() {
                // Use per-sprite-mode offset if available, otherwise fall back to global setting
                const spriteMode = this.settings.spriteMode || 'circles';
                const nameBubbleOffsets = this.settings.nameBubbleOffsets || {};

                let v;
                if (nameBubbleOffsets[spriteMode] !== undefined) {
                    // Use per-sprite-mode setting
                    v = nameBubbleOffsets[spriteMode];
                } else if (this.settings.nameBubbleOffset !== undefined) {
                    // Use global setting
                    v = this.settings.nameBubbleOffset;
                } else {
                    // Use mode-specific defaults
                    if (spriteMode === 'rpg-characters') {
                        v = -35; // RPG sprites need lower position (below sprite)
                    } else {
                        v = 25; // Other sprites use position above
                    }
                }

                document.documentElement.style.setProperty('--name-bubble-offset', `${-v}px`);
            }

            applyChatBubbleSize() {
                // Use per-sprite-mode size if available, otherwise fall back to global setting
                const spriteMode = this.settings.spriteMode || 'circles';
                const chatBubbleSizes = this.settings.chatBubbleSizes || {};
                const v = chatBubbleSizes[spriteMode] !== undefined ? chatBubbleSizes[spriteMode] : (this.settings.chatBubbleSize ?? 11);
                document.documentElement.style.setProperty('--chat-bubble-font-size', `${v}px`);
            }
            
            applyStatusIconPosition() {
                // Apply status icon position from settings
                const topValue = this.settings.statusIconTop || 0;
                const rightValue = this.settings.statusIconRight || 0;
                document.documentElement.style.setProperty('--status-icon-top', `${topValue}px`);
                document.documentElement.style.setProperty('--status-icon-right', `${rightValue}px`);
            }

            applyWidgetBackground() {
                const choice = String(this.settings.widgetBackground || 'black').toLowerCase();
                let bg = 'transparent';
                if (choice === 'black') bg = '#000000';
                else if (choice === 'white') bg = '#ffffff';
                else if (choice === 'green') bg = '#00ff00'; // chroma key green

                // Force background at the document level (base CSS sets transparent).
                try { document.documentElement.style.setProperty('background', bg, 'important'); } catch (e) {}
                try { document.body.style.setProperty('background', bg, 'important'); } catch (e) {}
            }

            applyNativeFrameMode() {
                const useNativeFrame = this.settings.useNativeFrame !== false;
                const isWindows = /Windows/i.test(navigator.userAgent || '');
                const wantsTransparent = String(this.settings.widgetBackground || 'black').toLowerCase() === 'transparent';
                // On Windows we force frameless when using a transparent window (stability).
                const effectiveFrameless = (!useNativeFrame) || (isWindows && wantsTransparent);
                // When frameless, enable drag region on the in-widget menu bar (see CSS `body.frameless`).
                try { document.body.classList.toggle('frameless', effectiveFrameless); } catch (e) {}
            }

            applyHideNameplates() {
                const hide = this.settings.hideNameplates === true;
                try { document.body.classList.toggle('hide-nameplates', hide); } catch (e) {}
            }

            updateCircleTransform() {
                // Hide debug circle (no longer needed)
                const debugCircle = document.getElementById('debugCircle');
                if (debugCircle) {
                    debugCircle.style.display = 'none';
                }
                
                // Calculate perspective transform for glow
                // Cap glow angle at 77 degrees to prevent it from getting too thin
                // User orbit can go to 90, but glow visual stops at 77
                const glowAngle = Math.min(this.circleAngle, 77);
                const angleRad = (glowAngle * Math.PI) / 180;
                const scaleY = Math.cos(angleRad);
                
                // Update campfire glow to match angle perspective
                const glow = document.getElementById('campfireGlow');
                if (glow) {
                    glow.style.transform = `translate(-50%, -50%) scaleY(${scaleY})`;
                }
                
                // Reposition all users (perspective is applied in positionUserElement)
                this.repositionUsers();
            }

            addUser(username, userData = {}) {
                // Normalize username for case-insensitive comparison (Twitch usernames are case-insensitive)
                const normalizedUsername = username ? username.toLowerCase() : '';
                const normalizedUserId = userData.userId ? String(userData.userId).toLowerCase() : '';
                
                // Check if user already exists - if so, just update their data
                // Use case-insensitive comparison for usernames
                const existingUser = this.users.find(u => {
                    const uNameLower = u.username ? u.username.toLowerCase() : '';
                    const uIdLower = u.userId ? String(u.userId).toLowerCase() : '';
                    
                    // Match by username (case-insensitive)
                    if (normalizedUsername && uNameLower === normalizedUsername) return true;
                    // Match by userId (case-insensitive)
                    if (normalizedUserId && uIdLower === normalizedUserId) return true;
                    // Match by userId to username (some systems use username as userId)
                    if (normalizedUserId && uNameLower === normalizedUserId) return true;
                    if (normalizedUsername && uIdLower === normalizedUsername) return true;
                    
                    return false;
                });
                
                if (existingUser) {
                    // Update existing user - preserve original username casing but update other data
                    const wasAfkOrLurk = existingUser.state === 'afk' || existingUser.state === 'lurk' || existingUser.outerRing;
                    Object.assign(existingUser, userData);
                    // Keep the original username if it exists, otherwise use the new one
                    if (!existingUser.username && username) {
                        existingUser.username = username;
                    }
                    
                    // If user was AFK/LURK and is rejoining, transition them to JOINED state
                    if (wasAfkOrLurk && this.settings.userStates && this.settings.userStates.enabled) {
                        const element = document.getElementById(existingUser.id);
                        if (element) {
                            const oldState = existingUser.state;
                            existingUser.state = 'joined';
                            existingUser.manualAfk = false;
                            existingUser.outerRing = false;
                            existingUser.lastActivity = Date.now();
                            
                            element.classList.remove('state-afk', 'state-lurk', 'state-sleepy', 'outer-ring');
                            element.classList.add('state-joined');
                            
                            this.updateStateIndicator(element, oldState, 'joined');
                            this.updateUserRingPosition(existingUser, element, 'joined');
                            
                            // Transition to active after joined animation
                            setTimeout(() => {
                                if (existingUser.state === 'joined') {
                                    existingUser.state = 'active';
                                    element.classList.remove('state-joined');
                                    element.classList.add('state-active');
                                }
                            }, 4500);
                            
                            console.log(`[addUser] Returned existing user from AFK/LURK: ${existingUser.username}`);
                        }
                    }
                    
                    this.updateUserElement(existingUser);
                    console.log(`[addUser] Updated existing user: ${existingUser.username} (userId: ${existingUser.userId})`);
                    
                    // Play join sound for returning users
                    if (wasAfkOrLurk) {
                        audioManager.playSound('join');
                    }
                    return;
                }

                // Check max users - only remove oldest active user (NOT AFK users)
                // AFK users should only be removed by auto-leave timer, not to make room
                if (this.users.length >= this.maxUsers) {
                    // Find oldest active (non-AFK, non-LURK) user to remove
                    const activeUsers = this.users.filter(u => u.state !== 'afk' && u.state !== 'lurk' && !u.outerRing);
                    if (activeUsers.length > 0) {
                        // Remove oldest active user
                        const oldest = activeUsers[0];
                        const oldestIndex = this.users.indexOf(oldest);
                        if (oldestIndex !== -1) {
                            this.users.splice(oldestIndex, 1);
                            this.removeUserElement(oldest.id);
                            console.log(`[addUser] Removed oldest active user ${oldest.username} to make room for new user`);
                        }
                    } else {
                        // All users are AFK/LURK - don't remove anyone, just log
                        console.log(`[addUser] Max users reached but all are AFK/LURK - not removing anyone`);
                        return; // Don't add new user if we can't make room
                    }
                }

                const user = {
                    id: `user-${Date.now()}-${Math.random()}`,
                    username: username,
                    angle: userData.angle !== undefined ? userData.angle : this.calculateNextAngle(),
                    userId: userData.userId || null,
                    ...userData
                };

                this.users.push(user);
                this.createUserElement(user);
                // Note: User persistence disabled - not saving to localStorage
                
                // Play join sound
                audioManager.playSound('join');
            }

            moveUser(username, direction, speed = 15) {
                // Try to find user by username or displayName (case-insensitive)
                const normalizedUsername = username ? username.toLowerCase() : '';
                const user = this.users.find(u => {
                    const uNameLower = u.username ? u.username.toLowerCase() : '';
                    const uDisplayLower = u.displayName ? u.displayName.toLowerCase() : '';
                    if (uNameLower === normalizedUsername || uDisplayLower === normalizedUsername) return true;
                    if (u.userId && localStorage.getItem('activeViewer')) {
                        try {
                            const activeViewer = JSON.parse(localStorage.getItem('activeViewer'));
                            return activeViewer && activeViewer.userId === u.userId;
                        } catch (e) {
                            return false;
                        }
                    }
                    return false;
                });
                
                if (!user) {
                    console.log('User not found for movement:', username);
                    return;
                }
                
                // If user is "still" (movement disabled), break STILL mode and transition to WANDER
                if (user.still) {
                    user.still = false;
                    user.lastActivity = Date.now();
                    
                    // If user was sleepy/afk, transition to active (wandering)
                    if (user.state === 'sleepy' || user.state === 'afk') {
                        const oldState = user.state;
                        user.state = 'active';
                        user.manualAfk = false;
                        
                        // Update visual classes
                        const element = document.getElementById(user.id);
                        if (element) {
                            element.classList.remove('state-sleepy', 'state-afk', 'still', 'outer-ring');
                            element.classList.add('state-active');
                        }
                        
                        // Move back to inner circle if they were on outer ring
                        if (user.ring === 'outer') {
                            user.ring = 'inner';
                        }
                        
                        console.log(`[moveUser] User ${user.username} broke STILL mode: ${oldState} ‚Üí active (roaming)`);
                    }
                }

                // Calculate if user is in front or behind fire based on perspective
                // Users in front (bottom half) need reversed controls for intuitive movement
                const angleRad = (user.angle * Math.PI) / 180;
                const baseY = Math.sin(angleRad) * this.circleRadius;
                const angleRadTransform = (this.circleAngle * Math.PI) / 180;
                const perspectiveY = baseY * Math.cos(angleRadTransform);
                
                // Determine if user is in front of fire (positive Y = bottom half = front)
                const isInFront = perspectiveY > 0;
                
                // Simple approach: flip direction when in front so RIGHT always moves right visually
                // If in front: flip direction (so RIGHT visually moves right)
                const effectiveDirection = isInFront ? -direction : direction;

                // Move user around circle using effective direction
                const angleStep = speed;
                user.angle += effectiveDirection * angleStep;
                
                // Normalize angle to 0-360
                if (user.angle < 0) user.angle += 360;
                if (user.angle >= 360) user.angle -= 360;

                // Flip sprite horizontally based on visual movement direction
                // Calculate visual direction: what direction is the sprite actually moving on screen?
                // When in front: effectiveDirection is flipped, so we need to check the actual screen movement
                // We can determine this by checking if angle is increasing or decreasing
                // For sprite flip: right movement = flip, left movement = normal
                const angleChange = effectiveDirection * angleStep;
                // If angle is increasing (positive change), sprite moves clockwise (right when behind, left when in front)
                // If angle is decreasing (negative change), sprite moves counter-clockwise (left when behind, right when in front)
                // For visual: when in front, counter-clockwise = right visually, clockwise = left visually
                const visualMovingRight = isInFront ? (angleChange < 0) : (angleChange > 0);
                this.flipSprite(user.id, visualMovingRight ? 1 : -1);

                // Set moving animation
                this.setUserMoving(user.id, true);
                
                // Reposition user
                this.positionUserElement(user);
            }

            // Smoothly move a user to a specific absolute angle (used for !cw / !ccw so movement is exact + consistent).
            moveUserToAngle(username, targetAngle, opts = {}) {
                const target = Number(targetAngle);
                if (!Number.isFinite(target)) return;

                const userIdHint = opts && opts.userId ? String(opts.userId).toLowerCase() : null;
                const normalizedUsername = username ? username.toLowerCase() : '';
                const user = this.users.find(u => {
                    const uIdLower = u.userId ? String(u.userId).toLowerCase() : '';
                    const uNameLower = u.username ? u.username.toLowerCase() : '';
                    const uDisplayLower = u.displayName ? u.displayName.toLowerCase() : '';
                    if (userIdHint && uIdLower === userIdHint) return true;
                    if (uNameLower === normalizedUsername || uDisplayLower === normalizedUsername) return true;
                    return false;
                });
                if (!user) return;
                
                // If user is "still" (movement disabled), break STILL mode and transition to WANDER
                if (user.still) {
                    user.still = false;
                    user.lastActivity = Date.now();
                    
                    // If user was sleepy/afk, transition to active (roaming)
                    if (user.state === 'sleepy' || user.state === 'afk') {
                        const oldState = user.state;
                        user.state = 'active';
                        user.manualAfk = false;
                        
                        // Update visual classes
                        const element = document.getElementById(user.id);
                        if (element) {
                            element.classList.remove('state-sleepy', 'state-afk', 'still', 'outer-ring');
                            element.classList.add('state-active');
                        }
                        
                        // Move back to inner circle if they were on outer ring
                        if (user.ring === 'outer') {
                            user.ring = 'inner';
                        }
                        
                        console.log(`[moveUserToAngle] User ${user.username} broke STILL mode: ${oldState} ‚Üí active (roaming)`);
                    }
                }

                const direction = (opts && typeof opts.direction === 'number') ? opts.direction : null;
                const degrees = (opts && typeof opts.degrees === 'number') ? Math.max(0, Math.min(360, opts.degrees)) : null;

                // Cancel any in-flight angle animation for this user
                if (!this._angleMoveAnimations) this._angleMoveAnimations = new Map();
                const prev = this._angleMoveAnimations.get(user.id);
                if (prev && prev.rafId) {
                    try { cancelAnimationFrame(prev.rafId); } catch (e) { /* ignore */ }
                }

                const startAngle = Number.isFinite(user.angle) ? user.angle : 0;
                const normalizedTarget = ((target % 360) + 360) % 360;

                // Prefer explicit delta from main (exact command), otherwise use shortest path fallback.
                let signedDelta = 0;
                let dir = direction;
                if (degrees !== null && dir !== null) {
                    signedDelta = dir * degrees;
                } else {
                    const diff = ((((normalizedTarget - startAngle) % 360) + 540) % 360) - 180; // -180..180
                    signedDelta = diff;
                    dir = diff === 0 ? 1 : (diff > 0 ? 1 : -1);
                }

                const deltaAbs = Math.abs(signedDelta);
                const durationMs = Math.min(5000, Math.max(250, (deltaAbs / 60) * 1000)); // ~60¬∞/sec
                const startTime = performance.now();

                // Begin moving animation
                this.setUserMoving(user.id, true);

                const easeOutCubic = (t) => 1 - Math.pow(1 - t, 3);

                const tick = (now) => {
                    const t = Math.min(1, Math.max(0, (now - startTime) / durationMs));
                    const eased = easeOutCubic(t);
                    const a = startAngle + (signedDelta * eased);
                    const newAngle = ((a % 360) + 360) % 360;
                    user.angle = newAngle;

                    // Flip sprite based on visual direction (similar to moveUser(), but keep cw/ccw absolute)
                    const angleRad = (newAngle * Math.PI) / 180;
                    const baseY = Math.sin(angleRad) * this.circleRadius;
                    const angleRadTransform = (this.circleAngle * Math.PI) / 180;
                    const perspectiveY = baseY * Math.cos(angleRadTransform);
                    const isInFront = perspectiveY > 0;
                    const visualMovingRight = isInFront ? (dir < 0) : (dir > 0);
                    this.flipSprite(user.id, visualMovingRight ? 1 : -1);

                    this.positionUserElement(user);

                    if (t < 1) {
                        const rafId = requestAnimationFrame(tick);
                        this._angleMoveAnimations.set(user.id, { rafId });
                    } else {
                        this._angleMoveAnimations.delete(user.id);
                        this.setUserMoving(user.id, false);
                        user.angle = normalizedTarget; // snap exact at end
                        this.positionUserElement(user);
                    }
                };

                const rafId = requestAnimationFrame(tick);
                this._angleMoveAnimations.set(user.id, { rafId });
            }
            
            flipSprite(userId, direction) {
                // Flip sprite horizontally based on movement direction and default sprite direction
                const element = document.getElementById(userId);
                if (!element) return;
                
                const shape = element.querySelector('.shape');
                if (!shape) return;
                
                // Get sprite default direction for current mode (defaults to 'left' if not set)
                const currentMode = this.settings.spriteMode || 'circles';
                const defaultDirection = (this.settings.spriteDefaultDirections && this.settings.spriteDefaultDirections[currentMode])
                    || this.settings.spriteDefaultDirection // Legacy fallback
                    || 'left';
                
                // Determine if sprite should be flipped
                // direction: 1 = moving right, -1 = moving left
                // If default is LEFT:
                //   - Moving LEFT (-1) = normal (not flipped)
                //   - Moving RIGHT (1) = flipped
                // If default is RIGHT:
                //   - Moving LEFT (-1) = flipped
                //   - Moving RIGHT (1) = normal (not flipped)
                
                let shouldFlip = false;
                if (defaultDirection === 'left') {
                    // Sprite faces left by default, so flip when moving right
                    shouldFlip = (direction === 1);
                } else {
                    // Sprite faces right by default, so flip when moving left
                    shouldFlip = (direction === -1);
                }
                
                // Update flipped class for CSS (for backwards compatibility)
                if (shouldFlip) {
                    shape.classList.add('flipped');
                } else {
                    shape.classList.remove('flipped');
                }
                
                // Recalculate transform with perspective scaling (if positionUserElement was already called)
                // Get the current transform to preserve perspective scaling
                const currentTransform = shape.style.transform;
                if (currentTransform && currentTransform.includes('scaleY')) {
                    // Extract the scaleY value from current transform
                    const scaleYMatch = currentTransform.match(/scaleY\(([^)]+)\)/);
                    if (scaleYMatch) {
                        const scaleYValue = scaleYMatch[1];
                        const flipDirection = shouldFlip ? -1 : 1;
                        // Reapply transform with updated flip direction
                        const scaleXMatch = currentTransform.match(/scaleX\(([^)]+)\)/);
                        if (scaleXMatch) {
                            // Extract scaleX value (without flip direction)
                            const scaleXValue = parseFloat(scaleXMatch[1]);
                            const baseScale = Math.abs(scaleXValue);
                            shape.style.transform = `scaleX(${flipDirection * baseScale}) scaleY(${scaleYValue})`;
                        } else {
                            // No scaleX yet, use scaleY value for both
                            shape.style.transform = `scaleX(${flipDirection * parseFloat(scaleYValue)}) scaleY(${scaleYValue})`;
                        }
                    }
                } else {
                    // If no perspective scaling yet, just apply flip (perspective will be added in positionUserElement)
                    // This is handled by the CSS class, so we don't need to do anything here
                }
            }

            stopUserMovement(userId) {
                // Stop movement animation when key is released
                this.setUserMoving(userId, false);
            }

            buildMessageWithEmotes(message, emotes) {
                const esc = (s) => {
                    if (s == null) return '';
                    return String(s).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
                };
                const escAttr = (s) => {
                    if (s == null) return '';
                    return String(s)
                        .replace(/&/g, '&amp;')
                        .replace(/</g, '&lt;')
                        .replace(/>/g, '&gt;')
                        .replace(/"/g, '&quot;')
                        .replace(/'/g, '&#39;');
                };
                const third = (window.__thirdPartyEmotes && typeof window.__thirdPartyEmotes === 'object') ? window.__thirdPartyEmotes : {};
                const renderTextWithThirdParty = (text) => {
                    if (!text) return '';
                    // Split by whitespace but keep delimiters so spacing is preserved
                    return String(text).split(/(\s+)/).map(part => {
                        if (!part) return '';
                        if (/^\s+$/.test(part)) return esc(part);
                        // Allow common punctuation around emote codes
                        const m = part.match(/^([(\[{<"']*)(.*?)([)\]}>,"'.!?;:]*)$/);
                        const pre = m ? m[1] : '';
                        const core = m ? m[2] : part;
                        const post = m ? m[3] : '';
                        const url = core && third[core];
                        if (url && typeof url === 'string' && /^https?:\/\//.test(url)) {
                            return `${esc(pre)}<img src="${escAttr(url)}" alt="${escAttr(core)}" class="chat-emote chat-emote-third">${esc(post)}`;
                        }
                        return esc(part);
                    }).join('');
                };
                if (!message) return '';
                if (!emotes) return renderTextWithThirdParty(message);
                const list = [];
                if (typeof emotes === 'string' && emotes) {
                    emotes.split('/').forEach(part => {
                        const i = part.indexOf(':');
                        if (i <= 0) return;
                        const id = part.slice(0, i);
                        if (!/^\d+$/.test(id)) return;
                        part.slice(i + 1).split(',').forEach(r => {
                            const [a, b] = r.split('-').map(Number);
                            if (!isNaN(a) && !isNaN(b)) list.push({ id, start: a, end: b });
                        });
                    });
                } else if (emotes && typeof emotes === 'object') {
                    Object.keys(emotes).forEach(id => {
                        if (!/^\d+$/.test(String(id))) return;
                        const arr = Array.isArray(emotes[id]) ? emotes[id] : [emotes[id]];
                        (arr || []).forEach(r => {
                            const [a, b] = String(r).split('-').map(Number);
                            if (!isNaN(a) && !isNaN(b)) list.push({ id: String(id), start: a, end: b });
                        });
                    });
                }
                if (list.length === 0) return renderTextWithThirdParty(message);
                list.sort((a, b) => a.start - b.start);
                const segs = [];
                let pos = 0;
                for (const { id, start, end } of list) {
                    if (start > pos) segs.push({ t: 'text', v: message.slice(pos, start) });
                    segs.push({ t: 'emote', id });
                    pos = end + 1;
                }
                if (pos < message.length) segs.push({ t: 'text', v: message.slice(pos) });
                
                // Use animated emote URL (falls back to static automatically if no animated version exists)
                // Format: https://static-cdn.jtvnw.net/emoticons/v2/{id}/{format}/dark/{scale}
                // format: 'animated' for GIF, 'static' for PNG
                // scale: 1.0, 2.0, or 3.0
                const animatedUrl = (id) => `https://static-cdn.jtvnw.net/emoticons/v2/${id}/animated/dark/2.0`;
                const staticUrl = (id) => `https://static-cdn.jtvnw.net/emoticons/v2/${id}/static/dark/2.0`;
                
                // Use animated URL with static fallback via onerror
                return segs.map(s => {
                    if (s.t === 'text') return renderTextWithThirdParty(s.v);
                    const aUrl = animatedUrl(s.id);
                    const sUrl = staticUrl(s.id);
                    // Try animated first, fall back to static on error
                    return `<img src="${aUrl}" onerror="this.onerror=null;this.src='${sUrl}';" alt="" class="chat-emote">`;
                }).join('');
            }

            showChatMessage(username, message, userId = null, emotes = null, allowBubble = true, isAction = false) {
                const u = username ? String(username).toLowerCase() : '';
                const uid = userId ? String(userId).toLowerCase() : '';
                const user = this.users.find(uu =>
                    (uid && uu.userId && String(uu.userId).toLowerCase() === uid) ||
                    (u && (uu.username || '').toLowerCase() === u)
                );
                if (!user) return;
                if (user.muted) return;
                if (this.settings.muteChatBubbles === true && !allowBubble) return;

                const element = document.getElementById(user.id);
                if (!element) return;
                
                // Update user activity for state tracking
                user.lastActivity = Date.now();
                if (this.settings.userStates && this.settings.userStates.enabled) {
                    // Clear manual AFK when user chats (but NOT lurk - lurk requires join command)
                    if (user.state === 'afk' || user.state === 'sleepy') {
                        const oldState = user.state;
                        user.state = 'active';
                        user.manualAfk = false;
                        user.persisted = false; // Clear persisted flag when user becomes active
                        element.classList.remove('state-joined', 'state-sleepy', 'state-afk', 'state-lurk', 'outer-ring', 'was-sleepy');
                        element.classList.add('state-active');
                        
                        // Remove indicators and move back to inner ring
                        this.updateStateIndicator(element, oldState, 'active');
                        this.updateUserRingPosition(user, element, 'active');
                        
                        console.log(`[showChatMessage] User ${user.username} returned from ${oldState} to active, moving to inner ring`);
                    } else if (user.state !== 'lurk') {
                        // Normal active state update (not lurking)
                        user.state = 'active';
                        element.classList.remove('state-joined', 'state-sleepy', 'state-afk');
                        element.classList.add('state-active');
                    }
                    // Note: LURK users stay in lurk even when chatting - they must use join command
                }
                const usernameLabel = element.querySelector('.username');
                if (!usernameLabel) return;

                // Remove existing chat message if any (cancel its timeouts so we don't restore username too early)
                const existingMessage = element.querySelector('.chat-message');
                if (existingMessage) {
                    if (existingMessage._timeoutId) clearTimeout(existingMessage._timeoutId);
                    if (existingMessage._restoreId) clearTimeout(existingMessage._restoreId);
                    existingMessage.remove();
                }
                const prevOpacity = usernameLabel.style.opacity;
                usernameLabel.style.opacity = '0';

                const chatMessage = document.createElement('div');
                chatMessage.className = 'chat-message';
                if (isAction) chatMessage.classList.add('action-message');
                // Wrap so we can clamp to 3 lines with ellipsis
                // For action messages (/me), wrap in <em> for italics
                const messageContent = this.buildMessageWithEmotes(message, emotes);
                chatMessage.innerHTML = isAction
                    ? `<span class="chat-text"><em>${messageContent}</em></span>`
                    : `<span class="chat-text">${messageContent}</span>`;
                // Align the bubble to the username position (username top varies by sprite mode)
                try {
                    const t = window.getComputedStyle(usernameLabel).top;
                    if (t) chatMessage.style.top = t;
                    const z = window.getComputedStyle(usernameLabel).zIndex;
                    if (z) chatMessage.style.zIndex = z;
                } catch (e) { /* ignore */ }
                element.appendChild(chatMessage);

                // Play speak sound
                audioManager.playSound('speak');

                setTimeout(() => chatMessage.classList.add('show'), 10);

                // Use chatBubbleDuration setting (in seconds), default to 3 seconds
                const bubbleDuration = (this.settings.chatBubbleDuration || 3) * 1000;
                chatMessage._timeoutId = setTimeout(() => {
                    chatMessage.classList.remove('show');
                    chatMessage.classList.add('fade-out');
                    chatMessage._restoreId = setTimeout(() => {
                        chatMessage.remove();
                        usernameLabel.style.opacity = prevOpacity || '';
                    }, 250);
                }, bubbleDuration);
            }
            
            // Update user activity without showing a chat bubble (for commands)
            // This ensures commands count as "active" for state tracking
            updateUserActivity(username, userId = null) {
                const u = username ? String(username).toLowerCase() : '';
                const uid = userId ? String(userId).toLowerCase() : '';
                const user = this.users.find(uu =>
                    (uid && uu.userId && String(uu.userId).toLowerCase() === uid) ||
                    (u && (uu.username || '').toLowerCase() === u)
                );
                if (!user) return;
                
                const element = document.getElementById(user.id);
                if (!element) return;
                
                // Update user activity for state tracking
                user.lastActivity = Date.now();
                if (this.settings.userStates && this.settings.userStates.enabled) {
                    // Clear AFK/SLEEPY when user uses a command (but NOT lurk - lurk requires join command)
                    if (user.state === 'afk' || user.state === 'sleepy') {
                        const oldState = user.state;
                        user.state = 'active';
                        user.manualAfk = false;
                        user.wasSleepy = false;
                        user.persisted = false; // Clear persisted flag when user becomes active
                        element.classList.remove('state-joined', 'state-sleepy', 'state-afk', 'state-lurk', 'was-sleepy', 'outer-ring');
                        element.classList.add('state-active');
                        
                        // Remove indicators and move back to inner ring
                        this.updateStateIndicator(element, oldState, 'active');
                        this.updateUserRingPosition(user, element, 'active');
                        
                        console.log(`[updateUserActivity] User ${user.username} returned from ${oldState} to active via command, moving to inner ring`);
                    } else if (user.state !== 'lurk') {
                        // Normal active state update (not lurking)
                        user.state = 'active';
                        element.classList.remove('state-joined', 'state-sleepy', 'state-afk');
                        element.classList.add('state-active');
                    }
                }
            }

            calculateNextAngle() {
                // If no users exist, start at angle 0
                if (this.users.length === 0) return 0;
                
                // Check if grouping is enabled (default: false for even distribution)
                const enableGrouping = this.settings.enableUserGrouping === true; // Must be explicitly true
                const minDistance = this.settings.userGroupingDistance || 15; // Minimum degrees between users (default 15¬∞)
                
                if (enableGrouping && this.users.length > 0) {
                    // Grouping mode: Find best spot near existing users
                    // Get all existing angles
                    const existingAngles = this.users.map(u => {
                        // Normalize angles to 0-360
                        let angle = u.angle;
                        if (angle < 0) angle += 360;
                        if (angle >= 360) angle -= 360;
                        return angle;
                    }).sort((a, b) => a - b);
                    
                    // Try to find a spot near existing users (within minDistance)
                    // First, try spots near each existing user
                    let bestAngle = null;
                    let bestScore = -1;
                    
                    for (let i = 0; i < existingAngles.length; i++) {
                        const baseAngle = existingAngles[i];
                        // Try angles on both sides of this user (¬±minDistance to ¬±minDistance*2)
                        for (const offset of [minDistance, -minDistance, minDistance * 1.5, -minDistance * 1.5]) {
                            let candidateAngle = baseAngle + offset;
                            // Normalize to 0-360
                            if (candidateAngle < 0) candidateAngle += 360;
                            if (candidateAngle >= 360) candidateAngle -= 360;
                            
                            // Check if this spot is valid (not too close to any existing user)
                            const isValid = existingAngles.every(existing => {
                                let diff = Math.abs(candidateAngle - existing);
                                if (diff > 180) diff = 360 - diff; // Wrap around
                                return diff >= minDistance;
                            });
                            
                            if (isValid) {
                                // Calculate score: closer to baseAngle = higher score
                                const distance = Math.min(Math.abs(offset), Math.abs(360 - Math.abs(offset)));
                                const score = 1 / (1 + distance); // Higher score for closer spots
                                if (score > bestScore) {
                                    bestScore = score;
                                    bestAngle = candidateAngle;
                                }
                            }
                        }
                    }
                    
                    // If we found a good grouping spot, use it
                    if (bestAngle !== null) {
                        return bestAngle;
                    }
                    // Otherwise, fall through to even distribution
                }
                
                // Even distribution mode (default): Distribute users evenly around circle
                // This prevents exact same locations by spacing them out
                const spacing = 360 / (this.users.length + 1);
                return spacing * this.users.length;
            }
            
            // Update user states based on activity time
            updateUserStates() {
                if (!this.settings.userStates || !this.settings.userStates.enabled) {
                    return;
                }
                
                const now = Date.now();
                const sleepyThreshold = (this.settings.userStates.sleepyMinutes || 5) * 60 * 1000; // Default 5 minutes
                const afkThreshold = (this.settings.userStates.afkMinutes || 15) * 60 * 1000; // Default 15 minutes
                const autoLeaveThreshold = this.settings.userStates.autoLeaveMinutes
                    ? this.settings.userStates.autoLeaveMinutes * 60 * 1000
                    : null; // null = disabled
                
                this.users.forEach(user => {
                    const element = document.getElementById(user.id);
                    if (!element) return;
                    
                    // Skip LURK users - they must manually exit via join command
                    if (user.state === 'lurk') {
                        return;
                    }
                    
                    // Skip manual AFK users - they clear on any chat
                    if (user.manualAfk) {
                        return;
                    }
                    
                    const timeSinceActivity = now - (user.lastActivity || now);
                    let newState = 'active';
                    
                    // Check for auto-leave first (longest threshold)
                    if (autoLeaveThreshold && timeSinceActivity >= autoLeaveThreshold) {
                        // Auto-leave: remove user from campfire
                        console.log(`[AutoLeave] Removing ${user.username} after ${Math.round(timeSinceActivity / 60000)} minutes of inactivity`);
                        this.removeUser(user.username);
                        return;
                    } else if (timeSinceActivity >= afkThreshold) {
                        newState = 'afk';
                    } else if (timeSinceActivity >= sleepyThreshold) {
                        newState = 'sleepy';
                    }
                    
                    // Only update if state changed
                    if (user.state !== newState && user.state !== 'joined') {
                        const oldState = user.state;
                        
                        // Track if user was sleepy before going AFK (for combined visual state)
                        if (newState === 'afk' && oldState === 'sleepy') {
                            user.wasSleepy = true;
                            element.classList.add('was-sleepy');
                        } else if (newState === 'active') {
                            // Clear wasSleepy when returning to active
                            user.wasSleepy = false;
                            element.classList.remove('was-sleepy');
                        }
                        
                        user.state = newState;
                        element.classList.remove('state-active', 'state-sleepy', 'state-afk', 'state-lurk');
                        element.classList.add(`state-${newState}`);
                        
                        // Add/remove sleepy indicator (keep it for AFK if was sleepy)
                        this.updateStateIndicator(element, oldState, newState, user.wasSleepy);
                        
                        // SLEEPY users should be STILL (not roaming)
                        if (newState === 'sleepy') {
                            this.setUserStillMode(user, element, true);
                        }
                        
                        // Move to outer ring if AFK, back to inner if active
                        // Also sets STILL mode for AFK users
                        this.updateUserRingPosition(user, element, newState);
                        
                        // Play AFK sound if transitioning to AFK
                        if (newState === 'afk' && oldState !== 'afk') {
                            audioManager.playSound('afk');
                        }
                    }
                });
            }
            
            // Set user to STILL or WANDER mode
            setUserStillMode(user, element, isStill) {
                if (isStill) {
                    user.stillMode = true;
                    user.roaming = false;
                    user.still = true;
                    element.classList.remove('roaming');
                    element.classList.add('still');
                } else {
                    user.stillMode = false;
                    user.roaming = true;
                    user.wander = false; // Not in wander mode
                    user.still = false;
                    element.classList.remove('still', 'wander');
                    element.classList.add('roaming');
                }
            }
            
            // Add/remove state indicators (üí§ for sleepy, <AFK> for afk, SVG eye for lurk)
            // wasSleepy: if true, keep sleepy indicator even when transitioning to AFK
            updateStateIndicator(element, oldState, newState, wasSleepy = false) {
                // Remove old indicators (but keep sleepy if transitioning to AFK and wasSleepy)
                const oldSleepy = element.querySelector('.sleepy-indicator');
                const oldLurk = element.querySelector('.lurk-indicator');
                const oldAfk = element.querySelector('.afk-indicator');
                
                // Only remove sleepy indicator if NOT going to AFK with wasSleepy flag
                if (oldSleepy && !(newState === 'afk' && wasSleepy)) {
                    oldSleepy.remove();
                }
                if (oldLurk) oldLurk.remove();
                if (oldAfk) oldAfk.remove();
                
                // Add new indicator if needed
                if (newState === 'sleepy') {
                    // Only add if not already present
                    if (!element.querySelector('.sleepy-indicator')) {
                        const indicator = document.createElement('div');
                        indicator.className = 'sleepy-indicator';
                        indicator.textContent = 'üí§';
                        element.appendChild(indicator);
                    }
                } else if (newState === 'afk' && wasSleepy) {
                    // Keep sleepy indicator for AFK users who were sleepy (sleepy overrides AFK indicator)
                    if (!element.querySelector('.sleepy-indicator')) {
                        const indicator = document.createElement('div');
                        indicator.className = 'sleepy-indicator';
                        indicator.textContent = 'üí§';
                        element.appendChild(indicator);
                    }
                } else if (newState === 'afk' && !wasSleepy) {
                    // Show <AFK> text indicator for AFK users who weren't sleepy
                    if (!element.querySelector('.afk-indicator')) {
                        const indicator = document.createElement('div');
                        indicator.className = 'afk-indicator';
                        indicator.textContent = '<AFK>';
                        element.appendChild(indicator);
                    }
                } else if (newState === 'lurk') {
                    const indicator = document.createElement('div');
                    indicator.className = 'lurk-indicator';
                    // SVG eye icon instead of emoji
                    indicator.innerHTML = `<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                    </svg>`;
                    element.appendChild(indicator);
                }
            }
            
            // Move user to outer ring (AFK/LURK) or inner ring (active)
            // Also sets user to STILL mode and positions at top arc of circle
            updateUserRingPosition(user, element, state) {
                const isOuterRing = state === 'afk' || state === 'lurk';
                const isLurk = state === 'lurk';
                 
                if (isOuterRing) {
                    // Move to outer ring - increase radius
                    user.outerRing = true;
                    element.classList.add('outer-ring');
                     
                    // LURK users can wander (with reduced distance), AFK users are STILL
                    if (isLurk) {
                        // LURK users can roam on outer ring (0.5x speed)
                        user.roaming = true;
                        user.wander = false;
                        user.stillMode = false;
                        user.still = false;
                        element.classList.remove('still');
                        element.classList.add('roaming');
                    } else {
                        // AFK users are STILL (no roaming)
                        user.roaming = false;
                        user.wander = false;
                        user.stillMode = true;
                        user.still = true;
                        element.classList.remove('roaming', 'wander');
                        element.classList.add('still');
                    }
                     
                    // Position at top arc of circle (190¬∞ to 350¬∞)
                    // This is the "visual top" when viewed from above (top-down view)
                    // 190¬∞ to 350¬∞ = 160¬∞ arc at the back of the campfire
                    const outerRingStartAngle = 190;
                    const outerRingEndAngle = 350;
                    const outerRingArcSize = outerRingEndAngle - outerRingStartAngle; // 160 degrees
                     
                    // Calculate position with spacing to prevent overlap
                    user.angle = this.calculateOuterRingAngle(user, outerRingStartAngle, outerRingArcSize);
                    console.log(`[Outer Ring] User ${user.username} positioned at angle ${user.angle}¬∞ (range: ${outerRingStartAngle}¬∞-${outerRingEndAngle}¬∞)`);
                     
                    // Ensure the user's position is updated immediately after transitioning to the outer ring
                    this.positionUserElement(user);
                } else {
                    // Move back to inner ring
                    user.outerRing = false;
                    element.classList.remove('outer-ring');
                    
                    // Restore roaming mode (users return to roaming when they rejoin)
                    // Also clear wasSleepy flag
                    user.stillMode = false;
                    user.roaming = true;
                    user.wander = false; // Return to default roam, not wander
                    user.still = false;
                    user.wasSleepy = false;
                    element.classList.remove('still', 'was-sleepy', 'wander');
                    element.classList.add('roaming');
                }
                
                // Reposition user with new ring
                this.positionUser(user, element);
            }
            
            // Calculate angle for outer ring user with spacing to prevent overlap
            calculateOuterRingAngle(user, startAngle, arcSize) {
                // Get all users currently on outer ring (excluding the current user)
                const outerRingUsers = this.users.filter(u =>
                    u.outerRing && u.id !== user.id
                );
                
                // If no other users on outer ring, place at center of arc
                if (outerRingUsers.length === 0) {
                    return startAngle + arcSize / 2;
                }
                
                // Calculate minimum spacing between users (in degrees)
                // Based on sprite size and outer ring radius
                const minSpacing = 25; // degrees between users
                
                // Get existing angles on outer ring
                const existingAngles = outerRingUsers.map(u => u.angle);
                
                // Try to find a spot with enough spacing
                // Start from center and work outward
                const centerAngle = startAngle + arcSize / 2;
                
                // Try positions in a spiral pattern from center
                for (let offset = 0; offset <= arcSize / 2; offset += minSpacing / 2) {
                    // Try center + offset
                    const angle1 = centerAngle + offset;
                    if (angle1 <= startAngle + arcSize && this.hasEnoughSpacing(angle1, existingAngles, minSpacing)) {
                        return angle1;
                    }
                    
                    // Try center - offset
                    if (offset > 0) {
                        const angle2 = centerAngle - offset;
                        if (angle2 >= startAngle && this.hasEnoughSpacing(angle2, existingAngles, minSpacing)) {
                            return angle2;
                        }
                    }
                }
                
                // If no good spot found, distribute evenly
                const totalUsers = outerRingUsers.length + 1;
                const spacing = arcSize / (totalUsers + 1);
                const userIndex = outerRingUsers.length; // New user gets last position
                return startAngle + spacing * (userIndex + 1);
            }
            
            // Check if an angle has enough spacing from existing angles
            hasEnoughSpacing(angle, existingAngles, minSpacing) {
                for (const existing of existingAngles) {
                    const diff = Math.abs(angle - existing);
                    if (diff < minSpacing) {
                        return false;
                    }
                }
                return true;
            }
            
            // Set user to manual AFK state (via command)
            setUserAfk(username) {
                const normalizedUsername = username ? username.toLowerCase() : '';
                const user = this.users.find(u =>
                    (u.username || '').toLowerCase() === normalizedUsername
                );
                 
                if (!user) return false;
                 
                const element = document.getElementById(user.id);
                if (!element) return false;
                 
                const oldState = user.state;
                user.state = 'afk';
                user.manualAfk = true; // Flag for manual AFK
                 
                element.classList.remove('state-active', 'state-sleepy', 'state-joined', 'state-lurk');
                element.classList.add('state-afk');
                 
                this.updateStateIndicator(element, oldState, 'afk', user.wasSleepy);
                this.updateUserRingPosition(user, element, 'afk');
                 
                // Play AFK sound
                audioManager.playSound('afk');
                
                return true;
            }
            
            // Update user data (e.g., placeholder user getting real Twitch data)
            updateUser(username, userData) {
                const normalizedUsername = username ? username.toLowerCase() : '';
                const user = this.users.find(u =>
                    (u.username || '').toLowerCase() === normalizedUsername
                );

                if (!user) {
                    console.warn(`[updateUser] User ${username} not found for update`);
                    return false;
                }

                // Update user properties
                Object.assign(user, userData);

                // Update the visual element
                this.updateUserElement(user);

                console.log(`[updateUser] Updated user ${username} with new data`);
                return true;
            }

            // Set user to LURK state (via command)
            setUserLurk(username) {
                const normalizedUsername = username ? username.toLowerCase() : '';
                const user = this.users.find(u =>
                    (u.username || '').toLowerCase() === normalizedUsername
                );
                
                if (!user) return false;
                
                const element = document.getElementById(user.id);
                if (!element) return false;
                
                const oldState = user.state;
                user.state = 'lurk';
                user.manualAfk = false; // Not AFK, lurking
                
                element.classList.remove('state-active', 'state-sleepy', 'state-joined', 'state-afk');
                element.classList.add('state-lurk');
                
                this.updateStateIndicator(element, oldState, 'lurk');
                this.updateUserRingPosition(user, element, 'lurk');
                
                // Play lurk sound
                audioManager.playSound('lurk');
                
                return true;
            }
            
            // Return user from LURK/AFK to active (via join command)
            returnUserFromLurkOrAfk(username) {
                const normalizedUsername = username ? username.toLowerCase() : '';
                const user = this.users.find(u =>
                    (u.username || '').toLowerCase() === normalizedUsername
                );
                
                if (!user) return false;
                if (user.state !== 'lurk' && user.state !== 'afk') return false;
                
                const element = document.getElementById(user.id);
                if (!element) return false;
                
                const oldState = user.state;
                user.state = 'joined';
                user.manualAfk = false;
                user.lastActivity = Date.now();
                
                element.classList.remove('state-afk', 'state-lurk', 'state-sleepy');
                element.classList.add('state-joined');
                
                this.updateStateIndicator(element, oldState, 'joined');
                this.updateUserRingPosition(user, element, 'joined');
                
                // Transition to active after joined animation
                setTimeout(() => {
                    if (user.state === 'joined') {
                        user.state = 'active';
                        element.classList.remove('state-joined');
                        element.classList.add('state-active');
                    }
                }, 4500);
                
                return true;
            }
            
            // Start the user state update interval
            startUserStateUpdates() {
                // Clear any existing interval
                if (this.userStateInterval) {
                    clearInterval(this.userStateInterval);
                }
                
                // Update states every 30 seconds
                this.userStateInterval = setInterval(() => {
                    this.updateUserStates();
                }, 30000);
                
                // Also run immediately
                this.updateUserStates();
            }
            
            // Stop the user state update interval
            stopUserStateUpdates() {
                if (this.userStateInterval) {
                    clearInterval(this.userStateInterval);
                    this.userStateInterval = null;
                }
            }
            
            // Wrapper to position user (calls positionUserElement)
            positionUser(user, element) {
                this.positionUserElement(user);
            }

            createUserElement(user) {
                const container = document.getElementById('circleContainer');
                const element = document.createElement('div');
                element.className = 'user-shape'; // Don't add 'entering' class yet - wait for sprite to load
                element.id = user.id;
                
                // Apply sprite size from settings
                const spriteSize = this.settings.spriteSize || 40;
                element.style.width = `${spriteSize}px`;
                element.style.height = `${spriteSize}px`;
                
                const shape = document.createElement('div');
                shape.className = 'shape';
                
                // Get viewer color for circle/circles sprites (saved color takes precedence, then Twitch color)
                // For other modes, this is less critical since sprites aren't colorized the same way
                const spriteMode = this.settings.spriteMode || 'circles';
                let viewerColor = (spriteMode === 'circle' || spriteMode === 'circles')
                    ? this.getCircleSpriteColor(user.username, user.userId)
                    : (user.color || this.getViewerColor(user.username, user.userId));
                
                // Save the color back to the user object for future reference
                if (viewerColor && !user.color) {
                    user.color = viewerColor;
                }
                
                // Get sprite for this user FIRST
                let spriteInfo = this.getUserSprite(user);
                
                // Validate spriteInfo.data is a string (not an object) using helper
                if (spriteInfo && spriteInfo.data) {
                    const dataString = this.extractSpriteDataString(spriteInfo.data);
                    if (!dataString) {
                        console.warn(`[createUserElement] Could not extract sprite data string for ${user.username}`);
                        spriteInfo = null;
                    } else if (dataString !== spriteInfo.data) {
                        // Fix the data to be a string
                        spriteInfo = { ...spriteInfo, data: dataString };
                    }
                }
                
                // For sprites: Hide element initially until sprite loads
                // For fallback: Don't hide - show immediately
                const hasSprite = spriteInfo && spriteInfo.data;
                if (hasSprite) {
                    // CRITICAL: Hide element completely - use visibility AND opacity AND ensure no background shows
                    // Set these BEFORE appending to DOM to prevent any flash
                    element.style.display = 'none';
                    element.style.visibility = 'hidden';
                    element.style.opacity = '0';
                }
                
                // IMMEDIATELY clear all default styles to prevent circle from showing
                // Do this BEFORE checking if sprite exists, so no circle shows during loading
                shape.style.background = 'transparent';
                shape.style.backgroundColor = 'transparent';
                shape.style.backgroundImage = 'none';
                shape.style.border = 'none';
                shape.style.borderRadius = '0';
                shape.style.boxShadow = 'none';
                shape.style.outline = 'none';
                shape.style.borderColor = 'transparent';
                shape.style.borderWidth = '0';
                shape.style.borderStyle = 'none';
                // Force remove any CSS border/outline that might be showing
                shape.style.setProperty('background', 'transparent', 'important');
                shape.style.setProperty('border', 'none', 'important');
                shape.style.setProperty('outline', 'none', 'important');
                
                if (spriteInfo && spriteInfo.data) {
                    // Clear any existing sprite img elements first
                    shape.innerHTML = '';

                    // Shape is already cleared above - sprite will be added next
                    shape.style.background = 'transparent';
                    shape.style.backgroundColor = 'transparent';
                    shape.style.backgroundImage = 'none';
                    shape.style.border = 'none';
                    shape.style.borderRadius = '0';
                    shape.style.boxShadow = 'none';
                    shape.style.outline = 'none';
                    // Force remove with important
                    shape.style.setProperty('background', 'transparent', 'important');
                    shape.style.setProperty('border', 'none', 'important');
                    shape.style.setProperty('outline', 'none', 'important');
                    
                    // Use sprite - create img element for GIF animation control
                    const spriteImg = document.createElement('img');
                    spriteImg.style.width = '100%';
                    spriteImg.style.height = '100%';
                    spriteImg.style.objectFit = 'contain';
                    spriteImg.style.objectPosition = 'center';
                    spriteImg.style.display = 'block';
                    spriteImg.style.boxShadow = 'none';
                    spriteImg.style.border = 'none';
                    spriteImg.style.borderRadius = '0';
                    spriteImg.style.overflow = 'visible';
                    
                    // Check if it's an SVG (fallback circle) - make it pixelated/low-res
                    if (spriteInfo.data && spriteInfo.data.includes('data:image/svg+xml')) {
                        spriteImg.style.imageRendering = 'pixelated';
                        spriteImg.style.imageRendering = '-moz-crisp-edges';
                        spriteImg.style.imageRendering = 'crisp-edges';
                    }
                    
                    // Apply colorization if needed (for circle and morph modes)
                    if (spriteInfo.colorize && spriteInfo.color) {
                        spriteImg.style.filter = `brightness(0) saturate(100%) ${this.colorToFilter(spriteInfo.color)}`;
                    } else {
                        spriteImg.style.filter = 'none';
                    }
                    
                    // Set up sprite to start invisible - will be shown only after it loads
                    spriteImg.style.opacity = '0';
                    // Don't use transition - let the element's popIn animation handle the appearance
                    
                    // Store reference to element on spriteImg so onload handler can access it
                    spriteImg._element = element;
                    spriteImg._shape = shape;
                    spriteImg._spriteMode = this.settings.spriteMode || 'circles';
                    
                        // Function to show element after sprite is ready
                        let showElementWithSprite = () => {
                            // Make sprite fully visible immediately (no transition) - element animation handles the effect
                            spriteImg.style.opacity = '1';
                            // Double-check background is transparent when sprite loads successfully
                            shape.style.background = 'transparent';
                            shape.style.backgroundColor = 'transparent';
                            shape.style.backgroundImage = 'none';
                            shape.style.border = 'none';
                            shape.style.outline = 'none';
                            // Force remove border/outline with important
                            shape.style.setProperty('border', 'none', 'important');
                            shape.style.setProperty('outline', 'none', 'important');
                            
                            // Only show element and start entering animation AFTER sprite loads
                            const elem = spriteImg._element;
                            if (elem) {
                                // Check if element was already visible (i.e., this is an update, not a new user)
                                const wasVisible = elem.style.visibility === 'visible' || 
                                                 elem.style.display === '' || 
                                                 elem.classList.contains('idle') ||
                                                 elem.classList.contains('entering');
                                
                                if (!wasVisible) {
                                    // OPTIMIZATION: Double-RAF pattern prevents layout thrashing and flicker
                                    // First RAF: browser schedules repaint, second RAF ensures paint before animation
                                    requestAnimationFrame(() => {
                                        requestAnimationFrame(() => {
                                            elem.classList.add('entering');
                                            elem.style.opacity = ''; // no inline opacity; popIn controls it
                                            elem.style.display = '';
                                            elem.style.visibility = 'visible';
                                            // Remove entering after animation and add idle
                                            setTimeout(() => {
                                                if (elem && elem.classList.contains('entering')) {
                                                    elem.classList.remove('entering');
                                                    const spriteMode = spriteImg._spriteMode || 'circles';
                                                    if (spriteMode !== 'rpg-characters') {
                                                        elem.classList.add('idle');
                                                        const randomDelay = Math.random() * 3;
                                                        elem.style.animationDelay = `${randomDelay}s`;
                                                    }
                                                }
                                            }, 500);
                                        });
                                    });
                                } else {
                                    // Update: restore visibility without animation
                                    elem.style.display = '';
                                    elem.style.visibility = 'visible';
                                    elem.style.opacity = '1';
                                    // For updates, just ensure idle animation is present (if appropriate)
                                    const spriteMode = spriteImg._spriteMode || 'circles';
                                    if (spriteMode !== 'rpg-characters' && !elem.classList.contains('idle')) {
                                        elem.classList.add('idle');
                                        const randomDelay = Math.random() * 3;
                                        elem.style.animationDelay = `${randomDelay}s`;
                                    }
                                }
                            }
                        };
                    
                    // Handle successful sprite load
                    spriteImg.onload = showElementWithSprite;
                    
                    // Handle image load errors
                    spriteImg.onerror = () => {
                        console.error(`[createUserElement] Failed to load sprite for ${user.username}`);
                        spriteImg.remove();
                        shape._spriteImg = null;
                        // Fall back to default shape ONLY if sprite actually failed to load
                        // Make sure to clear any sprite-related styles first
                        shape.style.backgroundImage = 'none';
                        shape.style.background = `linear-gradient(135deg, ${viewerColor || '#667eea'} 0%, ${this.adjustColor(viewerColor || '#667eea', -20)} 100%)`;
                        shape.style.border = '2px solid rgba(255, 255, 255, 0.8)';
                        shape.style.borderRadius = '50%';
                        shape.style.filter = 'none';
                        shape.style.outline = 'none'; // Still remove outline
                        
                        // Show element with fallback shape - sprite failed, show default circle
                        const elem = spriteImg._element;
                        if (elem) {
                            // Always show fallback, even if element was already visible
                            elem.style.display = '';
                            elem.style.visibility = 'visible';
                            elem.style.opacity = '1';
                            elem.classList.add('entering');
                            setTimeout(() => {
                                if (elem && elem.classList.contains('entering')) {
                                    elem.classList.remove('entering');
                                    const spriteMode = spriteImg._spriteMode || 'circle';
                                    if (spriteMode !== 'rpg-characters') {
                                        elem.classList.add('idle');
                                        const randomDelay = Math.random() * 3;
                                        elem.style.animationDelay = `${randomDelay}s`;
                                    }
                                }
                            }, 500);
                        }
                    };
                    
                    // Store reference to img and add to DOM immediately
                    // This allows the entering animation to play while sprite loads
                    shape._spriteImg = spriteImg;
                    shape.appendChild(spriteImg);
                    
                    // NO MORE STAGGERED DELAYS - they cause issues when users are added sequentially
                    // SVG data URLs load instantly anyway, GIFs load async via blob URLs
                    // Just use a simple incremental delay for GIF desynchronization only
                    const loadIndex = Date.now(); // Use timestamp for uniqueness instead of counter
                    const randomSeed = Math.floor(Math.random() * 1000000); // Unique seed per load
                    
                    // DEFER sprite loading until AFTER element is in DOM
                    // Store the loading function to be called later
                    element._loadSpriteFunction = () => {
                        // Load sprite with staggered delay to prevent race conditions
                        const loadSprite = () => {
                            // Check if it's a data URL
                            if (spriteInfo.data.startsWith('data:')) {
                                // Check if it's SVG - SVG data URLs work fine directly, no need for blob conversion
                                // (Blob conversion is only needed for GIFs to desynchronize animations)
                                if (spriteInfo.data.includes('data:image/svg+xml')) {
                                    // SVG data URL - loads synchronously, show IMMEDIATELY
                                    // CRITICAL: Disable onload handler FIRST to prevent race condition
                                    // The onload handler sets opacity to 0 then uses RAF which can fail
                                    spriteImg.onload = null;
                                    
                                    // Set SVG src immediately - no delay needed for SVG (they load synchronously)
                                    spriteImg.src = spriteInfo.data;
                                    console.log(`[createUserElement] SVG set for ${user.username}, showing immediately`);
                                    
                                    // Show sprite immediately
                                    spriteImg.style.opacity = '1';
                                    
                                    // Clear background to ensure only sprite shows
                                    shape.style.background = 'transparent';
                                    shape.style.backgroundColor = 'transparent';
                                    shape.style.backgroundImage = 'none';
                                    shape.style.border = 'none';
                                    shape.style.outline = 'none';
                                    shape.style.setProperty('border', 'none', 'important');
                                    shape.style.setProperty('outline', 'none', 'important');
                                    
                                    // Use the element reference directly from closure (guaranteed correct)
                                    // Don't rely on document.getElementById which can fail
                                    const elem = element; // Direct reference from closure
                                    console.log(`[createUserElement] Showing element for ${user.username} directly`);
                                    elem.style.display = '';
                                    elem.style.visibility = 'visible';
                                    elem.style.opacity = '1';
                                    elem.classList.add('entering');
                                    
                                    // Remove entering animation after it completes
                                    setTimeout(() => {
                                        if (elem && elem.classList.contains('entering')) {
                                            elem.classList.remove('entering');
                                            const spriteMode = spriteImg._spriteMode || 'circles';
                                            if (spriteMode !== 'rpg-characters') {
                                                elem.classList.add('idle');
                                                const randomDelay = Math.random() * 3;
                                                elem.style.animationDelay = `${randomDelay}s`;
                                            }
                                        }
                                    }, 500);
                                    
                                    // Clear timeout since we're showing immediately
                                    if (loadTimeout) clearTimeout(loadTimeout);
                                } else {
                                    // GIF or other data URL - convert to blob URL for cache-busting and desync
                                    fetch(spriteInfo.data)
                                        .then(response => response.blob())
                                        .then(blob => {
                                            const blobUrl = URL.createObjectURL(blob);
                                            spriteImg.src = blobUrl;
                                            // Store blob URL for cleanup later
                                            spriteImg._blobUrl = blobUrl;
                                            // Check if already loaded
                                            setTimeout(() => {
                                                if (spriteImg.complete && spriteImg.naturalWidth > 0 && spriteImg.naturalHeight > 0) {
                                                    showElementWithSprite();
                                                }
                                            }, 10);
                                        })
                                        .catch(error => {
                                            console.error(`[createUserElement] Failed to convert data URL to blob for ${user.username}:`, error);
                                            // Fallback to using data URL directly
                                            spriteImg.src = spriteInfo.data;
                                            setTimeout(() => {
                                                if (spriteImg.complete && spriteImg.naturalWidth > 0 && spriteImg.naturalHeight > 0) {
                                                    showElementWithSprite();
                                                }
                                            }, 10);
                                        });
                                }
                            } else {
                                // For regular URLs, add cache-busting parameters
                                const separator = spriteInfo.data.includes('?') ? '&' : '?';
                                spriteImg.src = spriteInfo.data + separator + 't=' + randomSeed + '&r=' + Date.now();
                                // Check if image is already loaded (cached) - must check AFTER setting src
                                checkImageLoaded();
                            }
                        };
                        
                        // Check if sprite is already loaded (cached images)
                        const checkImageLoaded = () => {
                            // Use setTimeout to allow browser to set complete/naturalWidth
                            setTimeout(() => {
                                if (spriteImg.complete && spriteImg.naturalWidth > 0 && spriteImg.naturalHeight > 0) {
                                    // Image is already loaded (cached), show immediately
                                    showElementWithSprite();
                                }
                            }, 10); // Small delay to ensure browser has set the properties
                        };
                        
                        // Store reference to this specific sprite load to prevent conflicts
                        spriteImg._loadIndex = loadIndex;
                        
                        // REMOVED: Fallback timeout that was causing circles to appear behind sprites
                        // The timeout was incorrectly triggering onerror() even when sprites loaded successfully
                        // Sprites now either load (via onload) or fail (via onerror) - no artificial timeout
                        // See SPRITE_SYSTEM_REFACTOR.md for the proper architectural solution
                        
                        // ALWAYS call loadSprite - no conditions that could fail
                        loadSprite();
                    };
                    
                    // Clear background-image if it exists (already cleared above, but ensure it stays clear)
                    shape.style.backgroundImage = 'none';
                    shape.style.backgroundSize = 'none';
                    shape.style.backgroundPosition = 'none';
                    shape.style.backgroundRepeat = 'none';
                    shape.style.boxShadow = 'none';
                    shape.style.overflow = 'visible';
                    shape.style.outline = 'none'; // Ensure no outline
                    // Force remove with important to override any CSS
                    shape.style.setProperty('outline', 'none', 'important');
                    shape.style.setProperty('border', 'none', 'important');
                    shape.style.setProperty('border-color', 'transparent', 'important');
                }
                
                // Fallback: no sprite or invalid sprite data
                // ONLY apply fallback styles if there's NO sprite
                if (!hasSprite) {
                    // Show default colored circle (only if no sprite was found)
                    const shapeStyle = this.settings.shapeStyle || 'circle';
                    if (shapeStyle === 'square') {
                        shape.style.borderRadius = '4px';
                    } else {
                        shape.style.borderRadius = '50%';
                    }
                    // Apply color to default shape (only if no sprite was found)
                    if (viewerColor) {
                        shape.style.backgroundImage = 'none';
                        shape.style.background = `linear-gradient(135deg, ${viewerColor} 0%, ${this.adjustColor(viewerColor, -20)} 100%)`;
                        shape.style.setProperty('border', '2px solid rgba(255, 255, 255, 0.8)', 'important');
                        // Only show border if we're actually using the fallback circle
                        shape.style.outline = 'none'; // Still remove outline
                    }
                    shape.style.filter = 'none';
                }
                
                const usernameLabel = document.createElement('div');
                usernameLabel.className = 'username';
                usernameLabel.textContent = user.username;
                
                // Username position is controlled by CSS variable --name-bubble-offset (set in applyNameBubbleOffset)
                // No inline style.top needed - CSS handles it

                if (spriteMode === 'rpg-characters') {
                    // RPG mode: use Twitch color with black stroke
                    const twitchColor = this.getTwitchColor(user.username, user.userId);
                    usernameLabel.style.color = twitchColor;
                } else if (spriteMode === 'pixel-morphs') {
                    // MORPH mode: use Twitch color with black stroke
                    const twitchColor = this.getTwitchColor(user.username, user.userId);
                    usernameLabel.style.color = twitchColor;
                } else {
                    // CIRCLE/CIRCLES mode: use Twitch username color (or hash fallback) like other modes
                    const twitchColor = this.getTwitchColor(user.username, user.userId);
                    usernameLabel.style.color = twitchColor;
                }
                
                // Check if username overlaps with sprite and make transparent if needed
                this.checkUsernameOverlap(usernameLabel, user);
                
                // Create state ring element for user state indicators
                const stateRing = document.createElement('div');
                stateRing.className = 'state-ring';
                
                element.appendChild(shape);
                element.appendChild(stateRing);
                element.appendChild(usernameLabel);
                
                // Initialize user state tracking
                user.lastActivity = Date.now();
                user.state = 'joined'; // Initial state
                element.classList.add('state-joined');
                
                // Remove joined state after animation completes (4.5s = 3 pulses at 1.5s each)
                setTimeout(() => {
                    element.classList.remove('state-joined');
                    // Transition to active state if user states are enabled
                    if (this.settings.userStates && this.settings.userStates.enabled) {
                        user.state = 'active';
                        element.classList.add('state-active');
                    }
                }, 4500);
                
                // Hide element initially - will be shown after sprite loads (if sprite exists)
                // For fallback shapes (no sprite), show immediately
                // hasSprite is already declared earlier in this function
                if (hasSprite) {
                    // Completely hide element until sprite loads - use display: none BEFORE appending
                    // This prevents any flash of empty square
                    element.style.display = 'none';
                    // Also ensure shape has no background that could show through
                    shape.style.background = 'transparent';
                    shape.style.backgroundColor = 'transparent';
                    shape.style.border = 'none';
                } else {
                    // No sprite - show element immediately with entering animation
                    element.style.opacity = '1';
                    element.classList.add('entering');
                    // Remove entering animation class after animation and add idle (gentle float)
                    setTimeout(() => {
                        element.classList.remove('entering');
                        const spriteMode = this.settings.spriteMode || 'circle';
                        if (spriteMode !== 'rpg-characters') {
                            element.classList.add('idle'); // This applies the gentle float animation
                            // Add random animation delay so sprites don't float in sync
                            const randomDelay = Math.random() * 3; // 0-3 seconds random delay
                            element.style.animationDelay = `${randomDelay}s`;
                        }
                    }, 500);
                }
                
                // Append element to DOM
                container.appendChild(element);
                this.positionUserElement(user);
                
                // NOW that element is in DOM, load the sprite IMMEDIATELY
                // appendChild is synchronous - element IS in DOM now, no need to wait
                if (element._loadSpriteFunction) {
                    element._loadSpriteFunction();
                    delete element._loadSpriteFunction; // Clean up
                }
                
                // For sprites: Element is hidden, will be shown in spriteImg.onload
                // For fallback (no sprite): Show immediately with entering animation
                if (!hasSprite) {
                    // No sprite - show element immediately with entering animation
                    element.style.display = '';
                    element.style.visibility = 'visible';
                    element.style.opacity = '1';
                    element.classList.add('entering');
                    // Remove entering animation class after animation and add idle (gentle float)
                    setTimeout(() => {
                        element.classList.remove('entering');
                        const spriteMode = this.settings.spriteMode || 'circle';
                        if (spriteMode !== 'rpg-characters') {
                            element.classList.add('idle'); // This applies the gentle float animation
                            // Add random animation delay so sprites don't float in sync
                            const randomDelay = Math.random() * 3; // 0-3 seconds random delay
                            element.style.animationDelay = `${randomDelay}s`;
                        }
                    }, 500);
                }
                // If hasSprite: Element stays hidden until spriteImg.onload shows it
            }

            updateUserElement(user) {
                // Update existing user element with new data
                const element = document.getElementById(user.id);
                if (!element) return;
                // Don't update during exit animation
                if (element.classList.contains('leaving')) return;

                // Get updated color for circle/circles sprites (saved color takes precedence, then Twitch color)
                const spriteMode = this.settings.spriteMode || 'circles';
                let viewerColor = (spriteMode === 'circle' || spriteMode === 'circles')
                    ? this.getCircleSpriteColor(user.username, user.userId)
                    : (user.color || this.getViewerColor(user.username, user.userId));
                
                // Save the color back to the user object for future reference
                if (viewerColor && !user.color) {
                    user.color = viewerColor;
                }
                
                const shape = element.querySelector('.shape');
                const usernameLabel = element.querySelector('.username');

                if (shape) {
                    // Get sprite for this user
                    let spriteInfo = this.getUserSprite(user);
                    
                    // Validate spriteInfo.data is a string (not an object)
                    if (spriteInfo && spriteInfo.data && typeof spriteInfo.data !== 'string') {
                        console.warn(`[updateUserElement] spriteInfo.data is not a string for ${user.username}:`, typeof spriteInfo.data);
                        if (typeof spriteInfo.data === 'object' && spriteInfo.data.data) {
                            spriteInfo = { ...spriteInfo, data: spriteInfo.data.data };
                        } else {
                            spriteInfo = null;
                        }
                    }
                    
                    if (spriteInfo && spriteInfo.data) {
                        // Capture if user was already visible BEFORE hiding (to skip entering animation on mere updates)
                        // Include 'moving' so NPCs mid-walk don't get mistaken for new and re-animate
                        const skipEnteringAnimation = element.classList.contains('idle') || element.classList.contains('entering') || element.classList.contains('moving');
                        
                        // CRITICAL: Hide element completely BEFORE removing old sprite and loading new one
                        // This prevents empty squares from being visible during sprite swap
                        element.style.display = 'none';
                        element.style.visibility = 'hidden';
                        element.style.opacity = '0';
                        
                        // Remove default background and border from shape when using sprites
                        // IMPORTANT: Clear ALL background properties to prevent circle from showing
                        shape.style.background = 'transparent';
                        shape.style.backgroundColor = 'transparent';
                        shape.style.backgroundImage = 'none';
                        shape.style.border = 'none';
                        shape.style.borderRadius = '0';
                        shape.style.boxShadow = 'none';
                        shape.style.outline = 'none';
                        // Force remove with important
                        shape.style.setProperty('background', 'transparent', 'important');
                        shape.style.setProperty('border', 'none', 'important');
                        shape.style.setProperty('outline', 'none', 'important');
                        
                        // Always remove existing img to ensure clean state
                        const existingImg = shape.querySelector('img');
                        if (existingImg) {
                            // Clean up blob URL if it exists
                            if (existingImg._blobUrl) {
                                URL.revokeObjectURL(existingImg._blobUrl);
                            }
                            existingImg.remove();
                            shape._spriteImg = null;
                        }
                        
                        // Create new img element
                        const spriteImg = document.createElement('img');
                        spriteImg.style.width = '100%';
                        spriteImg.style.height = '100%';
                        spriteImg.style.objectFit = 'contain';
                        spriteImg.style.objectPosition = 'center';
                        spriteImg.style.display = 'block';
                        spriteImg.style.boxShadow = 'none';
                        spriteImg.style.border = 'none';
                        spriteImg.style.borderRadius = '0';
                        spriteImg.style.overflow = 'visible';
                        
                        // Check if it's an SVG (fallback circle) - make it pixelated/low-res
                        if (spriteInfo.data && spriteInfo.data.includes('data:image/svg+xml')) {
                            spriteImg.style.imageRendering = 'pixelated';
                            spriteImg.style.imageRendering = '-moz-crisp-edges';
                            spriteImg.style.imageRendering = 'crisp-edges';
                        }
                        
                        // Apply colorization if needed (for circle and morph modes)
                        if (spriteInfo.colorize && spriteInfo.color) {
                            spriteImg.style.filter = `brightness(0) saturate(100%) ${this.colorToFilter(spriteInfo.color)}`;
                        } else {
                            spriteImg.style.filter = 'none';
                        }
                        
                        // Set up sprite to start invisible - will be shown only after it loads
                        spriteImg.style.opacity = '0';
                        // Don't use transition - let the element's popIn animation handle the appearance
                        
                        // Store reference to element on spriteImg so onload handler can access it
                        spriteImg._element = element;
                        spriteImg._shape = shape;
                        spriteImg._spriteMode = this.settings.spriteMode || 'circles';
                        
                        // Function to show element after sprite is ready
                        let showElementWithSprite = () => {
                            // Make sprite fully visible immediately (no transition) - element animation handles the effect
                            spriteImg.style.opacity = '1';
                            // Double-check background is transparent when sprite loads successfully
                            shape.style.background = 'transparent';
                            shape.style.backgroundColor = 'transparent';
                            shape.style.backgroundImage = 'none';
                            shape.style.border = 'none';
                            shape.style.outline = 'none';
                            // Force remove border/outline with important
                            shape.style.setProperty('border', 'none', 'important');
                            shape.style.setProperty('outline', 'none', 'important');
                            
                            // Show element now that sprite is loaded - restore visibility
                            if (element) {
                                element.style.display = '';
                                element.style.visibility = 'visible';
                                
                                if (skipEnteringAnimation) {
                                    // Just restore visibility, no entering animation (user was already on screen)
                                    element.style.opacity = '1';
                                    if (!element.classList.contains('idle') && !element.classList.contains('moving')) {
                                        element.classList.add('idle');
                                        const randomDelay = Math.random() * 3;
                                        element.style.animationDelay = `${randomDelay}s`;
                                    }
                                } else {
                                    // New or was hidden - use entering animation
                                    element.style.opacity = '';
                                    requestAnimationFrame(() => {
                                        requestAnimationFrame(() => {
                                            element.classList.add('entering');
                                            setTimeout(() => {
                                                if (element && element.classList.contains('entering')) {
                                                    element.classList.remove('entering');
                                                    const spriteMode = spriteImg._spriteMode || 'circles';
                                                    if (spriteMode !== 'rpg-characters') {
                                                        element.classList.add('idle');
                                                        const randomDelay = Math.random() * 3;
                                                        element.style.animationDelay = `${randomDelay}s`;
                                                    }
                                                }
                                            }, 500);
                                        });
                                    });
                                }
                            }
                        };
                        
                        // Handle image load errors
                        spriteImg.onerror = () => {
                            console.error(`[updateUserElement] Failed to load sprite for ${user.username}`);
                            spriteImg.remove();
                            shape._spriteImg = null;
                            // Fall back to default shape ONLY if sprite actually failed to load
                            // Make sure to clear any sprite-related styles first
                            shape.style.backgroundImage = 'none';
                            shape.style.background = `linear-gradient(135deg, ${viewerColor || '#667eea'} 0%, ${this.adjustColor(viewerColor || '#667eea', -20)} 100%)`;
                            shape.style.border = '2px solid rgba(255, 255, 255, 0.8)';
                            shape.style.borderRadius = '50%';
                            shape.style.filter = 'none';
                            
                            // Show element with fallback shape - sprite failed, show default circle
                            if (element) {
                                element.style.display = '';
                                element.style.visibility = 'visible';
                                if (skipEnteringAnimation) {
                                    element.style.opacity = '1';
                                    if (!element.classList.contains('idle') && !element.classList.contains('moving')) {
                                        element.classList.add('idle');
                                        const randomDelay = Math.random() * 3;
                                        element.style.animationDelay = `${randomDelay}s`;
                                    }
                                } else {
                                    element.classList.add('entering');
                                    requestAnimationFrame(() => {
                                        requestAnimationFrame(() => {
                                            setTimeout(() => {
                                                if (element && element.classList.contains('entering')) {
                                                    element.classList.remove('entering');
                                                    const spriteMode = spriteImg._spriteMode || 'circles';
                                                    if (spriteMode !== 'rpg-characters') {
                                                    element.classList.add('idle');
                                                    const randomDelay = Math.random() * 3;
                                                    element.style.animationDelay = `${randomDelay}s`;
                                                    }
                                                }
                                            }, 500);
                                        });
                                    });
                                }
                            }
                        };
                        
                        // Handle successful sprite load - show element with animation
                        spriteImg.onload = showElementWithSprite;
                        
                        shape._spriteImg = spriteImg;
                        shape.appendChild(spriteImg);
                        
                        const randomSeed = Math.floor(Math.random() * 1000000); // Random cache-busting seed
                        
                        // Check if image is already loaded (cached images)
                        const checkImageLoaded = () => {
                            // Use setTimeout to allow browser to set complete/naturalWidth
                            setTimeout(() => {
                                if (spriteImg.complete && spriteImg.naturalWidth > 0 && spriteImg.naturalHeight > 0) {
                                    // Image is already loaded (cached), show immediately
                                    showElementWithSprite();
                                }
                            }, 50); // Increased delay to ensure browser has set the properties
                        };
                        
                        // Load sprite immediately (no delays in update path)
                        const loadSprite = () => {
                            // Check if it's a data URL
                            if (spriteInfo.data.startsWith('data:')) {
                                // SVG data URL - show immediately, avoid onload race
                                if (spriteInfo.data.includes('data:image/svg+xml')) {
                                    spriteImg.onload = null;
                                    spriteImg.src = spriteInfo.data;
                                    spriteImg.style.opacity = '1';
                                    
                                    shape.style.background = 'transparent';
                                    shape.style.backgroundColor = 'transparent';
                                    shape.style.backgroundImage = 'none';
                                    shape.style.border = 'none';
                                    shape.style.outline = 'none';
                                    shape.style.setProperty('border', 'none', 'important');
                                    shape.style.setProperty('outline', 'none', 'important');
                                    
                                    element.style.display = '';
                                    element.style.visibility = 'visible';
                                    element.style.opacity = '1';
                                    element.classList.add('entering');
                                    
                                    setTimeout(() => {
                                        if (element && element.classList.contains('entering')) {
                                            element.classList.remove('entering');
                                            const spriteMode = spriteImg._spriteMode || 'circles';
                                            if (spriteMode !== 'rpg-characters') {
                                                element.classList.add('idle');
                                                const randomDelay = Math.random() * 3;
                                                element.style.animationDelay = `${randomDelay}s`;
                                            }
                                        }
                                    }, 500);
                                    return;
                                }
                                
                                // GIF or other data URL - convert to blob for cache-busting/desync
                                fetch(spriteInfo.data)
                                    .then(response => response.blob())
                                    .then(blob => {
                                        const blobUrl = URL.createObjectURL(blob);
                                        spriteImg.src = blobUrl;
                                        spriteImg._blobUrl = blobUrl;
                                        checkImageLoaded();
                                    })
                                    .catch(error => {
                                        console.error(`[updateUserElement] Failed to convert data URL to blob for ${user.username}:`, error);
                                        spriteImg.src = spriteInfo.data;
                                        checkImageLoaded();
                                    });
                            } else {
                                // For regular URLs, add cache-busting parameters
                                const separator = spriteInfo.data.includes('?') ? '&' : '?';
                                spriteImg.src = spriteInfo.data + separator + 't=' + randomSeed + '&r=' + Date.now();
                                checkImageLoaded();
                            }
                        };
                        
                        // REMOVED: Fallback timeout that was causing circles to appear behind sprites
                        // The timeout was incorrectly triggering onerror() even when sprites loaded successfully
                        // Sprites now either load (via onload) or fail (via onerror) - no artificial timeout
                        // See SPRITE_SYSTEM_REFACTOR.md for the proper architectural solution
                        
                        // Always load immediately
                        loadSprite();
                        
                        // Clear background-image if it exists (from old code)
                        shape.style.backgroundImage = 'none';
                        shape.style.backgroundSize = 'none';
                        shape.style.backgroundPosition = 'none';
                        shape.style.backgroundRepeat = 'none';
                        shape.style.background = 'transparent';
                        shape.style.backgroundColor = 'transparent';
                        shape.style.boxShadow = 'none';
                        shape.style.border = 'none';
                        shape.style.borderRadius = '0';
                        shape.style.overflow = 'visible';
                    } else {
                        // Fallback: no sprite or invalid sprite data
                        // Remove any img element if present
                        const existingImgFallback = shape.querySelector('img');
                        if (existingImgFallback) {
                            existingImgFallback.remove();
                            shape._spriteImg = null;
                        }
                        // Show default colored circle
                        if (viewerColor) {
                            shape.style.backgroundImage = 'none';
                            shape.style.background = `linear-gradient(135deg, ${viewerColor} 0%, ${this.adjustColor(viewerColor, -20)} 100%)`;
                            shape.style.border = '2px solid rgba(255, 255, 255, 0.8)';
                            shape.style.borderRadius = '50%';
                            shape.style.filter = 'none';
                        }
                        // CRITICAL: Show element even if sprite failed - ensure visibility
                        element.style.display = '';
                        element.style.visibility = 'visible';
                        element.style.opacity = '1';
                        element.classList.add('entering');
                        setTimeout(() => {
                            if (element && element.classList.contains('entering')) {
                                element.classList.remove('entering');
                                const spriteMode = this.settings.spriteMode || 'circles';
                                if (spriteMode !== 'rpg-characters') {
                                    element.classList.add('idle');
                                }
                            }
                        }, 500);
                    }
        
                    // Mark as initialized to prevent duplicate event listeners
                    menuBarInitialized = true;
                }

                if (usernameLabel) {
                    // Username position is controlled by CSS variable --name-bubble-offset (set in applyNameBubbleOffset)
                    // Adjust color based on sprite mode
                    const spriteMode = this.settings.spriteMode || 'circles';
    
                    if (spriteMode === 'rpg-characters') {
                        // RPG mode: use Twitch color with black stroke
                        const twitchColor = this.getTwitchColor(user.username, user.userId);
                        usernameLabel.style.color = twitchColor;
                    } else if (spriteMode === 'pixel-morphs') {
                        // MORPH mode: use Twitch color with black stroke
                        const twitchColor = this.getTwitchColor(user.username, user.userId);
                        usernameLabel.style.color = twitchColor;
                    } else {
                        // CIRCLE/CIRCLES mode: use Twitch username color (or hash fallback) like other modes
                        const twitchColor = this.getTwitchColor(user.username, user.userId);
                        usernameLabel.style.color = twitchColor;
                    }
                    // Username z-index and opacity will be updated in positionUserElement
                    // Recheck overlap after color update
                    this.checkUsernameOverlap(usernameLabel, user);

                    // Keep any visible chat bubble anchored to the username position
                    const chatMessage = element.querySelector('.chat-message');
                    if (chatMessage) {
                        try {
                            chatMessage.style.top = window.getComputedStyle(usernameLabel).top;
                            chatMessage.style.zIndex = window.getComputedStyle(usernameLabel).zIndex;
                        } catch (e) { /* ignore */ }
                    }
                }

                // Reposition if angle changed
                this.positionUserElement(user);
            }

            getViewerColor(username, userId) {
                // Try to get viewer color from localStorage
                let viewerColors = {};
                try {
                    const saved = localStorage.getItem('allViewerColors');
                    if (saved) viewerColors = JSON.parse(saved);
                } catch (e) {}

                // Check by userId first, then username
                if (userId && viewerColors[userId]) {
                    return viewerColors[userId].color;
                }

                // Check by username
                for (const key in viewerColors) {
                    if (viewerColors[key].username === username || viewerColors[key].displayName === username) {
                        return viewerColors[key].color;
                    }
                }

                // Return null to use default (Twitch username color would be applied by chat API)
                return null;
            }
            
            getTwitchColor(username, userId) {
                // Prefer real Twitch color when we have it (from tags.color)
                const uidLower = userId ? String(userId).toLowerCase() : '';
                const unameLower = username ? String(username).toLowerCase() : '';
                const u = this.users.find(uu =>
                    (uidLower && uu.userId && String(uu.userId).toLowerCase() === uidLower) ||
                    (unameLower && (uu.username || '').toLowerCase() === unameLower)
                );
                if (u && u.twitchColor && /^#?[0-9A-Fa-f]{6}$/.test(String(u.twitchColor).replace(/^#/, ''))) {
                    const c = String(u.twitchColor);
                    return c.startsWith('#') ? c : '#' + c;
                }
                // Fallback: deterministic hash from username
                let hash = 0;
                const nameToHash = username || '';
                for (let i = 0; i < nameToHash.length; i++) {
                    hash = nameToHash.charCodeAt(i) + ((hash << 5) - hash);
                }
                
                // Convert hash to HSL hue (0-360), then to hex
                const hue = Math.abs(hash % 360);
                const saturation = 70;
                const lightness = 60;
                
                // Convert HSL to RGB to Hex
                const h = hue / 360;
                const s = saturation / 100;
                const l = lightness / 100;
                
                let r, g, b;
                if (s === 0) {
                    r = g = b = l;
                } else {
                    const hue2rgb = (p, q, t) => {
                        if (t < 0) t += 1;
                        if (t > 1) t -= 1;
                        if (t < 1/6) return p + (q - p) * 6 * t;
                        if (t < 1/2) return q;
                        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                        return p;
                    };
                    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                    const p = 2 * l - q;
                    r = hue2rgb(p, q, h + 1/3);
                    g = hue2rgb(p, q, h);
                    b = hue2rgb(p, q, h - 1/3);
                }
                
                const toHex = (n) => {
                    const hex = Math.round(n * 255).toString(16);
                    return hex.length === 1 ? '0' + hex : hex;
                };
                
                return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
            }
            
            getCircleSpriteColor(username, userId) {
                // Get color for circle SPRITES (not usernames)
                // Custom saved color takes precedence, then Twitch color, then default
                
                // First check for saved custom color (only applies to circle sprites)
                let viewerColors = {};
                try {
                    const saved = localStorage.getItem('allViewerColors');
                    if (saved) viewerColors = JSON.parse(saved);
                } catch (e) {}

                // Check by userId first, then username
                if (userId && viewerColors[userId]) {
                    return viewerColors[userId].color;
                }

                // Check by username
                for (const key in viewerColors) {
                    if (viewerColors[key].username === username || viewerColors[key].displayName === username) {
                        return viewerColors[key].color;
                    }
                }
                
                // No saved color - use Twitch color (deterministic hash-based)
                return this.getTwitchColor(username, userId);
            }

            updateUserColor(user) {
                const el = document.getElementById(user.id);
                const shape = el?.querySelector('.shape');
                if (!shape) return;
                const mode = this.settings.spriteMode || 'circle';
                const c = user.color || this.getCircleSpriteColor(user.username, user.userId) || this.getViewerColor(user.username, user.userId) || '#bf94ff';
                if (mode === 'circle' || mode === 'circles') {
                    shape.style.background = `linear-gradient(135deg, ${c} 0%, ${this.adjustColor(c, -20)} 100%)`;
                    shape.style.backgroundImage = shape.style.backgroundImage || 'none';
                } else if (mode === 'pixel-morphs') {
                    shape.style.filter = this.colorToFilter(c);
                }
            }

            updateUserSprite(user) {
                // Sprite changes need to trigger full reload via updateUserElement to:
                // 1) Properly load RPG sprites (which use <img> elements, not backgroundImage)
                // 2) Handle sprite loading with animations
                // 3) Trigger the "entering" animation when sprite changes
                const element = document.getElementById(user.id);
                if (!element) return;
                
                // Store the current state indicators before updating the sprite
                const currentState = user.state;
                const wasSleepy = user.wasSleepy;
                
                // Reload sprite without hiding the whole element; then trigger a swivel animation
                // (prevents "flash" from popIn opacity=0, and keeps username stable).
                this.updateUserElement(user);
                
                // Re-apply the state indicators after the sprite update
                this.updateStateIndicator(element, null, currentState, wasSleepy);
                
                element.classList.remove('swivel');
                void element.offsetWidth;
                element.classList.add('swivel');
                setTimeout(() => {
                    if (element && element.classList.contains('swivel')) element.classList.remove('swivel');
                }, 550);
            }

            updateUsernameTwitchColor(user) {
                const el = document.getElementById(user.id);
                const label = el?.querySelector('.username');
                if (!label) return;
                const c = user.twitchColor && /^#?[0-9A-Fa-f]{6}$/i.test(String(user.twitchColor).replace(/^#/, ''))
                    ? (user.twitchColor.startsWith('#') ? user.twitchColor : '#' + user.twitchColor)
                    : this.getTwitchColor(user.username, user.userId);
                label.style.color = c;
            }

            colorToFilter(color) {
                // Convert hex color to CSS filter for coloring black sprites
                const hex = color.replace('#', '');
                const r = parseInt(hex.substr(0, 2), 16);
                const g = parseInt(hex.substr(2, 2), 16);
                const b = parseInt(hex.substr(4, 2), 16);
                
                // Create filter to colorize black sprite
                return `invert(${r / 255}) sepia(1) saturate(5) hue-rotate(${this.rgbToHue(r, g, b)}deg)`;
            }

            rgbToHue(r, g, b) {
                r /= 255;
                g /= 255;
                b /= 255;
                const max = Math.max(r, g, b);
                const min = Math.min(r, g, b);
                let h = 0;
                
                if (max === min) {
                    h = 0;
                } else if (max === r) {
                    h = ((g - b) / (max - min)) % 6;
                } else if (max === g) {
                    h = (b - r) / (max - min) + 2;
                } else {
                    h = (r - g) / (max - min) + 4;
                }
                
                h = Math.round(h * 60);
                if (h < 0) h += 360;
                return h;
            }

            adjustColor(color, amount) {
                // Simple color adjustment for gradient
                const hex = color.replace('#', '');
                const r = Math.max(0, Math.min(255, parseInt(hex.substr(0, 2), 16) + amount));
                const g = Math.max(0, Math.min(255, parseInt(hex.substr(2, 2), 16) + amount));
                const b = Math.max(0, Math.min(255, parseInt(hex.substr(4, 2), 16) + amount));
                return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
            }

            positionUserElement(user) {
                const element = document.getElementById(user.id);
                if (!element) return;
                // Don't reposition during exit animation
                if (element.classList.contains('leaving')) return;
                
                const angleRad = (user.angle * Math.PI) / 180;
                
                // Use outer ring radius for AFK/LURK users (1.67x normal radius = 200px total - further from campfire)
                const outerRingMultiplier = 1.67;
                const effectiveRadius = user.outerRing ? this.circleRadius * outerRingMultiplier : this.circleRadius;
                
                // NOTE: Container size is now handled by CSS with the outer-ring-scale variable
                // The campfire-area uses 75% of viewport to leave room for outer ring sprites
                // No dynamic expansion needed - this prevents scrollbar issues
                
                // Calculate base circle position (always perfect circle)
                const baseX = Math.cos(angleRad) * effectiveRadius;
                const baseY = Math.sin(angleRad) * effectiveRadius;
                
                // Apply perspective transform ONLY to Y coordinate (not the element itself)
                // angle 0 = no perspective (top-down view)
                // angle 90 = full perspective (side view - Y becomes 0)
                const angleRadTransform = (this.circleAngle * Math.PI) / 180;
                const perspectiveY = baseY * Math.cos(angleRadTransform);
                
                // Center in the campfire area using relative positioning
                // Get the actual container dimensions to calculate center point
                const campfireArea = document.querySelector('.campfire-area');
                const centerX = campfireArea ? campfireArea.offsetWidth / 2 : 150;
                const centerY = campfireArea ? campfireArea.offsetHeight / 2 : 150;
                
                // Get sprite size for proper centering
                const spriteSize = this.settings.spriteSize || 40;
                const spriteOffset = spriteSize / 2; // Half of sprite size for centering
                
                // Adjust vertical position based on view angle for better perspective
                // At 90 degrees (side view), raise sprites up so their feet aren't under the fire
                // Interpolate: 0px at 0¬∞, -7px at 45¬∞, -15px at 90¬∞
                let verticalAdjustment = 0;
                if (this.circleAngle <= 45) {
                    // Linear from 0¬∞ to 45¬∞: 0px to -7px
                    verticalAdjustment = -(this.circleAngle / 45) * 7;
                } else {
                    // Linear from 45¬∞ to 90¬∞: -7px to -15px
                    const progress = (this.circleAngle - 45) / 45; // 0 at 45¬∞, 1 at 90¬∞
                    verticalAdjustment = -7 - (progress * 8); // Start at -7, add -8 more
                }
                
                // Position element using relative container positioning
                // This ensures sprites stay visible regardless of window size
                element.style.left = `${centerX + baseX - spriteOffset}px`;
                element.style.top = `${centerY + perspectiveY - spriteOffset + verticalAdjustment}px`;
                
                // Set z-index based on Y position around the circle
                // Top of circle (baseY = -circleRadius) = furthest back = lowest z-index (5)
                // Bottom of circle (baseY = +circleRadius) = closest/front = highest z-index (24)
                // Z-index increases continuously as you go from top to bottom around the circle
                // This ensures correct layering: sprites closer to bottom are always in front
                const minZIndex = 5; // Furthest back (top of circle)
                const maxZIndex = 24; // Closest/front (bottom of circle)
                const zIndexRange = maxZIndex - minZIndex;
                
                // Normalize baseY from -circleRadius (top) to +circleRadius (bottom) to 0-1
                // Then map to z-index range
                // For outer ring users, use effectiveRadius for normalization
                const radiusForNormalization = user.outerRing ? effectiveRadius : this.circleRadius;
                const normalizedY = (baseY + radiusForNormalization) / (2 * radiusForNormalization); // 0 to 1
                let zIndex = minZIndex + Math.floor(normalizedY * zIndexRange);
                
                // CRITICAL FIX: Outer ring sprites at the top need higher z-index to appear above menu bar
                // Menu bar has z-index 999999, so we need to boost outer ring sprites at top
                // Only boost when sprite is in the "danger zone" (top 30% of outer ring, angles ~240-300¬∞)
                if (user.outerRing && normalizedY < 0.3) {
                    // Boost z-index to be above menu bar (which is 999999)
                    // Use 1000000 + original z-index to maintain relative ordering
                    zIndex = 1000000 + zIndex;
                }
                
                element.style.zIndex = zIndex;
                
                // Also set class for campfire layering (sprites behind campfire need lower z-index than fire)
                // Campfire is at z-index 10-11, so sprites with z-index < 10 are behind it
                if (zIndex < 10) {
                    element.classList.remove('front-layer');
                    element.classList.add('back-layer');
                } else {
                    element.classList.remove('back-layer');
                    element.classList.add('front-layer');
                }
                
                // Apply perspective-based scaling to sprite
                // When perspective is top-down (scaleY = 1), no scaling difference
                // When perspective is side-view (scaleY = 0), maximum scaling difference
                // Top sprites (baseY < 0) are smaller, bottom sprites (baseY > 0) are larger
                const scaleY = Math.cos(angleRadTransform);
                const perspectiveFactor = 1 - scaleY; // 0 when top-down, 1 when side-view
                const scaleAmount = 0.17; // 17% size difference at maximum perspective
                
                // baseY ranges from -1 (top) to +1 (bottom)
                // Calculate scale multiplier: 1 + (perspectiveFactor * baseY * scaleAmount)
                // Top (baseY = -1): 1 - (perspectiveFactor * scaleAmount) = smaller
                // Bottom (baseY = +1): 1 + (perspectiveFactor * scaleAmount) = larger
                // Sides (baseY = 0): 1 = normal size
                // For outer ring users, normalize using effectiveRadius to keep values in -1 to +1 range
                const normalizedBaseY = baseY / effectiveRadius; // Normalize to -1 to +1
                
                // Outer ring users (AFK/LURK) get additional scaling reduction since they're "further back"
                // This makes them appear smaller, reinforcing the perspective effect
                const outerRingScaleReduction = user.outerRing ? 0.85 : 1.0; // 15% smaller for outer ring
                const scaleMultiplier = (1 + (perspectiveFactor * normalizedBaseY * scaleAmount)) * outerRingScaleReduction;
                
                // Apply scaling to the shape element, combining with flip if needed
                const shape = element.querySelector('.shape');
                if (shape) {
                    // Check if sprite is flipped (for movement direction)
                    const isFlipped = shape.classList.contains('flipped');
                    const flipDirection = isFlipped ? -1 : 1;
                    
                    // Combine perspective scale with flip: scaleX handles flip, scaleY handles perspective
                    shape.style.transform = `scaleX(${flipDirection * scaleMultiplier}) scaleY(${scaleMultiplier})`;
                }
                
                // Update username z-index and opacity to match sprite layering
                const usernameLabel = element.querySelector('.username');
                if (usernameLabel) {
                    // Username z-index should match sprite z-index (so they layer together)
                    usernameLabel.style.zIndex = zIndex.toString();

                    const chatMessage = element.querySelector('.chat-message');
                    const hasChatBubble = !!chatMessage;

                    // If a chat bubble is visible, keep username hidden so it never shows "behind" the bubble.
                    if (hasChatBubble) {
                        usernameLabel.style.opacity = '0';
                    } else {
                        // Usernames get darker as they go backward (top of circle)
                        // Top of circle (baseY = -circleRadius) = darkest (0.5 opacity)
                        // Bottom of circle (baseY = +circleRadius) = brightest (1.0 opacity)
                        const opacityRange = 0.5; // 0.5 to 1.0
                        const minOpacity = 0.5;
                        const usernameOpacity = minOpacity + (normalizedY * opacityRange);
                        usernameLabel.style.opacity = usernameOpacity.toString();
                        this.checkUsernameOverlap(usernameLabel, user);
                    }

                    // Keep chat bubble aligned with username if visible
                    if (chatMessage) {
                        chatMessage.style.zIndex = zIndex.toString();
                        try {
                            chatMessage.style.top = window.getComputedStyle(usernameLabel).top;
                        } catch (e) { /* ignore */ }
                    }
                }
            }
            
            checkUsernameOverlap(usernameLabel, user) {
                // Check if username is too close to sprite center (overlapping)
                // Username is positioned at top: -25px, so if user is at top of circle,
                // username might overlap with sprite
                const element = document.getElementById(user.id);
                if (!element) return;
                // If a chat bubble is showing, never override username opacity (bubble controls it).
                if (element.querySelector('.chat-message')) return;
                
                // Get the angle - if user is near top (angle 270 or -90 degrees), username overlaps
                const angle = user.angle;
                // Check if angle is in the top quadrant (270¬∞ ¬± 45¬∞ or -90¬∞ ¬± 45¬∞)
                const normalizedAngle = ((angle % 360) + 360) % 360;
                const isTopQuadrant = (normalizedAngle >= 225 && normalizedAngle <= 315);
                
                // Also check vertical position - if user is high on screen, username might overlap
                const rect = element.getBoundingClientRect();
                const shapeRect = element.querySelector('.shape')?.getBoundingClientRect();
                
                if (shapeRect && usernameLabel) {
                    const usernameRect = usernameLabel.getBoundingClientRect();
                    // Check if username bottom overlaps with sprite top
                    const overlap = usernameRect.bottom > shapeRect.top;
                    
                    if (isTopQuadrant || overlap) {
                        // Make username more transparent when overlapping
                        usernameLabel.style.opacity = '0.7';
                    } else {
                        usernameLabel.style.opacity = '1';
                    }
                }
            }

            repositionUsers() {
                this.users.forEach(user => {
                    this.positionUserElement(user);
                });
            }

            updateAllUsernamePositions() {
                // Username positions are now controlled by CSS variable --name-bubble-offset
                // Just call applyNameBubbleOffset to update the CSS variable
                this.applyNameBubbleOffset();
            }

            removeUserElement(userId) {
                const element = document.getElementById(userId);
                if (element) {
                    // Clean up blob URLs to prevent memory leaks
                    const spriteImg = element.querySelector('img');
                    if (spriteImg && spriteImg._blobUrl) {
                        URL.revokeObjectURL(spriteImg._blobUrl);
                    }
                    
                    // Remove any existing animation classes
                    element.classList.remove('entering', 'idle', 'moving');
                    
                    // Stop any transitions that might interfere with exit animation
                    element.style.transition = 'none';
                    
                    // Calculate lift distance based on sprite size for better visual effect
                    // Larger sprites need more lift distance, smaller sprites need less
                    const spriteSize = this.settings.spriteSize || 40;
                    // Base lift is 40px, scale it proportionally to sprite size
                    // For 40px sprite: 40px lift, for 80px sprite: 80px lift, etc.
                    const liftDistance = Math.max(30, spriteSize); // Minimum 30px, scales with size
                    
                    // Set CSS variable for the animation to use
                    element.style.setProperty('--lift-distance', `-${liftDistance}px`);
                    
                    // Preserve the current transform scale from perspective positioning
                    const shape = element.querySelector('.shape');
                    if (shape) {
                        // Get the current transform values (scaleX and scaleY from perspective)
                        const currentTransform = shape.style.transform;
                        if (currentTransform) {
                            // Extract scale values
                            const scaleXMatch = currentTransform.match(/scaleX\(([^)]+)\)/);
                            const scaleYMatch = currentTransform.match(/scaleY\(([^)]+)\)/);
                            
                            if (scaleXMatch && scaleYMatch) {
                                const scaleX = scaleXMatch[1];
                                const scaleY = scaleYMatch[1];
                                // Store scale values as CSS variables for the animation to use
                                element.style.setProperty('--exit-scaleX', scaleX);
                                element.style.setProperty('--exit-scaleY', scaleY);
                            }
                        }
                    }
                    
                    // Random delay (0-250ms) to stagger animations when multiple users leave at once
                    // This creates a more natural, less synchronized effect
                    const randomDelay = Math.random() * 250;
                    
                    // Add leaving animation after random delay - gentle lift up and fade out
                    // This works consistently for all sprite types (RPG, morphs, circles)
                    setTimeout(() => {
                        if (element && element.parentNode) {
                            element.classList.add('leaving');
                        }
                    }, randomDelay);
                    
                    // Remove element after animation completes (600ms animation + random delay)
                    setTimeout(() => {
                        if (element && element.parentNode) {
                            element.remove();
                        }
                    }, 600 + randomDelay);
                }
            }

            removeUser(username) {
                // Use case-insensitive comparison for usernames (Twitch usernames are case-insensitive)
                const normalizedUsername = username ? username.toLowerCase() : '';
                const index = this.users.findIndex(u => {
                    const uNameLower = u.username ? u.username.toLowerCase() : '';
                    const uIdLower = u.userId ? String(u.userId).toLowerCase() : '';
                    return uNameLower === normalizedUsername || uIdLower === normalizedUsername;
                });
                if (index !== -1) {
                    const user = this.users[index];
                    this.users.splice(index, 1);
                    this.removeUserElement(user.id);
                    // Do NOT reposition remaining users; keep their angles stable.
                    // Note: User persistence disabled
                    console.log(`[removeUser] Removed user: ${user.username} (userId: ${user.userId})`);
                    
                    // Play leave sound
                    audioManager.playSound('leave');
                }
            }
            
            removeUserById(userId) {
                // Use case-insensitive comparison for userId (Twitch userIds are case-insensitive)
                const normalizedUserId = userId ? String(userId).toLowerCase() : '';
                const index = this.users.findIndex(u => {
                    const uIdLower = u.userId ? String(u.userId).toLowerCase() : '';
                    const uNameLower = u.username ? u.username.toLowerCase() : '';
                    return uIdLower === normalizedUserId || uNameLower === normalizedUserId;
                });
                if (index !== -1) {
                    const user = this.users[index];
                    this.users.splice(index, 1);
                    this.removeUserElement(user.id);
                    // Do NOT reposition remaining users; keep their angles stable.
                    // Note: User persistence disabled
                    console.log(`[removeUserById] Removed user: ${user.username} (userId: ${user.userId})`);
                    
                    // Play leave sound
                    audioManager.playSound('leave');
                }
            }

            updateSettings(newSettings) {
                // Prevent infinite loop - if we're already updating, skip
                if (this._updatingSettings) {
                    return;
                }
                this._updatingSettings = true;
                
                try {
                    // Store old settings for comparison
                    const oldSettings = { ...this.settings };
                    
                    this.settings = { ...this.settings, ...newSettings };
                    
                    // Update audio manager with new audio settings
                    if (newSettings.audioSettings) {
                        audioManager.updateSettings(newSettings.audioSettings);
                    }
                    
                    // Update user state settings
                    if (newSettings.userStates !== undefined) {
                        if (newSettings.userStates && newSettings.userStates.enabled) {
                            this.startUserStateUpdates();
                        } else {
                            this.stopUserStateUpdates();
                            // Clear all state classes from users
                            this.users.forEach(user => {
                                const element = document.getElementById(user.id);
                                if (element) {
                                    element.classList.remove('state-active', 'state-joined', 'state-sleepy', 'state-afk');
                                }
                            });
                        }
                    }
                    
                    // Update sprite mode class on container for CSS targeting
                    if (newSettings.spriteMode !== undefined) {
                        const container = document.getElementById('circleContainer');
                        if (container) {
                            // Remove all sprite-mode classes
                            container.classList.remove('sprite-mode-circles', 'sprite-mode-circle', 'sprite-mode-rpg-characters', 'sprite-mode-pixel-morphs', 'sprite-mode-custom');
                            // Add current sprite mode class
                            container.classList.add(`sprite-mode-${newSettings.spriteMode}`);
                        }
                    }
                    
                    // Always reload sprite data from localStorage (in case it was updated)
                    const defaultSprite = localStorage.getItem('defaultSpriteData');
                    const customSprite = localStorage.getItem('customSpriteData');
                    if (defaultSprite) this.settings.defaultSpriteData = defaultSprite;
                    if (customSprite) this.settings.customSpriteData = customSprite;
                    
                    // Only save to localStorage if settings actually changed (prevent loop)
                    const settingsChanged = JSON.stringify(oldSettings) !== JSON.stringify(this.settings);
                    if (settingsChanged) {
                        localStorage.setItem('campfireWidgetSettings', JSON.stringify(this.settings));
                    }
                    
                    // Update widget based on new settings
                    if (newSettings.circleAngle !== undefined && newSettings.circleAngle !== oldSettings.circleAngle) {
                        this.circleAngle = newSettings.circleAngle;
                        this.updateCircleTransform();
                    }

                    if (newSettings.campfireYOffset !== undefined && newSettings.campfireYOffset !== oldSettings.campfireYOffset) {
                        this.applyCampfireYOffset();
                    }

                    if (newSettings.nameBubbleOffset !== undefined && newSettings.nameBubbleOffset !== oldSettings.nameBubbleOffset) {
                        this.applyNameBubbleOffset();
                        // Update username label positions for all existing users
                        this.updateAllUsernamePositions();
                    }
                    if (newSettings.nameBubbleOffsets !== undefined) {
                        this.applyNameBubbleOffset();
                    }
                    if (newSettings.chatBubbleSize !== undefined && newSettings.chatBubbleSize !== oldSettings.chatBubbleSize) {
                        this.applyChatBubbleSize();
                    }
                    if (newSettings.chatBubbleSizes !== undefined) {
                        this.applyChatBubbleSize();
                    }
                    
                    // Status icon position
                    if (newSettings.statusIconTop !== undefined || newSettings.statusIconRight !== undefined) {
                        this.applyStatusIconPosition();
                    }

                    if (newSettings.widgetBackground !== undefined && newSettings.widgetBackground !== oldSettings.widgetBackground) {
                        this.applyWidgetBackground();
                    }

                    if (newSettings.useNativeFrame !== undefined && newSettings.useNativeFrame !== oldSettings.useNativeFrame) {
                        this.applyNativeFrameMode();
                    }

                    if (newSettings.hideNameplates !== undefined && newSettings.hideNameplates !== oldSettings.hideNameplates) {
                        this.applyHideNameplates();
                    }
                    
                    if (newSettings.fireSize !== undefined && newSettings.fireSize !== oldSettings.fireSize) {
                        // Update fire size without recreating the entire graphic (prevents flickering)
                        const fireSize = this.settings.fireSize || 48;
                        
                        // Update default emoji fire if it exists
                        const fireEmoji = document.getElementById('campfireEmoji');
                        if (fireEmoji) {
                            // Use requestAnimationFrame to ensure smooth update without flicker
                            requestAnimationFrame(() => {
                                fireEmoji.style.fontSize = `${fireSize}px`;
                            });
                        }
                        
                        // Update custom fire graphics (img or video) if they exist
                        const container = document.getElementById('campfireGraphic');
                        if (container) {
                            const customImg = container.querySelector('img');
                            const customVideo = container.querySelector('video');
                            
                            if (customImg) {
                                requestAnimationFrame(() => {
                                    customImg.style.width = `${fireSize}px`;
                                    customImg.style.height = `${fireSize}px`;
                                });
                            }
                            if (customVideo) {
                                requestAnimationFrame(() => {
                                    customVideo.style.width = `${fireSize}px`;
                                    customVideo.style.height = `${fireSize}px`;
                                });
                            }
                        }
                    }
                    
                    // Sprite size update is handled separately below (line ~3027) to avoid duplicate code
                    
                    // Handle animated glow setting change
                    if (newSettings.animatedGlow !== undefined && newSettings.animatedGlow !== oldSettings.animatedGlow) {
                        if (this.settings.animatedGlow && !this.animationFrame) {
                            // Start animation if it was just enabled
                            this.startGlowAnimation();
                        } else if (!this.settings.animatedGlow && this.animationFrame) {
                            // Stop animation if it was just disabled
                            cancelAnimationFrame(this.animationFrame);
                            this.animationFrame = null;
                        }
                    }
                    
                    // Only recreate campfire graphic if relevant settings ACTUALLY changed (compare old vs new)
                    const campfireGraphicChanged = (newSettings.campfireGraphicUrl !== undefined && newSettings.campfireGraphicUrl !== oldSettings.campfireGraphicUrl) ||
                        (newSettings.campfireGraphicData !== undefined && newSettings.campfireGraphicData !== oldSettings.campfireGraphicData) ||
                        (newSettings.hideCampfireGraphic !== undefined && newSettings.hideCampfireGraphic !== oldSettings.hideCampfireGraphic);
                    const glowSettingsChanged = (newSettings.glowSize !== undefined && newSettings.glowSize !== oldSettings.glowSize) ||
                        (newSettings.glowIntensity !== undefined && newSettings.glowIntensity !== oldSettings.glowIntensity) ||
                        (newSettings.shadowIntensity !== undefined && newSettings.shadowIntensity !== oldSettings.shadowIntensity) ||
                        (newSettings.glowSpread !== undefined && newSettings.glowSpread !== oldSettings.glowSpread) ||
                        (newSettings.flickerOpacity !== undefined && newSettings.flickerOpacity !== oldSettings.flickerOpacity) ||
                        (newSettings.flickerSpread !== undefined && newSettings.flickerSpread !== oldSettings.flickerSpread) ||
                        (newSettings.flickerSize !== undefined && newSettings.flickerSize !== oldSettings.flickerSize);
                    
                    if (campfireGraphicChanged || glowSettingsChanged) {
                        // Stop existing animation if glow settings changed
                        if (this.animationFrame) {
                            cancelAnimationFrame(this.animationFrame);
                            this.animationFrame = null;
                        }
                        this.setupCampfireGraphic();
                        // Restart animation if it was enabled
                        if (this.settings.animatedGlow !== false) {
                            this.startGlowAnimation();
                        }
                    }
                    
                    // Update sprites ONLY if sprite-related settings are explicitly in newSettings
                    // Don't enter this block if only non-sprite settings (like maxUsers, spriteSize) changed
                    const hasSpriteSettings = newSettings.defaultSpriteData !== undefined ||
                        newSettings.customSpriteData !== undefined ||
                        newSettings.spriteMode !== undefined ||
                        newSettings.shadowSprites !== undefined ||
                        newSettings.rpgSprites !== undefined ||
                        newSettings.morphSprites !== undefined;
                    
                    if (hasSpriteSettings) {
                            
                            // Track if sprite collections were updated (to know if we need to refresh user sprites)
                            let spriteCollectionsUpdated = false;
                            
                            // Use sprite collections from newSettings if provided, otherwise reload from localStorage
                            if (newSettings.shadowSprites !== undefined) {
                            // Check if collection actually changed (not just empty array)
                            const oldCount = (this.settings.shadowSprites || []).length;
                            const newCount = (newSettings.shadowSprites || []).length;
                            if (newCount > oldCount || (oldCount === 0 && newCount > 0)) {
                                spriteCollectionsUpdated = true;
                            }
                            // Use provided sprite collection and save to localStorage
                            this.settings.shadowSprites = Array.isArray(newSettings.shadowSprites) ? newSettings.shadowSprites : [];
                            try {
                                localStorage.setItem('shadowSprites', JSON.stringify(this.settings.shadowSprites));
                            } catch (e) {
                                console.warn('Could not save shadowSprites to localStorage:', e);
                            }
                        } else {
                            // Reload from localStorage
                            const shadowSprites = localStorage.getItem('shadowSprites');
                            if (shadowSprites) {
                                try {
                                    this.settings.shadowSprites = JSON.parse(shadowSprites);
                                    if (!Array.isArray(this.settings.shadowSprites)) {
                                        this.settings.shadowSprites = [];
                                    }
                                } catch (e) {
                                    console.error('Error parsing shadowSprites:', e);
                                    this.settings.shadowSprites = [];
                                }
                            } else {
                                this.settings.shadowSprites = [];
                            }
                        }
                        
                        if (newSettings.rpgSprites !== undefined) {
                            // Check if collection actually changed (not just empty array)
                            const oldCount = (this.settings.rpgSprites || []).length;
                            const newCount = (newSettings.rpgSprites || []).length;
                            if (newCount > oldCount || (oldCount === 0 && newCount > 0)) {
                                spriteCollectionsUpdated = true;
                            }
                            // Use provided sprite collection and save to localStorage
                            this.settings.rpgSprites = Array.isArray(newSettings.rpgSprites) ? newSettings.rpgSprites : [];
                            try {
                                localStorage.setItem('rpgSprites', JSON.stringify(this.settings.rpgSprites));
                            } catch (e) {
                                console.warn('Could not save rpgSprites to localStorage:', e);
                            }
                        } else {
                            // Reload from localStorage
                            const rpgSprites = localStorage.getItem('rpgSprites');
                            if (rpgSprites) {
                                try {
                                    this.settings.rpgSprites = JSON.parse(rpgSprites);
                                    if (!Array.isArray(this.settings.rpgSprites)) {
                                        this.settings.rpgSprites = [];
                                    }
                                } catch (e) {
                                    console.error('Error parsing rpgSprites:', e);
                                    this.settings.rpgSprites = [];
                                }
                            } else {
                                this.settings.rpgSprites = [];
                            }
                        }
                        
                        if (newSettings.morphSprites !== undefined) {
                            // Check if collection actually changed (not just empty array)
                            const oldCount = (this.settings.morphSprites || []).length;
                            const newCount = (newSettings.morphSprites || []).length;
                            if (newCount > oldCount || (oldCount === 0 && newCount > 0)) {
                                spriteCollectionsUpdated = true;
                            }
                            // Use provided sprite collection and save to localStorage
                            this.settings.morphSprites = Array.isArray(newSettings.morphSprites) ? newSettings.morphSprites : [];
                            try {
                                localStorage.setItem('morphSprites', JSON.stringify(this.settings.morphSprites));
                            } catch (e) {
                                console.warn('Could not save morphSprites to localStorage:', e);
                            }
                        } else {
                            // Reload from localStorage
                            const morphSprites = localStorage.getItem('morphSprites');
                            if (morphSprites) {
                                try {
                                    this.settings.morphSprites = JSON.parse(morphSprites);
                                    if (!Array.isArray(this.settings.morphSprites)) {
                                        this.settings.morphSprites = [];
                                    }
                                } catch (e) {
                                    console.error('Error parsing morphSprites:', e);
                                    this.settings.morphSprites = [];
                                }
                            } else {
                                this.settings.morphSprites = [];
                            }
                        }
                        
                        // Debug: Log sprite collection status (only when collections actually change)
                        // Removed constant logging to prevent console spam
                        
                        // Only update sprites if sprite mode ACTUALLY changed (not just reloaded)
                        // OR if sprite collections were newly loaded (were empty, now have sprites)
                        // Don't update sprites if only size settings changed
                        const spriteModeChanged = newSettings.spriteMode !== undefined && 
                                                 newSettings.spriteMode !== oldSettings.spriteMode;
                        const defaultSpriteChanged = newSettings.defaultSpriteData !== undefined && 
                                                     newSettings.defaultSpriteData !== oldSettings.defaultSpriteData;
                        const customSpriteChanged = newSettings.customSpriteData !== undefined && 
                                                   newSettings.customSpriteData !== oldSettings.customSpriteData;
                        
                        // Only update user elements if sprite mode or collections ACTUALLY changed
                        // Don't update if we're just reloading from localStorage with the same data
                        if (spriteModeChanged || defaultSpriteChanged || customSpriteChanged || spriteCollectionsUpdated) {
                            // Update all user elements to apply new sprites (without re-adding entering animation)
                            this.users.forEach(user => {
                                const element = document.getElementById(user.id);
                                if (element) {
                                    // Only clear and reload sprites if collections actually changed
                                    if (spriteCollectionsUpdated && user.spritesByMode) {
                                        const currentMode = this.settings.spriteMode || 'circle';
                                        delete user.spritesByMode[currentMode];
                                        // Clear existing sprite img element to force reload
                                        const shape = element.querySelector('.shape');
                                        if (shape) {
                                            const existingImg = shape.querySelector('img');
                                            if (existingImg) {
                                                existingImg.remove();
                                                shape._spriteImg = null;
                                            }
                                            // Clear any background that might be showing
                                            shape.style.background = 'transparent';
                                            shape.style.backgroundImage = 'none';
                                        }
                                    }
                                    
                                    // For sprite mode changes only (no collection changes): swap sprite smoothly without hiding
                                    // For collection/default/custom changes: use updateUserElement (full reload needed)
                                    if (spriteModeChanged && !spriteCollectionsUpdated && !defaultSpriteChanged && !customSpriteChanged) {
                                        // Only mode changed - swap sprite smoothly
                                        const shape = element.querySelector('.shape');
                                        if (shape) {
                                            // Get sprite for new mode (getUserSprite handles spritesByMode lookup)
                                            const spriteInfo = this.getUserSprite(user);
                                            if (spriteInfo && spriteInfo.data) {
                                                // Remove old sprite img
                                                const existingImg = shape.querySelector('img');
                                                if (existingImg) {
                                                    // Clean up blob URL if it exists
                                                    if (existingImg._blobUrl) {
                                                        URL.revokeObjectURL(existingImg._blobUrl);
                                                    }
                                                    existingImg.remove();
                                                    shape._spriteImg = null;
                                                }
                                                
                                                // Clear background
                                                shape.style.background = 'transparent';
                                                shape.style.backgroundColor = 'transparent';
                                                shape.style.backgroundImage = 'none';
                                                shape.style.border = 'none';
                                                shape.style.borderRadius = '0';
                                                
                                                // Create new sprite img
                                                const spriteImg = document.createElement('img');
                                                spriteImg.style.width = '100%';
                                                spriteImg.style.height = '100%';
                                                spriteImg.style.objectFit = 'contain';
                                                spriteImg.style.objectPosition = 'center';
                                                spriteImg.style.display = 'block';
                                                
                                                // Apply colorization if needed
                                                if (spriteInfo.colorize && spriteInfo.color) {
                                                    spriteImg.style.filter = `brightness(0) saturate(100%) ${this.colorToFilter(spriteInfo.color)}`;
                                                } else {
                                                    spriteImg.style.filter = 'none';
                                                }
                                                
                                                // Store references for error handling
                                                spriteImg._element = element;
                                                spriteImg._shape = shape;
                                                spriteImg._user = user;
                                                
                                                // Handle successful load - sprite should show immediately
                                                spriteImg.onload = () => {
                                                    spriteImg.style.opacity = '1';
                                                    shape.style.background = 'transparent';
                                                    shape.style.border = 'none';
                                                };
                                                
                                                // Handle errors - show fallback
                                                spriteImg.onerror = () => {
                                                    console.error(`[swapSprite] Failed to load sprite for ${user.username}`);
                                                    spriteImg.remove();
                                                    shape._spriteImg = null;
                                                    // Show fallback circle
                                                    const viewerColor = user.color || this.getViewerColor(user.username, user.userId);
                                                    shape.style.background = `linear-gradient(135deg, ${viewerColor || '#667eea'} 0%, ${this.adjustColor(viewerColor || '#667eea', -20)} 100%)`;
                                                    shape.style.border = '2px solid rgba(255, 255, 255, 0.8)';
                                                    shape.style.borderRadius = '50%';
                                                    shape.style.filter = 'none';
                                                };
                                                
                                                // Set src and append
                                                spriteImg.src = spriteInfo.data;
                                                shape._spriteImg = spriteImg;
                                                shape.appendChild(spriteImg);
                                                
                                                // Add swivel animation when sprite mode changes (no opacity flash)
                                                element.classList.remove('swivel');
                                                void element.offsetWidth;
                                                element.classList.add('swivel');
                                                setTimeout(() => {
                                                    if (element && element.classList.contains('swivel')) {
                                                        element.classList.remove('swivel');
                                                    }
                                                }, 550);
                                                
                                                // Update username position based on new mode
                                                const usernameLabel = element.querySelector('.username');
                                                if (usernameLabel) {
                                                    // Username position is controlled by CSS variable --name-bubble-offset
                                                    // Just update the color based on sprite mode
                                                    const newMode = this.settings.spriteMode || 'circle';

                                                    if (newMode === 'rpg-characters') {
                                                        const twitchColor = this.getTwitchColor(user.username, user.userId);
                                                        usernameLabel.style.color = twitchColor;
                                                    } else if (newMode === 'pixel-morphs') {
                                                        const twitchColor = this.getTwitchColor(user.username, user.userId);
                                                        usernameLabel.style.color = twitchColor;
                                                    } else {
                                                        const twitchColor = this.getTwitchColor(user.username, user.userId);
                                                        usernameLabel.style.color = twitchColor;
                                                    }
                                                    this.checkUsernameOverlap(usernameLabel, user);
                                                }
                                            } else {
                                                // No sprite found - fallback to circle
                                                console.warn(`[swapSprite] No sprite found for ${user.username} in mode ${this.settings.spriteMode}, using fallback`);
                                                const existingImg = shape.querySelector('img');
                                                if (existingImg) {
                                                    if (existingImg._blobUrl) {
                                                        URL.revokeObjectURL(existingImg._blobUrl);
                                                    }
                                                    existingImg.remove();
                                                    shape._spriteImg = null;
                                                }
                                                const viewerColor = user.color || this.getViewerColor(user.username, user.userId);
                                                shape.style.background = `linear-gradient(135deg, ${viewerColor || '#667eea'} 0%, ${this.adjustColor(viewerColor || '#667eea', -20)} 100%)`;
                                                shape.style.border = '2px solid rgba(255, 255, 255, 0.8)';
                                                shape.style.borderRadius = '50%';
                                                shape.style.filter = 'none';
                                            }
                                        }
                                    } else {
                                        // Collections/default/custom changed - need full reload via updateUserElement
                                        this.updateUserElement(user);
                                    }
                                }
                            });
                        }
                    }
                    
                    // Update sprite sizes and positions if spriteSize or fireSize changed
                    if (newSettings.spriteSize !== undefined || newSettings.fireSize !== undefined) {
                        this.users.forEach(user => {
                            const element = document.getElementById(user.id);
                            if (element) {
                                // Update size and position without changing sprite
                                const shape = element.querySelector('.shape');
                                if (newSettings.spriteSize !== undefined) {
                                    const spriteSize = newSettings.spriteSize;
                                    element.style.width = `${spriteSize}px`;
                                    element.style.height = `${spriteSize}px`;
                                    if (shape) {
                                        shape.style.width = `${spriteSize}px`;
                                        shape.style.height = `${spriteSize}px`;
                                    }
                                }
                                // Reposition to account for new sprite size
                                this.positionUserElement(user);
                                // Ensure username stays centered after size change
                                const usernameLabel = element.querySelector('.username');
                                if (usernameLabel) {
                                    // Force center alignment - ensure left and transform are set correctly
                                    usernameLabel.style.left = '50%';
                                    usernameLabel.style.transform = 'translateX(-50%)';
                                    this.checkUsernameOverlap(usernameLabel, user);
                                }
                            }
                        });
                    }
                    
                    if (newSettings.maxUsers !== undefined) {
                        this.maxUsers = newSettings.maxUsers;
                    }
                    
                    if (newSettings.spriteDefaultDirections !== undefined) {
                        this.settings.spriteDefaultDirections = newSettings.spriteDefaultDirections;
                    }
                    if (newSettings.spriteDefaultDirection !== undefined) {
                        this.settings.spriteDefaultDirection = newSettings.spriteDefaultDirection;
                        // Update all existing sprites to reflect new default direction
                        // Sprites will flip correctly on next movement, but we could also update them immediately
                        // For now, just update the setting - sprites will use new direction on next flip
                    }
                    
                    // Handle test users toggle
                    if (newSettings.showTestUsers !== undefined) {
                        if (newSettings.showTestUsers === false) {
                            // Remove ONLY locally-generated mock users (not IPC-driven test users)
                            const testUsers = this.users.filter(u =>
                                u &&
                                u.username &&
                                u.username.startsWith('TestUser') &&
                                (u.source === 'mock' || String(u.userId || '') === String(u.username || ''))
                            );
                            testUsers.forEach(user => {
                                this.removeUser(user.username);
                            });
                            // Don't stop random movement when test users are removed
                            // Random movement should continue for all users (including real users)
                            // Only stop if explicitly disabled via settings
                        } else if (newSettings.showTestUsers === true) {
                            // Add test users if toggle is turned on and they don't exist
                            const hasTestUsers = this.users.some(u =>
                                u &&
                                u.username &&
                                u.username.startsWith('TestUser') &&
                                (u.source === 'mock' || String(u.userId || '') === String(u.username || ''))
                            );
                            if (!hasTestUsers && !this._settingUpMockUsers) {
                                this.setupMockUsers();
                            }
                        }
                    }
                } finally {
                    // Always clear the updating flag, even if an error occurred
                    this._updatingSettings = false;
                }
            }

            // Mock users for testing (remove in production)
            setupMockUsers() {
                // Prevent multiple simultaneous calls
                if (this._settingUpMockUsers) {
                    return;
                }
                this._settingUpMockUsers = true;
                
                // Check if test users already exist - if so, don't add them again
                const hasTestUsers = this.users.some(u =>
                    u &&
                    u.username &&
                    u.username.startsWith('TestUser') &&
                    (u.source === 'mock' || String(u.userId || '') === String(u.username || ''))
                );
                if (hasTestUsers) {
                    this._settingUpMockUsers = false;
                    return;
                }
                
                console.log('setupMockUsers() called');
                // Add a few test users with consistent userIds
                console.log('Scheduling test users to be added...');
                setTimeout(() => {
                    console.log('Adding TestUser1...');
                    this.addUser('TestUser1', { userId: 'TestUser1', source: 'mock' });
                }, 500);
                setTimeout(() => {
                    console.log('Adding TestUser2...');
                    this.addUser('TestUser2', { userId: 'TestUser2', source: 'mock' });
                }, 1000);
                setTimeout(() => {
                    console.log('Adding TestUser3...');
                    this.addUser('TestUser3', { userId: 'TestUser3', source: 'mock' });
                    // Clear the flag after all users are scheduled
                    this._settingUpMockUsers = false;
                }, 1500);
                
                // Random movement is now started in init() for all users
                // No need to start it here - it's already running
                
                // Start glow animation if enabled (only if not already started)
                if (this.settings.animatedGlow !== false && !this.animationFrame) {
                    console.log('Starting glow animation...');
                    this.startGlowAnimation();
                } else if (this.settings.animatedGlow === false) {
                    console.log('Glow animation disabled');
                }
            }

            startRandomMovement() {
                // Prevent multiple intervals from being created
                if (this.randomMovementInterval) {
                    return; // Already running
                }
                
                // Randomly move non-active users around the campfire (NPC movement)
                // Active users = users with their viewer dashboard open (activeViewer in localStorage)
                // When dashboard is open, user controls their sprite with arrow keys (no NPC movement)
                // When dashboard closes, activeViewer is cleared and NPC movement automatically resumes
                this.randomMovementInterval = setInterval(() => {
                    this.users.forEach(user => {
                        const isActiveUser = this.isActiveUser(user);
                        const isLurkUser = user.state === 'lurk';
                        
                        // SLEEPY and AFK users should ALWAYS be STILL (enforce this every tick)
                        // This ensures they don't wander even if still flag wasn't set properly
                        // Note: LURK users CAN wander (with reduced distance)
                        if ((user.state === 'sleepy' || user.state === 'afk') && !user.still) {
                            user.still = true;
                            user.stillMode = true;
                            user.roaming = false;
                            const element = document.getElementById(user.id);
                            if (element) {
                                element.classList.remove('roaming');
                                element.classList.add('still');
                            }
                        }

                        // LURK users can roam - ensure they're not marked as still
                        if (isLurkUser && user.still && !user.manualStill) {
                            user.still = false;
                            user.stillMode = false;
                            user.roaming = true;
                            user.wander = false;
                        }

                        if (user.still && !isLurkUser) {
                            // !still command or SLEEPY/AFK: No movement, but random direction flips
                            if (Math.random() < 0.15) { // 15% chance every 3 seconds (~20-30 sec intervals)
                                const direction = Math.random() < 0.5 ? -1 : 1;
                                this.flipSprite(user.id, direction);
                            }
                        } else if (!isActiveUser || user.state === 'lurk') {
                            // State-first movement logic: LURK ‚Üí WANDER ‚Üí ROAM ‚Üí NPC
                            let moveChance, baseAngleStep;

                            if (user.state === 'lurk') {
                                // LURK: minimal movement (same as NPC)
                                moveChance = 0.25;
                                baseAngleStep = 5; // 5 degrees (minimal)
                            } else if (user.wander) {
                                // WANDER: most active
                                moveChance = 0.7;
                                baseAngleStep = (10 + Math.random() * 25); // 10-35 degrees (normal)
                            } else if (user.roaming) {
                                // ROAM: normal movement
                                moveChance = 0.4;
                                baseAngleStep = (10 + Math.random() * 25); // 10-35 degrees (normal)
                            } else {
                                // NPC: minimal movement
                                moveChance = 0.25;
                                baseAngleStep = 5; // 5 degrees (minimal)
                            }
                            const angleStep = baseAngleStep;

                            if (Math.random() < moveChance) {
                                const direction = Math.random() < 0.5 ? -1 : 1;
                                let newAngle = (user.angle + direction * angleStep + 360) % 360;
                                
                                // LURK users are on outer ring - enforce outer ring degree limits (190¬∞ to 350¬∞)
                                if (isLurkUser && user.outerRing) {
                                    const outerRingStartAngle = 190;
                                    const outerRingEndAngle = 350;
                                    
                                    // Clamp to outer ring limits
                                    if (newAngle < outerRingStartAngle || newAngle > outerRingEndAngle) {
                                        // If going past limits, bounce back
                                        if (newAngle < outerRingStartAngle) {
                                            newAngle = outerRingStartAngle + (outerRingStartAngle - newAngle);
                                            if (newAngle > outerRingEndAngle) newAngle = outerRingStartAngle;
                                        } else if (newAngle > outerRingEndAngle) {
                                            newAngle = outerRingEndAngle - (newAngle - outerRingEndAngle);
                                            if (newAngle < outerRingStartAngle) newAngle = outerRingEndAngle;
                                        }
                                    }
                                }

                                // Check for collisions with other users
                                const minDistance = 25; // Minimum angle distance between users (in degrees)
                                let canMove = true;

                                this.users.forEach(otherUser => {
                                    if (otherUser.id !== user.id) {
                                        // Calculate shortest angular distance
                                        const angleDiff = Math.abs(newAngle - otherUser.angle);
                                        const minAngleDiff = Math.min(angleDiff, 360 - angleDiff);

                                        if (minAngleDiff < minDistance) {
                                            canMove = false;
                                        }
                                    }
                                });

                                if (canMove) {
                                    user.angle = newAngle;

                                    // Flip sprite based on movement direction
                                    this.flipSprite(user.id, direction);

                                    // Set moving animation
                                    this.setUserMoving(user.id, true);

                                    // Reposition user
                                    this.positionUserElement(user);

                                    // Stop moving animation after movement completes
                                    setTimeout(() => {
                                        this.setUserMoving(user.id, false);
                                    }, 600);
                                }
                            }
                        }
                    });
                }, 3000); // Check every 3 seconds
            }

            isActiveUser(user) {
                // Check if user is the logged-in active viewer
                try {
                    const activeViewer = localStorage.getItem('activeViewer');
                    if (activeViewer) {
                        const active = JSON.parse(activeViewer);
                        return user.userId === active.userId || 
                               user.username === active.displayName || 
                               user.username === active.username;
                    }
                } catch (e) {}
                return false;
            }

            setUserMoving(userId, isMoving) {
                const element = document.getElementById(userId);
                if (!element) return;
                
                const spriteMode = this.settings.spriteMode || 'circle';
                const isRpgMode = spriteMode === 'rpg-characters';
                
                if (isMoving) {
                    element.classList.remove('idle');
                    element.classList.add('moving');
                } else {
                    element.classList.remove('moving');
                    // Skip idle animation for RPG characters
                    if (!isRpgMode) {
                        element.classList.add('idle');
                        // Add random animation delay so sprites don't float in sync
                        const randomDelay = Math.random() * 3; // 0-3 seconds random delay
                        element.style.animationDelay = `${randomDelay}s`;
                    }
                }
            }
            
            shutdown() {
                console.log('üõë Shutting down widget...');
                
                // Stop all animations
                if (this.animationFrame) {
                    cancelAnimationFrame(this.animationFrame);
                    this.animationFrame = null;
                }
                
                // Stop random movement
                if (this.randomMovementInterval) {
                    clearInterval(this.randomMovementInterval);
                    this.randomMovementInterval = null;
                }
                
                // Clean up all blob URLs
                this.users.forEach(user => {
                    const element = document.getElementById(user.id);
                    if (element) {
                        const spriteImg = element.querySelector('img');
                        if (spriteImg && spriteImg._blobUrl) {
                            URL.revokeObjectURL(spriteImg._blobUrl);
                        }
                    }
                });
                
                // Clear all users with animations
                this.users.forEach(user => {
                    this.removeUserElement(user.id);
                });
                this.users = [];
                
                // Clear DOM after animations complete (600ms animation + up to 250ms random delay)
                setTimeout(() => {
                    const circleContainer = document.getElementById('circleContainer');
                    if (circleContainer) {
                        circleContainer.innerHTML = '';
                    }
                }, 900); // 600ms animation + 250ms max delay + 50ms buffer
                
                console.log('‚úÖ Widget shutdown complete');
            }

            // Glow animation
            startGlowAnimation() {
                // Cancel existing animation if any
                if (this.animationFrame) {
                    cancelAnimationFrame(this.animationFrame);
                    this.animationFrame = null;
                }
                
                // Check if animation should be enabled (default to true if not explicitly false)
                if (this.settings.animatedGlow === false) {
                    return; // Animation disabled
                }
                
                let animationTime = 0;
                const baseIntensity = this.settings.glowIntensity || 50;
                const baseSpread = this.settings.glowSpread || 85;
                const flickerBaseOpacitySetting = this.settings.flickerOpacity || 25;
                const flickerBaseSpread = this.settings.flickerSpread || 55;
                
                const animate = () => {
                    const glow = document.getElementById('campfireGlow');
                    const flicker = document.getElementById('campfireFlicker');
                    // Check if animation should continue (default to true if not explicitly false)
                    if (!glow || this.settings.animatedGlow === false) {
                        this.animationFrame = null;
                        return;
                    }
                    
                    animationTime += 0.05;
                    
                    // Intensity: vary by ¬±1-20 from base
                    const intensityVariation = Math.sin(animationTime * 0.8) * 10 + Math.sin(animationTime * 1.3) * 5;
                    const animatedIntensity = Math.max(0, Math.min(100, baseIntensity + intensityVariation));
                    
                    // Spread: vary by ¬±3-8% from base
                    const spreadVariation = Math.sin(animationTime * 0.5) * 4 + Math.sin(animationTime * 0.9) * 2;
                    const animatedSpread = Math.max(20, Math.min(100, baseSpread + spreadVariation));
                    
                    // Recalculate gradient
                    const baseOpacity = (animatedIntensity / 100) * 0.5;
                    const stop1 = Math.max(0, animatedSpread * 0.25);
                    const stop2 = Math.max(5, animatedSpread * 0.4);
                    const stop3 = Math.max(10, animatedSpread * 0.55);
                    const stop4 = Math.max(15, animatedSpread * 0.7);
                    const stop5 = Math.max(20, animatedSpread * 0.85);
                    
                    const glowGradient = `radial-gradient(ellipse at center, 
                        rgba(255, 107, 53, ${baseOpacity}) 0%, 
                        rgba(247, 147, 30, ${baseOpacity * 0.7}) ${stop1}%, 
                        rgba(255, 204, 2, ${baseOpacity * 0.5}) ${stop2}%, 
                        rgba(255, 204, 2, ${baseOpacity * 0.3}) ${stop3}%, 
                        rgba(255, 204, 2, ${baseOpacity * 0.15}) ${stop4}%, 
                        transparent ${animatedSpread}%)`;
                    
                    glow.style.background = glowGradient;

                    // Flicker layer: faster/lower-amplitude variation, in front of campfire
                    if (flicker) {
                        const flickerOpacityVar = (Math.sin(animationTime * 2.2) * 6 + Math.sin(animationTime * 3.7) * 4);
                        const animatedFlickerOpacity = Math.max(0, Math.min(100, flickerBaseOpacitySetting + flickerOpacityVar));
                        const flickerSpreadVar = (Math.sin(animationTime * 1.6) * 3 + Math.sin(animationTime * 2.4) * 2);
                        const animatedFlickerSpread = Math.max(20, Math.min(100, flickerBaseSpread + flickerSpreadVar));

                        const op = Math.max(0, Math.min(1, (animatedFlickerOpacity / 100) * 0.6));
                        const f1 = Math.max(0, animatedFlickerSpread * 0.25);
                        const f2 = Math.max(5, animatedFlickerSpread * 0.45);
                        const flickerGradient = `radial-gradient(ellipse at center,
                            rgba(255, 255, 255, ${op * 0.15}) 0%,
                            rgba(255, 204, 2, ${op * 0.7}) ${f1}%,
                            rgba(255, 107, 53, ${op * 0.35}) ${f2}%,
                            transparent ${animatedFlickerSpread}%)`;
                        flicker.style.background = flickerGradient;
                    }
                    
                    this.animationFrame = requestAnimationFrame(animate);
                };
                
                this.animationFrame = requestAnimationFrame(animate);
            }
        }

        // Initialize widget when DOM is ready
        let widget;
        const pendingWidgetEvents = [];
        
        let reconcileTimeout = null;
        function scheduleReconcile() {
            if (reconcileTimeout) clearTimeout(reconcileTimeout);
            reconcileTimeout = setTimeout(() => {
                if (!widget || !Array.isArray(widget.users)) return;
                widget.users.forEach(user => {
                    const elem = document.getElementById(user.id);
                    // Skip users mid-enter
                    if (elem && elem.classList.contains('entering')) return;
                    
                    // Ensure sprite is assigned (getUserSprite will handle spritesByMode automatically)
                    if (widget.getUserSprite) {
                        widget.getUserSprite(user);
                    }
                    // Do NOT call updateUserElement here: it does a full sprite swap (hide/reload/show) on
                    // every user, which makes all existing sprites re-animate or blink when only one was added.
                    // updateUserElement is still used by syncUsersToState (color/sprite change) and updateSettings.
                    // Safety: ensure element isn't stuck hidden from a prior failed load
                    if (elem && elem.style.display === 'none') {
                        elem.style.display = '';
                        elem.style.visibility = 'visible';
                        elem.style.opacity = '1';
                    }
                });
            }, 200);
        }

        function applyWidgetEvent(evt) {
            if (!widget || !evt) return false;
            
            if (evt.type === 'userJoin' && evt.user) {
                const user = evt.user;
                if (user.username) {
                    widget.addUser(user.username, {
                        userId: user.userId || null,
                        color: user.color || '#ffffff',
                        selectedSprite: user.selectedSprite || null,
                        twitchColor: user.twitchColor || null,
                        angle: user.angle !== undefined ? user.angle : Math.random() * 360
                    });
                    scheduleReconcile();
                    // Refresh members list if members tab is open
                    if (document.getElementById('membersSection')?.classList.contains('active')) {
                        setTimeout(() => loadWidgetMembers(), 100);
                    }
                }
                return true;
            }
            
            if (evt.type === 'userLeave') {
                if (evt.userId && widget.removeUserById) {
                    widget.removeUserById(evt.userId);
                    // Refresh members list if members tab is open
                    if (document.getElementById('membersSection')?.classList.contains('active')) {
                        setTimeout(() => loadWidgetMembers(), 100);
                    }
                    return true;
                }
                if (evt.username && widget.removeUser) {
                    widget.removeUser(evt.username);
                    // Refresh members list if members tab is open
                    if (document.getElementById('membersSection')?.classList.contains('active')) {
                        setTimeout(() => loadWidgetMembers(), 100);
                    }
                    return true;
                }
            }
            
            if (evt.type === 'userAfk') {
                if (evt.username && widget.setUserAfk) {
                    widget.setUserAfk(evt.username);
                    return true;
                }
            }
            
            if (evt.type === 'userLurk') {
                if (evt.username && widget.setUserLurk) {
                    widget.setUserLurk(evt.username);
                    return true;
                }
            }

            if (evt.type === 'userUpdate') {
                if (evt.username && widget.updateUser) {
                    widget.updateUser(evt.username, evt);
                    return true;
                }
            }
            
            if (evt.type === 'userReturnFromLurk') {
                if (evt.username && widget.returnUserFromLurkOrAfk) {
                    widget.returnUserFromLurkOrAfk(evt.username);
                    return true;
                }
            }
            
            if (evt.type === 'memberMovement' && evt.userId) {
                // Handle movement state changes from commands
                // Use case-insensitive string comparison for userId matching
                const targetId = String(evt.userId || '').toLowerCase();
                const user = widget.users.find(u => String(u.userId || '').toLowerCase() === targetId);
                if (user) {
                    user.still = !!evt.still;
                    user.roaming = !!evt.roaming;
                    user.wander = !!evt.wander;
                    user.stillMode = !!evt.still;
                    // Mark as manual command so movement loop doesn't override
                    user.manualStill = !!evt.still;

                    // Reset activity timer for movement commands (user is actively engaging)
                    user.lastActivity = Date.now();

                    // Update CSS classes
                    const element = document.getElementById(user.id);
                    if (element) {
                        element.classList.remove('still', 'roaming', 'wander');
                        if (evt.still) element.classList.add('still');
                        else if (evt.wander) element.classList.add('wander');
                        else if (evt.roaming) element.classList.add('roaming');
                    }
                    
                    console.log(`[memberMovement] Updated ${user.username}: still=${user.still}, roaming=${user.roaming}, wander=${user.wander}`);
                    return true;
                }
            }

            if (evt.type === 'syncFullState' && Array.isArray(evt.users)) {
                syncUsersToState(evt.users);
                scheduleReconcile();
                return true;
            }
            
            return false;
        }
        
        // Electron IPC listeners for widget events (desktop app only)
        if (window.electronAPI) {
            // Settings updates from main (Dashboard ‚Üí main ‚Üí widget, and vice versa)
            if (window.electronAPI.onSettingsUpdate) {
                window.electronAPI.onSettingsUpdate((settings) => {
                    try {
                        if (settings && widget) {
                            widget.updateSettings(settings);
                            // Keep Quick Settings overlay inputs mirrored
                            try { localStorage.setItem('campfireWidgetSettings', JSON.stringify({ ...(widget.settings || {}), ...(settings || {}) })); } catch (e) {}
                            if (typeof loadDashboardData === 'function') loadDashboardData({ silent: true });
                        }
                    } catch (e) { /* ignore */ }
                });
            }

            window.electronAPI.onUserJoin((user) => {
                const evt = { type: 'userJoin', user };
                if (!applyWidgetEvent(evt)) {
                    pendingWidgetEvents.push(evt);
                }
            });
            
            window.electronAPI.onUserLeave((data) => {
                const evt = { type: 'userLeave', userId: data?.userId, username: data?.username };
                if (!applyWidgetEvent(evt)) {
                    pendingWidgetEvents.push(evt);
                }
            });
            
            // User AFK state change
            if (window.electronAPI.onUserAfk) {
                window.electronAPI.onUserAfk((data) => {
                    const evt = { type: 'userAfk', username: data?.username };
                    if (!applyWidgetEvent(evt)) {
                        pendingWidgetEvents.push(evt);
                    }
                });
            }
            
            // User LURK state change
            if (window.electronAPI.onUserLurk) {
                window.electronAPI.onUserLurk((data) => {
                    const evt = { type: 'userLurk', username: data?.username };
                    if (!applyWidgetEvent(evt)) {
                        pendingWidgetEvents.push(evt);
                    }
                });
            }
            
            // User return from LURK/AFK via join command
            if (window.electronAPI.onUserReturnFromLurk) {
                window.electronAPI.onUserReturnFromLurk((data) => {
                    const evt = { type: 'userReturnFromLurk', username: data?.username };
                    if (!applyWidgetEvent(evt)) {
                        pendingWidgetEvents.push(evt);
                    }
                });
            }

            // User data update (e.g., placeholder user getting real Twitch data)
            if (window.electronAPI.onUserUpdate) {
                window.electronAPI.onUserUpdate((data) => {
                    const evt = { type: 'userUpdate', username: data?.username, ...data };
                    if (!applyWidgetEvent(evt)) {
                        pendingWidgetEvents.push(evt);
                    }
                });
            }
            
            // User ID migration (when placeholder userId is replaced with real Twitch ID)
            if (window.electronAPI.onUserIdMigrated) {
                window.electronAPI.onUserIdMigrated((data) => {
                    console.log(`[Widget] User ID migrated: ${data?.username} from ${data?.oldUserId} to ${data?.newUserId}`);
                    // Update the widget's internal user tracking
                    if (widget && widget.migrateUserId) {
                        widget.migrateUserId(data?.oldUserId, data?.newUserId, data?.username);
                    } else if (widget && widget.users) {
                        // Fallback: manually update the user in the widget's users array
                        const userIndex = widget.users.findIndex(u =>
                            String(u.userId) === String(data?.oldUserId) ||
                            (u.username && u.username.toLowerCase() === data?.username?.toLowerCase())
                        );
                        if (userIndex !== -1) {
                            widget.users[userIndex].userId = data?.newUserId;
                            console.log(`[Widget] Updated user ${data?.username} userId to ${data?.newUserId}`);
                        }
                    }
                });
            }
            
            // User activity update (for commands that don't show chat bubbles)
            if (window.electronAPI.onUserActivity) {
                window.electronAPI.onUserActivity((data) => {
                    if (widget && widget.updateUserActivity) {
                        widget.updateUserActivity(data?.username, data?.userId);
                    }
                });
            }
            
            window.electronAPI.onSyncFullState((users) => {
                if (!widget) {
                    pendingWidgetEvents.push({ type: 'syncFullState', users });
                    return;
                }
                if (Array.isArray(users)) {
                    syncUsersToState(users);
                }
            });

            window.electronAPI.onViewerColorChange((data) => {
                if (!widget || !data?.userId) return;
                const targetId = String(data.userId).toLowerCase();
                const u = widget.users.find(uu => String(uu.userId || '').toLowerCase() === targetId);
                if (u) { u.color = data.color; widget.updateUserColor(u); }
            });

            window.electronAPI.onViewerSpriteChange((data) => {
                if (!widget || !data?.userId) return;
                const targetId = String(data.userId).toLowerCase();
                const u = widget.users.find(uu => String(uu.userId || '').toLowerCase() === targetId);
                if (u) { u.assignedSprite = data.sprite; u.selectedSprite = data.sprite; widget.updateUserSprite(u); }
            });

            window.electronAPI.onViewerTwitchColorUpdate((data) => {
                if (!widget || !data?.userId) return;
                const targetId = String(data.userId).toLowerCase();
                const u = widget.users.find(uu => String(uu.userId || '').toLowerCase() === targetId);
                if (u) { u.twitchColor = data.color; widget.updateUsernameTwitchColor(u); }
            });

            // Movement from Twitch chat commands (!cw / !ccw) and viewer dashboards
            window.electronAPI.onViewerMovement((data) => {
                if (!widget || !data) return;
                const username = data.username || data.displayName;
                const direction = typeof data.direction === 'number' ? data.direction : null;
                const speed = typeof data.speed === 'number' ? data.speed : (typeof data.degrees === 'number' ? data.degrees : 15);
                if (username && direction !== null) {
                    const angle = typeof data.angle === 'number' ? data.angle : null;
                    const degrees = typeof data.degrees === 'number' ? data.degrees : (typeof data.speed === 'number' ? data.speed : null);
                    if (angle !== null && typeof widget.moveUserToAngle === 'function') {
                        widget.moveUserToAngle(username, angle, { userId: data.userId || null, direction, degrees });
                    } else {
                        widget.moveUser(username, direction, speed || 15);
                    }
                }
            });
            
            // Audio control from dashboard (plays in widget for persistence)
            if (window.electronAPI.onAudioControl) {
                window.electronAPI.onAudioControl(async (data) => {
                    const { action, audioType, volume } = data;
                    console.log(`[Widget] Audio control: ${action} ${audioType}`, volume !== undefined ? `volume=${volume}` : '');
                    
                    if (!audioManager) return;
                    
                    if (action === 'play') {
                        // Load audio data if needed
                        const audioSettings = JSON.parse(localStorage.getItem('audioSettings') || '{}');
                        let audioData = audioSettings[audioType]?.fileData;
                        
                        // Load from disk if useFileStorage is set
                        if (!audioData && audioSettings[audioType]?.useFileStorage && window.electronAPI.loadAudioFile) {
                            try {
                                const result = await window.electronAPI.loadAudioFile(audioType);
                                if (result.success) {
                                    audioData = result.fileData;
                                }
                            } catch (e) {
                                console.error(`Failed to load ${audioType} from disk:`, e);
                            }
                        }
                        
                        if (audioData) {
                            // Update audio manager settings
                            if (!audioManager.settings[audioType]) {
                                audioManager.settings[audioType] = {};
                            }
                            audioManager.settings[audioType].fileData = audioData;
                            audioManager.settings[audioType].volume = volume !== undefined ? volume : (audioSettings[audioType]?.volume || 70);
                            audioManager.settings[audioType].loop = audioSettings[audioType]?.loop !== false;
                            
                            // Play the audio
                            audioManager.playSound(audioType);
                        }
                    } else if (action === 'stop') {
                        if (audioManager.audioElements[audioType]) {
                            audioManager.audioElements[audioType].pause();
                            audioManager.audioElements[audioType].currentTime = 0;
                            audioManager.audioElements[audioType] = null;
                        }
                    } else if (action === 'setVolume' && volume !== undefined) {
                        if (audioManager.audioElements[audioType]) {
                            audioManager.audioElements[audioType].volume = volume / 100;
                        }
                        // Also update settings
                        if (audioManager.settings[audioType]) {
                            audioManager.settings[audioType].volume = volume;
                        }
                    }
                });
            }
            
            // Respond to audio status requests
            if (window.electronAPI.onGetAudioStatus) {
                window.electronAPI.onGetAudioStatus(() => {
                    const status = {
                        music: {
                            playing: !!(audioManager?.audioElements?.music && !audioManager.audioElements.music.paused),
                            volume: audioManager?.settings?.music?.volume || 70
                        },
                        ambience: {
                            playing: !!(audioManager?.audioElements?.ambience && !audioManager.audioElements.ambience.paused),
                            volume: audioManager?.settings?.ambience?.volume || 50
                        }
                    };
                    if (window.electronAPI.sendAudioStatusResponse) {
                        window.electronAPI.sendAudioStatusResponse(status);
                    }
                });
            }
        }
        console.log('Widget script loading, readyState:', document.readyState);
        
        function initWidget() {
            try {
                console.log('Initializing widget...');
                console.log('Campfire graphic element exists:', !!document.getElementById('campfireGraphic'));
                console.log('Circle container element exists:', !!document.getElementById('circleContainer'));
                
                widget = new CampfireWidget();
                window.campfireWidget = widget;
                window.widget = widget; // Also expose as window.widget for compatibility
                
                // Apply any pending IPC events that arrived before widget init
                if (pendingWidgetEvents.length > 0) {
                    const queued = pendingWidgetEvents.splice(0, pendingWidgetEvents.length);
                    queued.forEach(evt => applyWidgetEvent(evt));
                }
                console.log('Widget initialized successfully!', widget);
                
                // Auto-play music/ambience if enabled (after a short delay to ensure everything is ready)
                setTimeout(() => {
                    if (audioManager) {
                        audioManager.autoPlayOnLoad();
                    }
                }, 1000);
            } catch (error) {
                console.error('Error initializing widget:', error);
                console.error('Error stack:', error.stack);
            }
        }
        
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initWidget);
        } else {
            // DOM already loaded, initialize immediately
            initWidget();
        }

        // Flag to prevent storage events from triggering updates during Dashboard initialization
        let _ignoringStorageEvents = false;
        
        // Listen for settings updates from dashboard (via localStorage events)
        window.addEventListener('storage', (e) => {
            if (!widget || _ignoringStorageEvents) return;
            if (e.key === 'campfireWidgetSettings') {
                try {
                    const newSettings = JSON.parse(e.newValue);
                    const oldSettings = widget.settings || {};
                    // Only pass settings that actually changed to prevent unnecessary sprite updates
                    const changedSettings = {};
                    Object.keys(newSettings).forEach(key => {
                        // Skip sprite collections and data - they're handled separately
                        if (key === 'shadowSprites' || key === 'rpgSprites' || key === 'morphSprites' || 
                            key === 'defaultSpriteData' || key === 'customSpriteData') {
                            // Only include if they actually changed
                            const oldVal = oldSettings[key];
                            const newVal = newSettings[key];
                            if (JSON.stringify(oldVal) !== JSON.stringify(newVal)) {
                                changedSettings[key] = newVal;
                            }
                        } else if (oldSettings[key] !== newSettings[key]) {
                            changedSettings[key] = newSettings[key];
                        }
                    });
                    // Only call updateSettings if something actually changed
                    if (Object.keys(changedSettings).length > 0) {
                        widget.updateSettings(changedSettings);
                    }
                    // Sync sprite mode dropdown in Quick Settings overlay when Dashboard changes it (cross-window)
                    // Only update if value actually changed to prevent infinite loops
                    if (newSettings.spriteMode !== undefined) {
                        const quickSpriteModeSelect = document.getElementById('spriteMode');
                        if (quickSpriteModeSelect && quickSpriteModeSelect.value !== newSettings.spriteMode) {
                            // Prevent triggering onchange event by temporarily removing listener
                            const oldOnchange = quickSpriteModeSelect.onchange;
                            quickSpriteModeSelect.onchange = null;
                            quickSpriteModeSelect.value = newSettings.spriteMode;
                            quickSpriteModeSelect.onchange = oldOnchange;
                        }
                    }
                } catch (err) {
                    console.error('Error parsing settings:', err);
                }
            }
        });
        
        // Also listen for custom events (for same-window updates from dashboard)
        window.addEventListener('campfireSettingsUpdate', (e) => {
            if (widget) widget.updateSettings(e.detail);
            // Sync sprite mode dropdown in Quick Settings overlay when Dashboard changes it (same-window)
            // Only update if value actually changed to prevent infinite loops
            if (e.detail && e.detail.spriteMode !== undefined) {
                const quickSpriteModeSelect = document.getElementById('spriteMode');
                if (quickSpriteModeSelect && quickSpriteModeSelect.value !== e.detail.spriteMode) {
                    // Prevent triggering onchange event by temporarily removing listener
                    const oldOnchange = quickSpriteModeSelect.onchange;
                    quickSpriteModeSelect.onchange = null;
                    quickSpriteModeSelect.value = e.detail.spriteMode;
                    quickSpriteModeSelect.onchange = oldOnchange;
                }
            }
        });
        
        // Sync current widget users to a target state (source of truth)
        function syncUsersToState(targetUsers) {
            if (!widget || !widget.users || !Array.isArray(targetUsers)) return;
            // When main has no users yet (e.g. after restart, before any !join), do not wipe
            // widget users that were restored from localStorage.
            if (targetUsers.length === 0 && widget.users.length > 0) return;

            const currentUsers = widget.users.slice();
            
            // Create maps for quick lookup (use both userId and username as keys)
            const currentUserMap = new Map();
            currentUsers.forEach(u => {
                const userIdKey = (u.userId || '').toLowerCase();
                const usernameKey = (u.username || '').toLowerCase();
                if (userIdKey) currentUserMap.set(userIdKey, u);
                if (usernameKey && usernameKey !== userIdKey) currentUserMap.set(usernameKey, u);
            });
            
            const targetUserMap = new Map();
            targetUsers.forEach(u => {
                const userIdKey = (u.userId || '').toLowerCase();
                const usernameKey = (u.username || '').toLowerCase();
                if (userIdKey) targetUserMap.set(userIdKey, u);
                if (usernameKey && usernameKey !== userIdKey) targetUserMap.set(usernameKey, u);
            });
            
            // Remove users that are no longer in the target state
            currentUsers.forEach(user => {
                const userIdKey = (user.userId || '').toLowerCase();
                const usernameKey = (user.username || '').toLowerCase();
                const shouldRemove = (userIdKey && !targetUserMap.has(userIdKey)) || 
                                   (usernameKey && !targetUserMap.has(usernameKey));
                if (shouldRemove) {
                    if (user.userId && widget.removeUserById) {
                        widget.removeUserById(user.userId);
                    } else if (user.username && widget.removeUser) {
                        widget.removeUser(user.username);
                    }
                }
            });
            
            // Add/update users to match target state
            targetUsers.forEach(user => {
                const userIdKey = (user.userId || '').toLowerCase();
                const usernameKey = (user.username || '').toLowerCase();
                if (!userIdKey && !usernameKey) return;
                
                const existingUser = currentUserMap.get(userIdKey) || currentUserMap.get(usernameKey);
                if (existingUser) {
                    let needsUpdate = false;
                    // DO NOT update angles for existing users - this preserves their position
                    // when JOIN ALL adds new users. Only new users get angles from the target state.
                    // Existing users keep their current position on the circle.
                    if (user.color && existingUser.color !== user.color) {
                        existingUser.color = user.color;
                        needsUpdate = true;
                    }
                    if (user.selectedSprite !== undefined && existingUser.selectedSprite !== user.selectedSprite) {
                        existingUser.selectedSprite = user.selectedSprite;
                        needsUpdate = true;
                    }
                    if (user.twitchColor !== undefined && existingUser.twitchColor !== user.twitchColor) {
                        existingUser.twitchColor = user.twitchColor;
                        widget.updateUsernameTwitchColor(existingUser);
                    }
                    if (needsUpdate) {
                        widget.updateUserElement(existingUser);
                    }
                } else if (widget.addUser) {
                    widget.addUser(user.username, {
                        userId: user.userId,
                        color: user.color || '#ffffff',
                        selectedSprite: user.selectedSprite || null,
                        twitchColor: user.twitchColor || null,
                        angle: user.angle !== undefined ? user.angle : Math.random() * 360
                    });
                }
            });
        }
        
        // Listen for postMessage from dashboard (for real-time preview updates)
        // Debounce to prevent excessive updates while dragging sliders
        let updateTimeout = null;
        window.addEventListener('message', (e) => {
            if (!e.data || !widget) return;
            
            // Handle full state sync for live preview (matches actual widget exactly)
            if (e.data.type === 'syncFullState' && Array.isArray(e.data.users)) {
                syncUsersToState(e.data.users);
                return;
            }
            
            // Handle individual user sync for live preview (legacy support)
            if (e.data.type === 'syncUser' && e.data.user) {
                const user = e.data.user;
                // Check if user already exists
                const existingUser = widget.users.find(u => 
                    (u.userId && user.userId && u.userId === user.userId) ||
                    (u.username && user.username && u.username.toLowerCase() === user.username.toLowerCase())
                );
                
                if (!existingUser && widget.addUser) {
                    // Add user if not present
                    widget.addUser(user.username, {
                        userId: user.userId,
                        color: user.color || '#ffffff',
                        selectedSprite: user.selectedSprite || null,
                        angle: user.angle || Math.random() * 360
                    });
                }
                return;
            }
            
            if (e.data.type === 'updateSettings') {
                // Clear existing timeout
                if (updateTimeout) {
                    clearTimeout(updateTimeout);
                }
                // Debounce updates by 50ms (only update after user stops dragging)
                updateTimeout = setTimeout(() => {
                    widget.updateSettings(e.data.settings);
                }, 50);
            } else if (e.data.type === 'kickMember') {
                // Kick member from campfire
                if (e.data.userId) {
                    widget.removeUserById(e.data.userId);
                } else {
                    widget.removeUser(e.data.username);
                }
            } else if (e.data.type === 'memberMute') {
                // Mute/unmute member (store state for chat message filtering)
                const user = widget.users.find(u => 
                    (e.data.userId && u.userId === e.data.userId) || 
                    u.username === e.data.username
                );
                if (user) {
                    user.muted = e.data.muted;
                }
            } else if (e.data.type === 'memberStill') {
                // Prevent/allow member movement
                const user = widget.users.find(u => 
                    (e.data.userId && u.userId === e.data.userId) || 
                    u.username === e.data.username
                );
                if (user) {
                    user.still = e.data.still;
                }
            } else if (e.data.type === 'shutdown') {
                // Shutdown widget and all resources
                stopEventPolling();
                if (widget) {
                    widget.shutdown();
                }
            } else if (e.data.type === 'userActivity') {
                // Update user activity (for commands that don't show chat bubbles)
                if (widget && widget.updateUserActivity) {
                    widget.updateUserActivity(e.data.username, e.data.userId);
                }
            } else if (e.data.type === 'memberMovement' && e.data.userId) {
                // Handle movement state changes from commands (still/roam/wander)
                // Route to applyWidgetEvent for consistent handling
                applyWidgetEvent(e.data);
            }
        });

        window.addEventListener('viewerMovement', (e) => {
            if (widget) widget.moveUser(e.detail.username, e.detail.direction, e.detail.speed || 15);
        });

        window.addEventListener('viewerStopMovement', (e) => {
            if (!widget) return;
            const user = widget.users.find(u => 
                u.userId === e.detail.userId || 
                u.username === e.detail.username
            );
            if (user) {
                widget.stopUserMovement(user.id);
            }
        });

        window.addEventListener('viewerColorUpdate', (e) => {
            if (!widget) return;
            // Update color for existing user
            const user = widget.users.find(u => 
                u.userId === e.detail.userId || 
                u.username === e.detail.username
            );
            if (user) {
                user.color = e.detail.color;
                widget.updateUserElement(user);
                widget.savePersistedUsers(); // Save state after color update
            }
        });

        window.addEventListener('viewerJoin', (e) => {
            if (widget) widget.addUser(e.detail.username, {
                userId: e.detail.userId,
                color: e.detail.color,
                selectedSprite: e.detail.selectedSprite || null
            });
        });

        window.addEventListener('viewerLeave', (e) => {
            if (widget) {
                if (e.detail.userId) {
                    widget.removeUserById(e.detail.userId);
                } else {
                    widget.removeUser(e.detail.username);
                }
            }
        });

        window.addEventListener('chatMessage', (e) => {
            if (widget && e.detail.message && e.detail.message.length <= 50) {
                // Prevent duplicate processing by marking the message as processed
                if (!e.detail._processed) {
                    e.detail._processed = true;
                    widget.showChatMessage(e.detail.username, e.detail.message);
                }
            }
        });

        // Listen for viewer events via storage (for cross-window communication)
        window.addEventListener('storage', (e) => {
            if (!widget) return;
            
            if (e.key === 'viewerJoin') {
                try {
                    const joinData = JSON.parse(e.newValue);
                    if (joinData.action === 'join') {
                        widget.addUser(joinData.username, {
                            userId: joinData.userId,
                            color: joinData.color,
                            selectedSprite: joinData.selectedSprite || null
                        });
                    }
                } catch (err) {
                    console.error('Error parsing join data:', err);
                }
            } else if (e.key === 'viewerLeave') {
                try {
                    const leaveData = JSON.parse(e.newValue);
                    if (leaveData.action === 'leave') {
                        if (leaveData.userId) {
                            widget.removeUserById(leaveData.userId);
                        } else {
                            widget.removeUser(leaveData.username);
                        }
                    }
                } catch (err) {
                    console.error('Error parsing leave data:', err);
                }
            } else if (e.key === 'viewerMovement') {
                // Handle viewer movement
                try {
                    const movement = JSON.parse(e.newValue);
                    widget.moveUser(movement.username || movement.displayName, movement.direction, movement.speed || 15);
                } catch (err) {
                    console.error('Error parsing movement:', err);
                }
            } else if (e.key === 'viewerColorUpdate') {
                // Handle color update
                try {
                    const colorData = JSON.parse(e.newValue);
                    const user = widget.users.find(u => 
                        u.userId === colorData.userId || 
                        u.username === colorData.username
                    );
                    if (user) {
                        user.color = colorData.color;
                        widget.updateUserElement(user);
                        widget.savePersistedUsers(); // Save state after color update
                    }
                } catch (err) {
                    console.error('Error parsing color update:', err);
                }
            } else if (e.key === 'chatMessage') {
                // Handle chat message
                try {
                    const chatData = JSON.parse(e.newValue);
                    if (chatData.message && chatData.message.length <= 50) {
                        // Prevent duplicate processing by checking if the message has already been processed
                        if (!chatData._processed) {
                            chatData._processed = true;
                            widget.showChatMessage(chatData.username, chatData.message);
                        }
                    }
                } catch (err) {
                    console.error('Error parsing chat message:', err);
                }
            } else if (e.key === 'viewerStopMovement') {
                // Handle stop movement
                try {
                    const stopData = JSON.parse(e.newValue);
                    const user = widget.users.find(u => 
                        u.userId === stopData.userId || 
                        u.username === stopData.username
                    );
                    if (user) {
                        widget.stopUserMovement(user.id);
                    }
                } catch (err) {
                    console.error('Error parsing stop movement:', err);
                }
            }
        });

        // Listen for chat messages (this would be integrated with chat API)
        // For now, we'll create a function that can be called by chat integration
        window.handleChatMessage = function(username, message, userId = null) {
            if (!widget) return;
            if (message && message.length <= 50) {
                // Add user if they don't exist
                if (!widget.users.find(u => u.username === username)) {
                    widget.addUser(username, { userId: userId });
                }
                
                // Show chat message
                widget.showChatMessage(username, message);
            }
        };

        // Expose widget globally for external control (chat integration, etc.)
        // (Already set above during initialization)

        // Poll server for chat events (if server is running)
        let lastEventId = 0;
        let eventPollInterval = null;

        function stopEventPolling() {
            if (eventPollInterval) {
                clearInterval(eventPollInterval);
                eventPollInterval = null;
                console.log('‚úÖ Event polling stopped');
            }
        }

        function startEventPolling() {
            // Only poll if we're on localhost (server is running)
            if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
                eventPollInterval = setInterval(async () => {
                    try {
                        const response = await fetch(`http://localhost:3000/api/events?since=${lastEventId}`);
                        const data = await response.json();
                        
                        if (data.events && data.events.length > 0) {
                            data.events.forEach(event => {
                                if (event.id > lastEventId) {
                                    lastEventId = event.id;
                                }
                                
                                if (event.type === 'userJoin' && widget) {
                                    widget.addUser(event.data.username, {
                                        userId: event.data.userId,
                                        color: event.data.color,
                                        selectedSprite: event.data.selectedSprite,
                                        isSubscriber: event.data.isSubscriber,
                                        isMod: event.data.isMod,
                                        isVip: event.data.isVip,
                                        isBroadcaster: event.data.isBroadcaster
                                    });
                                } else if (event.type === 'userLeave' && widget) {
                                    if (event.data.userId) {
                                        widget.removeUserById(event.data.userId);
                                    } else {
                                        widget.removeUser(event.data.username);
                                    }
                                } else if (event.type === 'chatMessage' && widget) {
                                    // Prevent duplicate processing by marking the message as processed
                                    if (!event.data._processed) {
                                        event.data._processed = true;
                                        widget.showChatMessage(event.data.username, event.data.message);
                                    }
                                }
                            });
                        }
                    } catch (e) {
                        // Server not running or not available - that's okay
                        // Only log if we've successfully connected before
                        if (lastEventId > 0) {
                            console.log('Server not available (this is normal if server.js is not running)');
                        }
                    }
                }, 500); // Poll every 500ms
            }
        }

        // Start polling when widget is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                setTimeout(startEventPolling, 2000); // Wait 2 seconds for widget to initialize
            });
        } else {
            setTimeout(startEventPolling, 2000);
        }

        // ============================================
        // DESKTOP APP MENU BAR
        // ============================================
        
        let menuBarInitialized = false;
        let hasSimulatedJoins = false; // Track if we've already simulated joins to prevent duplicates

        function initDesktopMenuBar() {
            console.log('[Menu Bar] initDesktopMenuBar() called');

            // Prevent duplicate initialization
            if (menuBarInitialized) {
                console.log('[Menu Bar] Already initialized, skipping');
                return;
            }
            
            // Mark as initialized immediately to prevent race conditions
            menuBarInitialized = true;

            // Check if we're in Electron (desktop app)
            const hasElectronAPI = typeof window.electronAPI !== 'undefined';
            const hasProcess = typeof window.process !== 'undefined';
            const userAgentHasElectron = navigator.userAgent.includes('Electron');
            const isDesktopApp = hasElectronAPI || hasProcess || userAgentHasElectron;

            console.log('[Menu Bar] Checking desktop app mode:', isDesktopApp);
            console.log('[Menu Bar] electronAPI available:', hasElectronAPI);
            console.log('[Menu Bar] User agent has Electron:', userAgentHasElectron);

            const menuBar = document.getElementById('desktopMenuBar');
            console.log('[Menu Bar] Menu bar element found:', !!menuBar);

            if (!menuBar) {
                console.error('[Menu Bar] Menu bar element not found!');
                return;
            }
            
            // Show menu bar if in Electron
            if (isDesktopApp) {
                menuBar.classList.add('desktop-app');
                console.log('[Menu Bar] Added desktop-app class');
                
                // Auto-hide menu bar after inactivity (5 seconds)
                let hideTimeout;
                const hideDelay = 5000; // 5 seconds
                
                function resetHideTimer() {
                    clearTimeout(hideTimeout);
                    menuBar.classList.remove('hidden');
                    
                    hideTimeout = setTimeout(() => {
                        menuBar.classList.add('hidden');
                        console.log('[Menu Bar] Auto-hiding after inactivity');
                    }, hideDelay);
                }
                
                // Reset timer on mouse movement or menu bar interaction
                document.addEventListener('mousemove', resetHideTimer);
                menuBar.addEventListener('mouseenter', () => {
                    clearTimeout(hideTimeout);
                    menuBar.classList.remove('hidden');
                });
                
                menuBar.addEventListener('mouseleave', () => {
                    resetHideTimer();
                });
                
                // Start the timer
                resetHideTimer();
            } else {
                console.log('[Menu Bar] Not in Electron - forcing show for debug');
                menuBar.classList.add('desktop-app');
            }
            
            if (isDesktopApp && typeof window.electronAPI !== 'undefined') {
                const btnDashboard = document.getElementById('btnDashboard');
                const btnSettings = document.getElementById('btnSettings');
                const btnMembers = document.getElementById('btnMembers');
                const btnEnd = document.getElementById('btnEnd');
                const btnKickAllUsers = document.getElementById('btnKickAllUsers');
                const btnJoinControlled = document.getElementById('btnJoinControlled');
                const btnJoinChaos = document.getElementById('btnJoinChaos');
                const statusIndicator = document.getElementById('statusIndicator');
                const statusText = document.getElementById('statusText');
                
                if (btnDashboard) {
                    btnDashboard.addEventListener('click', async () => {
                        console.log('[Widget] Dashboard button clicked');
                        // Temporarily ignore storage events to prevent glitches when Dashboard opens
                        _ignoringStorageEvents = true;
                        setTimeout(() => {
                            _ignoringStorageEvents = false;
                        }, 1000); // Ignore for 1 second after Dashboard opens
                        
                        // Open Full Settings window (dashboard.html)
                        if (window.electronAPI && window.electronAPI.openDashboard) {
                            console.log('[Widget] Calling electronAPI.openDashboard');
                            try {
                                const result = await window.electronAPI.openDashboard();
                                console.log('[Widget] openDashboard result:', result);
                            } catch (err) {
                                console.error('[Widget] Error opening dashboard:', err);
                            }
                        } else {
                            console.error('[Widget] electronAPI or openDashboard not available');
                        }
                    });
                }
                
                if (btnSettings) {
                    btnSettings.addEventListener('click', () => {
                        console.log('[Widget] Settings button (gear) clicked');
                        // Open Quick Settings overlay
                        openDashboard('quick');
                    });
                }
                
                if (btnMembers) {
                    btnMembers.addEventListener('click', () => {
                        openDashboard('members'); // Opens overlay to members tab
                    });
                }
                
                // Chat Popout button
                const btnChatPopout = document.getElementById('btnChatPopout');
                if (btnChatPopout) {
                    btnChatPopout.addEventListener('click', async () => {
                        console.log('[Widget] Chat Popout button clicked');
                        if (window.electronAPI && window.electronAPI.openChatPopout) {
                            try {
                                await window.electronAPI.openChatPopout();
                            } catch (err) {
                                console.error('[Widget] Error opening chat popout:', err);
                            }
                        } else {
                            console.error('[Widget] electronAPI or openChatPopout not available');
                        }
                    });
                }
                
                // Show All and Hide All test users buttons
                const btnShowAll = document.getElementById('btnShowAll');
                const btnHideAll = document.getElementById('btnHideAll');
                
                if (btnShowAll) {
                    btnShowAll.addEventListener('click', async () => {
                        await showAllTestUsers();
                    });
                }
                
                if (btnHideAll) {
                    btnHideAll.addEventListener('click', async () => {
                        await hideAllTestUsers();
                    });
                }

                if (btnKickAllUsers && !btnKickAllUsers.hasAttribute('data-listener-attached')) {
                    btnKickAllUsers.setAttribute('data-listener-attached', 'true');
                    btnKickAllUsers.addEventListener('click', async () => {
                        if (!window.electronAPI || !window.electronAPI.kickAllUsers) return;
                        // Use simple confirm for widget menu (no custom modal available)
                        if (!confirm('Kick ALL (non-test) users from the campfire?')) return;
                        try {
                            await window.electronAPI.kickAllUsers();
                            if (typeof loadWidgetMembers === 'function') setTimeout(() => loadWidgetMembers(), 250);
                        } catch (e) {
                            console.error('Error kicking all users:', e);
                            alert('Failed to kick all users.');
                        }
                    });
                }

                if (btnJoinControlled && !btnJoinControlled.hasAttribute('data-listener-attached')) {
                    btnJoinControlled.setAttribute('data-listener-attached', 'true');
                    btnJoinControlled.addEventListener('click', async () => {
                        if (!window.electronAPI || !window.electronAPI.joinAllUsers) return;
                        if (!confirm('Join all users (Controlled - follows join rules)?')) return;
                        try {
                            await window.electronAPI.joinAllUsers({ mode: 'controlled' });
                            if (typeof loadWidgetMembers === 'function') setTimeout(() => loadWidgetMembers(), 250);
                        } catch (e) {
                            console.error('Error joining all users:', e);
                            alert('Failed to join all users.');
                        }
                    });
                }

                if (btnJoinChaos && !btnJoinChaos.hasAttribute('data-listener-attached')) {
                    btnJoinChaos.setAttribute('data-listener-attached', 'true');
                    btnJoinChaos.addEventListener('click', async () => {
                        if (!window.electronAPI || !window.electronAPI.joinAllUsers) return;
                        if (!confirm('Join all users (Chaos - overrides join rules)?')) return;
                        try {
                            await window.electronAPI.joinAllUsers({ mode: 'chaos' });
                            if (typeof loadWidgetMembers === 'function') setTimeout(() => loadWidgetMembers(), 250);
                        } catch (e) {
                            console.error('Error joining all users:', e);
                            alert('Failed to join all users.');
                        }
                    });
                }
                
                if (btnEnd && !btnEnd.hasAttribute('data-listener-attached')) {
                    btnEnd.setAttribute('data-listener-attached', 'true');
                    btnEnd.addEventListener('click', async () => {
                        if (confirm('Are you sure you want to shut down the widget and all servers?')) {
                            await window.electronAPI.shutdownApp();
                        }
                    });
                }
                
                // hasSimulatedJoins is now declared at module level (line 6812) to prevent duplicates
                
                if (window.electronAPI) {
                    window.electronAPI.onTwitchConnected(async () => {
                        if (statusIndicator) statusIndicator.classList.add('connected');
                        if (statusText) statusText.textContent = 'Connected';
                        
                        // Now that Twitch is connected, simulate !join for streamer and bot
                        // Only do this once to prevent duplicate joins
                        if (!hasSimulatedJoins && widget && widget.simulateJoinForConnectedUsers) {
                            hasSimulatedJoins = true;
                            console.log('[Twitch Connected] Simulating join for streamer and bot...');
                            await widget.simulateJoinForConnectedUsers();
                        }
                    });
                    
                    window.electronAPI.onTwitchDisconnected(() => {
                        if (statusIndicator) statusIndicator.classList.remove('connected');
                        if (statusText) statusText.textContent = 'Disconnected';
                    });
                    
                    // Listen for chat messages from Twitch (bubbles above joined users)
                    window.electronAPI.onChatMessage((data) => {
                        const msg = String(data && data.message ? data.message : '').trim();
                        if (msg.startsWith('!')) return; // Never show command-like messages as bubbles
                        if (widget && data.username && msg) {
                            // Prevent duplicate processing by marking the message as processed
                            if (!data._processed) {
                                data._processed = true;
                                widget.showChatMessage(data.username, data.message, data.userId, data.emotes, data.allowBubble !== false, data.isAction || false);
                            }
                        }
                    });

                    // Third-party emotes (BTTV/FFZ/7TV) are pushed from main once connected.
                    // Used to render emote codes like "heafthCamp" when Twitch IRC tags.emotes is empty.
                    window.__thirdPartyEmotes = window.__thirdPartyEmotes || {};
                    if (window.electronAPI.getThirdPartyEmotes) {
                        window.electronAPI.getThirdPartyEmotes()
                            .then((data) => {
                                window.__thirdPartyEmotes = (data && data.emotes && typeof data.emotes === 'object') ? data.emotes : {};
                            })
                            .catch(() => {});
                    }
                    if (window.electronAPI.onThirdPartyEmotesUpdate) {
                        window.electronAPI.onThirdPartyEmotesUpdate((data) => {
                            window.__thirdPartyEmotes = (data && data.emotes && typeof data.emotes === 'object') ? data.emotes : {};
                        });
                    }
                    
                    // Refresh widget Members list when chatters/potential members update (so it stays in sync with dashboard)
                    if (window.electronAPI.onPotentialMembersUpdate) {
                        window.electronAPI.onPotentialMembersUpdate(() => {
                            if (typeof loadWidgetMembers === 'function') loadWidgetMembers();
                        });
                    }

                    // Keep "Active in chat" (last N minutes) display fresh while Members tab is open
                    if (!_widgetMembersStatusInterval) {
                        _widgetMembersStatusInterval = setInterval(() => {
                            try {
                                const sec = document.getElementById('membersSection');
                                if (!sec || !sec.classList.contains('active')) return;
                                const cached = window.__widgetMembersCache;
                                if (Array.isArray(cached) && typeof renderWidgetMembers === 'function') {
                                    renderWidgetMembers(cached);
                                }
                            } catch (e) { /* ignore */ }
                        }, 30 * 1000);
                    }
                    
                    window.electronAPI.getTwitchStatus().then(status => {
                        if (status.connected) {
                            if (statusIndicator) statusIndicator.classList.add('connected');
                            if (statusText) statusText.textContent = 'Connected';
                        }
                    }).catch(err => {
                        console.error('[Menu Bar] Error getting Twitch status:', err);
                    });
                }
            } else if (isDesktopApp) {
                setTimeout(() => {
                    if (typeof window.electronAPI !== 'undefined') {
                        initDesktopMenuBar();
                    }
                }, 500);
            }
        }
        
        // Initialize menu bar
        console.log('[Menu Bar] Script loaded, readyState:', document.readyState);
        
        if (document.readyState === 'complete' || document.readyState === 'interactive') {
            setTimeout(initDesktopMenuBar, 100);
        } else {
            document.addEventListener('DOMContentLoaded', () => {
                setTimeout(initDesktopMenuBar, 100);
            });
        }
        
        window.addEventListener('load', () => {
            setTimeout(initDesktopMenuBar, 200);
        });
        
        setTimeout(() => {
            const menuBar = document.getElementById('desktopMenuBar');
            if (menuBar && !menuBar.classList.contains('desktop-app')) {
                initDesktopMenuBar();
            }
        }, 1000);
        
        // ============================================
        // XSS HELPERS (escape before innerHTML/onclick)
        // ============================================
        function escapeHtml(str) { if (str == null) return ''; var s = String(str); return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#39;'); }
        function escapeJsQuoted(str) { if (str == null) return ''; return String(str).replace(/\\/g,'\\\\').replace(/'/g,"\\'").replace(/\r/g,'\\r').replace(/\n/g,'\\n'); }

        // ============================================
        // INTEGRATED DASHBOARD FUNCTIONS
        // ============================================
        function openDashboard(tab = 'quick') {
            const overlay = document.getElementById('dashboardOverlay');
            if (overlay) {
                overlay.classList.add('active');
                switchDashboardTab(tab);
                loadDashboardData();
            }
        }
        
        function closeDashboard() {
            const overlay = document.getElementById('dashboardOverlay');
            if (overlay) {
                overlay.classList.remove('active');
            }
        }
        
        function switchDashboardTab(tabName) {
            console.log('[Dashboard] Switching to tab:', tabName);
            
            // Update tab buttons
            document.querySelectorAll('.dashboard-tab').forEach(tab => {
                tab.classList.remove('active');
                if (tab.onclick && tab.onclick.toString().includes(tabName)) {
                    tab.classList.add('active');
                }
            });
            
            // Update sections
            document.querySelectorAll('.dashboard-section').forEach(section => {
                section.classList.remove('active');
            });
            
            const sectionMap = {
                'quick': 'quickSection',
                'members': 'membersSection'
            };
            
            const targetSection = document.getElementById(sectionMap[tabName]);
            if (targetSection) {
                targetSection.classList.add('active');
                console.log('[Dashboard] Activated section:', sectionMap[tabName]);
                
                // Load members when switching to members tab
                if (tabName === 'members') {
                    loadWidgetMembers();
                }
            } else {
                console.error('[Dashboard] Section not found:', sectionMap[tabName]);
            }
        }
        
        async function loadWidgetMembers() {
            const membersList = document.getElementById('membersList');
            if (!membersList) return;
            
            try {
                // Get active users from widget
                const users = window.widget?.users || [];
                
                // Also check electronAPI for more complete data
                let allMembers = [];
                if (window.electronAPI && window.electronAPI.getActiveUsers) {
                    const activeUsers = await window.electronAPI.getActiveUsers();
                    const potentialUsers = await window.electronAPI.getPotentialMembers?.() || [];
                    const userMap = new Map();
                    const usernameToKey = new Map(); // usernameLower -> canonical key
                    const normName = (v) => (v ? String(v).toLowerCase() : '');
                    const normId = (v) => (v == null ? '' : String(v));
                    const keyFor = (userId, username) => {
                        const id = normId(userId);
                        const name = normName(username);
                        if (id) {
                            if (name) usernameToKey.set(name, id);
                            return id;
                        }
                        if (name) return usernameToKey.get(name) || name;
                        return '';
                    };
                    const upsert = (rec) => {
                        const key = keyFor(rec.userId, rec.username);
                        if (!key) return;
                        const existing = userMap.get(key);
                        if (existing) {
                            existing.joined = !!existing.joined || !!rec.joined;
                            if (rec.username) existing.username = existing.username || rec.username;
                            existing.userId = key;
                            if (rec.color) existing.color = rec.color;
                            if (rec.twitchColor) existing.twitchColor = rec.twitchColor;
                            if (rec.lastMessage) existing.lastMessage = Math.max(existing.lastMessage || 0, rec.lastMessage);
                        } else {
                            userMap.set(key, { ...rec, userId: key });
                        }
                    };

                    const activeSet = new Set();
                    const potentialSet = new Set();
                    const widgetSet = new Set();
                    const addPresence = (set, userId, username) => {
                        const id = normId(userId);
                        const name = normName(username);
                        if (id) set.add(id);
                        if (name) set.add(name);
                    };
                    activeUsers.forEach(u => addPresence(activeSet, u.userId, u.username));
                    potentialUsers.forEach(p => addPresence(potentialSet, p.userId, p.username));
                    users.forEach(w => addPresence(widgetSet, w.userId, w.username));

                    // Order matters: add sources with userId first so later username-only rows merge correctly
                    activeUsers.forEach(u => upsert({ username: u.username, userId: u.userId, joined: true, restored: false, twitchColor: u.twitchColor || null, color: u.color || null }));
                    users.forEach(u => upsert({ username: u.username, userId: u.userId, joined: true, restored: true, twitchColor: u.twitchColor || null, color: u.color || null }));
                    potentialUsers.forEach(p => upsert({ username: p.username, userId: p.userId, joined: false, restored: false, twitchColor: p.color || null, lastMessage: p.lastMessage || null }));
                    
                    // Ensure test users are always present
                    ['TestUser1', 'TestUser2', 'TestUser3'].forEach(testUser => {
                        upsert({ username: testUser, userId: testUser.toLowerCase(), joined: false, restored: false });
                    });
                    
                    allMembers = Array.from(userMap.values()).map(m => {
                        const id = normId(m.userId);
                        const name = normName(m.username);
                        const inWidget = widgetSet.has(id) || (name && widgetSet.has(name));
                        const inActive = activeSet.has(id) || (name && activeSet.has(name));
                        const inPotential = potentialSet.has(id) || (name && potentialSet.has(name));
                        return {
                            ...m,
                            inCampfire: !!(inWidget || inActive),
                            inChat: !!inPotential,
                            restored: !!(inWidget && !inActive && !inPotential)
                        };
                    });
                } else {
                    // Fallback: just use widget users
                    allMembers = users.map(u => ({
                        username: u.username,
                        userId: u.userId || u.username.toLowerCase(),
                        joined: true,
                        color: u.color
                    }));
                }
                
                if (allMembers.length === 0) {
                    membersList.innerHTML = '<p style="color: #888; text-align: center; padding: 20px;">No members yet. Users will appear here when they join.</p>';
                    return;
                }
                
                window.__widgetMembersCache = allMembers;
                renderWidgetMembers(allMembers);
            } catch (error) {
                console.error('[Widget] Error loading members:', error);
                membersList.innerHTML = '<p style="color: #f44; text-align: center; padding: 20px;">Error loading members</p>';
            }
        }

        const WIDGET_ACTIVE_WINDOW_MS = 10 * 60 * 1000; // "recently active in chat" window
        let _widgetMembersStatusInterval = null;

        function renderWidgetMembers(allMembers) {
            const membersList = document.getElementById('membersList');
            if (!membersList) return;
            const now = Date.now();
            if (!Array.isArray(allMembers) || allMembers.length === 0) {
                membersList.innerHTML = '<p style="color: #888; text-align: center; padding: 20px;">No members yet. Users will appear here when they join.</p>';
                return;
            }

            // Render member list with identical styling to dashboard
            const uid = m => escapeJsQuoted(m.userId || '');
            const uname = m => escapeJsQuoted(m.username || '');
            const unameH = m => escapeHtml(m.username || '');

            membersList.innerHTML = allMembers.map(member => {
                    const isTestUser = member.username && member.username.startsWith('TestUser');
                    const inChat = !!member.inChat;
                    const lastMessage = member.lastMessage || 0;
                    const recentlyActive = !!(lastMessage && (now - lastMessage) <= WIDGET_ACTIVE_WINDOW_MS);
                    const inCampfire = !!(member.inCampfire || member.joined);
                    const status = inCampfire ? (inChat ? 'joined' : 'sleepy') : (recentlyActive ? 'active' : 'not-joined');
                    const twitchColor = member.twitchColor || member.color || null;
                    const nameColor = (status === 'joined' || status === 'sleepy') ? (twitchColor || '#fff') : (status === 'active' ? '#fff' : '#777');
                    const zzz = (status === 'sleepy') ? '<span class="member-zzz" title="In campfire, but not in chat (sleepy/disconnected?)">zzz</span>' : '';
                    const statusText =
                        (status === 'joined') ? 'Joined' :
                        (status === 'sleepy') ? 'Sleeping' :
                        (status === 'active') ? 'Active in chat' :
                        'Not joined';
                    const u = uid(member);
                    const n = uname(member);
                    const nh = unameH(member);
                    if (isTestUser) {
                        return `
                            <div class="member-item" style="background: #1f1f1f; border: 1px solid #3a3a3a; border-radius: 6px; padding: 8px 12px; margin-bottom: 8px; display: flex; justify-content: space-between; align-items: center; min-height: 40px;">
                                <div class="member-info" style="flex: 1; display: flex; align-items: center; gap: 10px;">
                                    <span class="member-name" style="font-family: 'UsernameFont', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; font-weight: bold; font-size: 14px; color: #fff;">${nh}</span>
                                    <span class="member-status" style="font-size: 11px; color: #888;">${member.joined ? 'Joined' : 'Not joined'}</span>
                                </div>
                                <div class="member-actions" style="display: flex; gap: 8px; align-items: center;">
                                    <button onclick="widgetOpenMemberEdit('${u}', '${n}')" style="padding: 6px 12px; background: #444; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: 600;">Edit</button>
                                    <div class="toggle-switch ${member.joined ? 'active' : ''}" onclick="widgetToggleTestUser('${u}', '${n}')" style="cursor: pointer; width: 50px; height: 24px; background: ${member.joined ? '#4caf50' : '#444'}; border-radius: 12px; position: relative; transition: background 0.3s; box-shadow: inset 0 1px 3px rgba(0,0,0,0.3);">
                                        <div style="position: absolute; top: 2px; left: ${member.joined ? '28px' : '2px'}; width: 20px; height: 20px; background: white; border-radius: 50%; transition: left 0.3s ease; box-shadow: 0 2px 4px rgba(0,0,0,0.2);"></div>
                                    </div>
                                </div>
                            </div>
                        `;
                    } else {
                        const restoredIcon = member.restored ? '<span title="Restored from previous session; may have disconnected" style="margin-left:4px;opacity:0.85;" aria-label="Restored">üìå</span>' : '';
                        return `
                            <div class="member-item" style="background: #1f1f1f; border: 1px solid #3a3a3a; border-radius: 6px; padding: 8px 12px; margin-bottom: 8px; display: flex; justify-content: space-between; align-items: center; min-height: 40px;">
                                <div class="member-info" style="flex: 1; display: flex; align-items: center; gap: 10px;">
                                    <span class="member-name status-${status}" style="font-family: 'UsernameFont', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; font-weight: bold; font-size: 14px; color: ${nameColor};">${nh}</span>${zzz}${restoredIcon}
                                    <span class="member-status" style="font-size: 11px; color: #888;">${statusText}</span>
                                </div>
                                <div class="member-actions" style="display: flex; gap: 8px; align-items: center;">
                                    ${member.joined 
                                        ? `<button onclick="widgetLeaveMember('${u}', '${n}')" style="padding: 6px 12px; background: #ff4444; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: 600;">Leave</button>`
                                        : `<button onclick="widgetJoinMember('${u}', '${n}')" style="padding: 6px 12px; background: #4caf50; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: 600;">Join</button>`
                                    }
                                    <button onclick="widgetOpenMemberEdit('${u}', '${n}')" style="padding: 6px 12px; background: #444; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: 600;">Edit</button>
                                </div>
                            </div>
                        `;
                    }
                }).join('');
        }
        
        async function widgetToggleTestUser(userId, username) {
            if (!window.electronAPI) return;
            
            try {
                const widgetUsers = await window.electronAPI.getWidgetUsers?.() || window.widget?.users || [];
                const isInWidget = widgetUsers.find(w => {
                    const wUserId = (w.userId || '').toLowerCase();
                    const wUsername = (w.username || '').toLowerCase();
                    const checkUserId = (userId || '').toLowerCase();
                    const checkUsername = (username || '').toLowerCase();
                    return wUserId === checkUserId || wUsername === checkUsername;
                });
                
                if (isInWidget) {
                    // Remove user
                    const result = await window.electronAPI.removeTestUserFromWidget(userId, username);
                    if (!result || !result.success) {
                        console.error('Failed to remove test user:', result);
                        return;
                    }
                } else {
                    // Add user
                    const result = await window.electronAPI.addTestUserToWidget(userId, username);
                    if (!result || !result.success) {
                        console.error('Failed to add test user:', result);
                        return;
                    }
                }
                
                // Refresh the members list
                setTimeout(() => loadWidgetMembers(), 200);
                
            } catch (error) {
                console.error('Error toggling test user:', error);
            }
        }
        
        async function widgetJoinMember(userId, username) {
            if (!window.electronAPI || !window.electronAPI.joinMember) {
                alert('Join functionality not available');
                return;
            }
            
            try {
                const result = await window.electronAPI.joinMember(userId, username);
                if (result && result.success) {
                    setTimeout(() => loadWidgetMembers(), 200);
                } else {
                    alert('Failed to join member');
                }
            } catch (error) {
                console.error('Error joining member:', error);
                alert('Error: ' + error.message);
            }
        }
        
        async function widgetLeaveMember(userId, username) {
            if (!window.electronAPI || !window.electronAPI.kickMember) {
                alert('Leave functionality not available');
                return;
            }
            
            try {
                const result = await window.electronAPI.kickMember(userId);
                if (result && result.success) setTimeout(() => loadWidgetMembers(), 200);
            } catch (error) {
                console.error('Error removing member:', error);
                alert('Error: ' + error.message);
            }
        }
        
        function widgetOpenMemberEdit(userId, username) {
            // Open the Viewer Dashboard (sprite settings) for this member
            if (window.electronAPI && window.electronAPI.openMemberDashboard) {
                window.electronAPI.openMemberDashboard(userId, username);
            } else {
                alert(`Edit settings for ${username} - Viewer Dashboard not available`);
            }
        }
        
        async function removeTestUser(userId, username) {
            if (!window.electronAPI || !window.electronAPI.removeTestUserFromWidget) {
                alert('Test user removal not available');
                return;
            }
            
            try {
                const result = await window.electronAPI.removeTestUserFromWidget(userId, username);
                if (result && result.success) {
                    // Refresh the members list
                    setTimeout(() => loadWidgetMembers(), 200);
                } else {
                    alert('Failed to remove test user');
                }
            } catch (error) {
                console.error('Error removing test user:', error);
                alert('Error: ' + error.message);
            }
        }
        
        function openFullSettings() {
            if (window.electronAPI && window.electronAPI.openDashboard) {
                closeDashboard();
                window.electronAPI.openDashboard();
            }
        }
        
        function updateMaxUsers() {
            const maxUsers = document.getElementById('maxUsers')?.value;
            if (maxUsers && window.widget) {
                const maxUsersInt = parseInt(maxUsers);
                window.widget.updateSettings({ maxUsers: maxUsersInt });
            }
        }
        
        async function loadDashboardData(opts = {}) {
            const silent = !!opts.silent;
            // Load current settings from localStorage (source of truth) to ensure sync with Dashboard
            // This ensures Quick Settings and Dashboard are always in sync
            try {
                const savedSettings = JSON.parse(localStorage.getItem('campfireWidgetSettings') || '{}');
                const settings = window.widget ? { ...window.widget.settings, ...savedSettings } : savedSettings;
                
                // Populate sprite mode
                const spriteModeSelect = document.getElementById('spriteMode');
                if (spriteModeSelect && settings.spriteMode) {
                    spriteModeSelect.value = settings.spriteMode;
                }
                
                // Populate max users
                const maxUsersInput = document.getElementById('maxUsers');
                if (maxUsersInput && settings.maxUsers) {
                    maxUsersInput.value = settings.maxUsers;
                }
                
                // Populate join method
                const joinMethodSelect = document.getElementById('joinMethod');
                if (joinMethodSelect && settings.joinMethod) {
                    joinMethodSelect.value = settings.joinMethod;
                }

                // Populate join command/emote name
                const joinCmdEl = document.getElementById('quickJoinCommand');
                if (joinCmdEl) joinCmdEl.value = settings.command || '!join';
                const joinEmoteEl = document.getElementById('quickJoinEmote');
                if (joinEmoteEl) joinEmoteEl.value = settings.emoteName || '';

                // Populate mute settings
                const muteEl = document.getElementById('muteChatBubbles');
                if (muteEl) muteEl.checked = settings.muteChatBubbles === true;
                const opt = document.getElementById('muteChatBubblesOptions');
                if (opt) opt.style.display = (settings.muteChatBubbles === true) ? 'block' : 'none';
                const vip = document.getElementById('muteAllowVip'); if (vip) vip.checked = settings.muteAllowVip === true;
                const mod = document.getElementById('muteAllowMod'); if (mod) mod.checked = settings.muteAllowMod === true;
                const t1 = document.getElementById('muteAllowTier1'); if (t1) t1.checked = settings.muteAllowTier1 === true;
                const t2 = document.getElementById('muteAllowTier2'); if (t2) t2.checked = settings.muteAllowTier2 === true;
                const t3 = document.getElementById('muteAllowTier3'); if (t3) t3.checked = settings.muteAllowTier3 === true;
                
                // Show/hide join settings UI without saving back (prevents sync loops).
                if (typeof updateJoinMethodUIOnly === 'function') {
                    updateJoinMethodUIOnly();
                } else if (typeof updateJoinMethod === 'function' && !silent) {
                    // Backward compatible fallback (only when explicitly requested)
                    updateJoinMethod();
                }
            } catch (err) {
                console.error('Error loading dashboard data:', err);
            }
            
            // Load Twitch config from electron
            if (window.electronAPI && window.electronAPI.getTwitchConfig) {
                try {
                    const config = await window.electronAPI.getTwitchConfig();
                    if (config) {
                        const usernameInput = document.getElementById('twitchUsername');
                        const channelInput = document.getElementById('twitchChannel');
                        if (usernameInput) usernameInput.value = config.username || '';
                        if (channelInput) channelInput.value = config.channel || '';
                    }
                } catch (err) {
                    console.error('Failed to load Twitch config:', err);
                }
            }
            
            // Load members list
            if (window.widget && window.widget.users) {
                updateMembersList();
            }
        }
        
        async function showAllTestUsers() {
            if (window.electronAPI && window.electronAPI.joinAllTestUsers) {
                try {
                    await window.electronAPI.joinAllTestUsers();
                    updateMembersList();
                } catch (err) {
                    console.error('Failed to show test users:', err);
                    alert('Failed to show test users: ' + err.message);
                }
            }
        }
        
        async function hideAllTestUsers() {
            if (window.electronAPI && window.electronAPI.kickAllTestUsers) {
                try {
                    await window.electronAPI.kickAllTestUsers();
                    updateMembersList();
                } catch (err) {
                    console.error('Failed to hide test users:', err);
                    alert('Failed to hide test users: ' + err.message);
                }
            }
        }
        
        function updateMembersList() {
            const membersList = document.getElementById('membersList');
            if (!membersList) return;
            
            if (!window.widget || !window.widget.users || window.widget.users.length === 0) {
                membersList.innerHTML = '<p style="color: #888;">No members yet. Users will appear here when they join.</p>';
                return;
            }
            
            membersList.innerHTML = window.widget.users.map(user => {
                const u = escapeJsQuoted(user.userId || user.username || '');
                const nh = escapeHtml(user.username || '');
                // Show status based on user state
                const statusText = user.state === 'joined' ? 'Joined' :
                                 user.state === 'active' ? 'Active' :
                                 user.state === 'sleepy' ? 'Idle' :
                                 user.state === 'afk' ? 'AFK' :
                                 user.state === 'lurk' ? 'Lurking' : 'Unknown';
                return `
                <div class="member-item">
                    <div>
                        <span class="member-name">${nh}</span>
                        <span class="member-status">${statusText}</span>
                    </div>
                    <div class="member-actions">
                        <button class="button button-secondary" style="padding: 6px 12px; font-size: 12px;" onclick="kickUser('${u}')">Remove</button>
                    </div>
                </div>
            `;
            }).join('');
        }
        
        async function kickUser(userId) {
            if (window.electronAPI && window.electronAPI.kickUser) {
                try {
                    await window.electronAPI.kickUser(userId);
                    updateMembersList();
                } catch (err) {
                    console.error('Failed to kick user:', err);
                }
            }
        }
        
        async function saveTwitchConfig() {
            const username = document.getElementById('twitchUsername')?.value;
            const channel = document.getElementById('twitchChannel')?.value;
            
            if (!username || !channel) {
                alert('Please enter both username and channel');
                return;
            }
            
            if (window.electronAPI && window.electronAPI.saveTwitchConfig) {
                try {
                    await window.electronAPI.saveTwitchConfig({ username, channel });
                    alert('Twitch configuration saved! The widget will attempt to connect.');
                } catch (err) {
                    console.error('Failed to save Twitch config:', err);
                    alert('Failed to save configuration: ' + err.message);
                }
            }
        }
        
        // Flag to prevent infinite loops when syncing dropdowns
        let _syncingSpriteMode = false;
        
        function updateSpriteMode() {
            // Prevent infinite loops
            if (_syncingSpriteMode) return;
            
            const spriteMode = document.getElementById('spriteMode')?.value;
            if (spriteMode && window.widget) {
                _syncingSpriteMode = true;
                try {
                    // Use updateSettings instead of reloading - this preserves users
                    window.widget.updateSettings({ spriteMode: spriteMode });
                    // Also update localStorage for persistence and sync with Dashboard
                    const currentSettings = JSON.parse(localStorage.getItem('campfireWidgetSettings') || '{}');
                    // Only save if value actually changed
                    if (currentSettings.spriteMode !== spriteMode) {
                        currentSettings.spriteMode = spriteMode;
                        localStorage.setItem('campfireWidgetSettings', JSON.stringify(currentSettings));
                        // Dispatch event for same-window sync (Dashboard overlay doesn't use storage events)
                        window.dispatchEvent(new CustomEvent('campfireSettingsUpdate', { detail: { spriteMode: spriteMode } }));
                    }
                } catch (e) {
                    console.error('Error saving sprite mode:', e);
                } finally {
                    _syncingSpriteMode = false;
                }
            }
        }
        
        function updateJoinMethodUIOnly() {
            const joinMethod = document.getElementById('joinMethod')?.value;
            const quickCheerSettings = document.getElementById('quickCheerSettings');
            const quickCommandSettings = document.getElementById('quickCommandSettings');
            const quickEmoteSettings = document.getElementById('quickEmoteSettings');
            if (quickCheerSettings) quickCheerSettings.style.display = (joinMethod === 'cheer') ? 'block' : 'none';
            if (quickCommandSettings) quickCommandSettings.style.display = (joinMethod === 'command') ? 'block' : 'none';
            if (quickEmoteSettings) quickEmoteSettings.style.display = (joinMethod === 'emote') ? 'block' : 'none';
        }

        function updateJoinMethod(opts = {}) {
            const silent = !!opts.silent;
            updateJoinMethodUIOnly();

            if (silent) return;

            const joinMethod = document.getElementById('joinMethod')?.value;
            const cmd = document.getElementById('quickJoinCommand')?.value || '!join';
            const emoteName = document.getElementById('quickJoinEmote')?.value || '';
            const cheerMethod = document.getElementById('quickCheerType')?.value || 'bits';
            const cheerAmount = parseInt(document.getElementById('quickCheerAmount')?.value || 100, 10);

            if (!joinMethod || !window.widget) return;

            const patch = { joinMethod };
            if (joinMethod === 'command') patch.command = cmd.trim() || '!join';
            if (joinMethod === 'emote') patch.emoteName = emoteName.trim();
            if (joinMethod === 'cheer') {
                patch.cheerMethod = cheerMethod;
                patch.cheerAmount = Number.isFinite(cheerAmount) ? cheerAmount : 100;
            }

            // Apply to widget and persist so Dashboard mirrors it too
            try {
                window.widget.updateSettings(patch);
                const currentSettings = JSON.parse(localStorage.getItem('campfireWidgetSettings') || '{}');
                const merged = { ...currentSettings, ...patch };
                localStorage.setItem('campfireWidgetSettings', JSON.stringify(merged));
                window.dispatchEvent(new CustomEvent('campfireSettingsUpdate', { detail: patch }));
                if (window.electronAPI && window.electronAPI.saveSettings) {
                    window.electronAPI.saveSettings(merged).catch(() => {});
                }
            } catch (e) {
                console.error('Error saving join settings:', e);
            }
        }

        function updateMuteChatBubbles() {
            if (!window.widget) return;
            const muted = document.getElementById('muteChatBubbles')?.checked === true;
            const opt = document.getElementById('muteChatBubblesOptions');
            if (opt) opt.style.display = muted ? 'block' : 'none';
            const patch = {
                muteChatBubbles: muted,
                muteAllowVip: document.getElementById('muteAllowVip')?.checked === true,
                muteAllowMod: document.getElementById('muteAllowMod')?.checked === true,
                muteAllowTier1: document.getElementById('muteAllowTier1')?.checked === true,
                muteAllowTier2: document.getElementById('muteAllowTier2')?.checked === true,
                muteAllowTier3: document.getElementById('muteAllowTier3')?.checked === true
            };
            try {
                window.widget.updateSettings(patch);
                const currentSettings = JSON.parse(localStorage.getItem('campfireWidgetSettings') || '{}');
                const merged = { ...currentSettings, ...patch };
                localStorage.setItem('campfireWidgetSettings', JSON.stringify(merged));
                if (window.electronAPI && window.electronAPI.saveSettings) {
                    window.electronAPI.saveSettings(merged).catch(() => {});
                }
            } catch (e) {
                console.error('Error saving mute settings:', e);
            }
        }
        
        // Close dashboard with Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeDashboard();
            }
        });
        
        // Close dashboard when clicking backdrop
        document.getElementById('dashboardOverlay')?.addEventListener('click', (e) => {
            if (e.target.id === 'dashboardOverlay') {
                closeDashboard();
            }
        });
    </script>
</body>
</html>
